[{"data":1,"prerenderedAt":1288},["ShallowReactive",2],{"search-api":3},[4,11,23,35,44,53,66,77,88,98,107,117,124,133,141,150,158,167,174,181,189,199,206,214,226,233,241,249,256,263,270,281,288,296,305,312,319,334,347,355,364,374,384,392,403,413,420,428,435,443,450,458,465,472,480,487,494,501,508,517,527,539,548,559,568,575,582,589,598,606,641,654,664,674,686,699,727,738,749,756,764,773,781,789,796,810,818,827,835,842,849,859,872,887,901,912,924,940,949,956,965,972,981,993,1005,1016,1023,1031,1040,1050,1065,1077,1088,1099,1110,1120,1127,1134,1149,1162,1170,1181,1188,1197,1207,1215,1222,1236,1248,1255,1262,1269,1278],{"id":5,"path":6,"dir":7,"title":8,"description":7,"keywords":9,"body":10},"content:0.index.md","/","","Головна | arakviel.com",[],"     Всі навчальні матеріали   Тут буде опис     Матеріали по Android (Java)  Далі більше...",{"id":12,"path":13,"dir":14,"title":15,"description":7,"keywords":16,"body":22},"content:1.android:1.lesson1:1.first-project.md","/android/lesson1/first-project","lesson1","Перший проєкт в Android Studio",[17,18,19,20,21],"Створення першого застосунку в Android Studio","Вибір шаблону Empty Activity у Android Studio","Налаштування проєкту в Android Studio","Структура проєкту в Android Studio","Запуск проєкту","  Перший проєкт в Android Studio  Створення першого застосунку в Android Studio  Тепер створимо перший застосунок у середовищі   Android Studio  для операційної системи Android. Відкриймо Android Studio та на початковому екрані оберіть пункт   New Project :\n   Створення проєкту в Android Studio    При створенні проєкту   Android Studio  запропонує обрати шаблон проєкту.   Вибір шаблону   Empty Activity  у Android Studio  Android Studio пропонує різні шаблони для різних сценаріїв. Для створення застосунку на   Java  оберіть шаблон   Empty Views Activity , який надає найпростіший функціонал для початку, і натисніть кнопку   Next .  Після цього з’явиться вікно налаштувань нового проєкту:\n    Налаштування проєкту в Android Studio  У вікні створення нового проєкту можна встановити початкові параметри:    Name : введіть назву застосунку. Наприклад,   HelloApp .   Package Name : вкажіть ім’я пакету, в якому розміщуватиметься головний клас. Для тестових проєктів використайте   com.example.helloapp .   Save Location : задайте місце розташування файлів проєкту на диску (можна залишити за замовчуванням).   Language : оберіть   Java  як мову програмування (уважно, бо за замовчуванням може стояти Kotlin).   Minimum SDK : встановіть мінімальну підтримувану версію SDK (залиште за замовчуванням).   Мінімальна версія SDK визначає, на яких пристроях ваш застосунок зможе запускатися. Чим вища версія, тим менше підтримуваних пристроїв.  Натисніть   Finish , і Android Studio створить новий проєкт:\n    Структура проєкту в Android Studio    Проєкт в Android може складатися з різних модулів. За замовчуванням створюється один модуль -   app , який має три підпапки:    manifests : містить файл   AndroidManifest.xml , що описує конфігурацію застосунку та визначає його компоненти.   java : зберігає файли коду на Java, розподілені за пакетами. Наприклад,   MainActivity.java  — головний клас, який запускається за замовчуванням.   res : містить ресурси застосунку, організовані в підпапки:\n    drawable : зображення.   layout : графічний інтерфейс (  activity_main.xml ).   mipmap : іконки для різних роздільностей екрана.   values : xml-файли з описом кольорів (  colors.xml ), рядкових ресурсів (  strings.xml ) і тем.  Окремий блок   ini Scripts  містить скрипти для побудови застосунку.   Запуск проєкту  Створений проєкт уже містить базовий функціонал. Наприклад, він виводить текст   \"Hello world!\" . Щоб запустити та протестувати застосунок:   Використовуйте   емулятор  або   реальний пристрій  (рекомендується).  Для тестування на пристрої підключіть його до комп’ютера. У разі необхідності встановіть драйвери.   Увімкнення режиму розробника на пристрої  За замовчуванням опції розробника на смартфонах приховані. Щоб їх увімкнути:   Перейдіть до   Settings > About phone  (в Android 8:   Settings > System > About phone ).  Сім разів натисніть на   Build Number .\n   Далі, активуйте   USB Debugging  у меню розробника:\n  Settings > System > Advanced > Developer options .\n     Запуск застосунку в Android Studio  Підключіть пристрій і натисніть зелену стрілочку на панелі інструментів:\n   Оберіть пристрій і натисніть   OK . Після запуску застосунок з’явиться на екрані пристрою:\n ",{"id":24,"path":25,"dir":14,"title":26,"description":7,"keywords":27,"body":34},"content:1.android:1.lesson1:2.ui-in-as.md","/android/lesson1/ui-in-as","Створення графічного інтерфейсу в Android Studio",[28,29,30,31,32,33],"Огляд","Клас MainActivity","Файл activity_main.xml","Структура activity_main.xml","Налаштування інтерфейсу","TextView","  Створення графічного інтерфейсу в Android Studio  Огляд  Під час створення нового проєкту в   Android Studio  за замовчуванням генерується простий застосунок, який відображає текст   \"Hello Android\" . Розглянемо, як формується цей інтерфейс і як можна його змінити.\n   Клас   MainActivity  Виконання застосунку починається з класу   MainActivity , який зазвичай виглядає так:     package   com.example.helloapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n   }\n  Кожен окремий екран або сторінка в додатку описується таким поняттям як   activity . У літературі можуть використовуватися різні терміни:   екран ,   сторінка , активність.       У цьому випадку я буду використовувати поняття «  activity » . Так ось, якщо ми запустимо застосунок на пристрої, то на екрані ми, по суті, побачимо певну   activity , яка представляє цей інтерфейс.  Клас   MainActivity  успадковує   AppCompatActivity , що представляє окремий екран застосунку.\nМетод   onCreate()  викликається під час створення активності та встановлює макет інтерфейсу за допомогою   setContentView() , передаючи ресурс   R.layout.activity_main .     setContentView  (R.layout.activity_main);\n  Файл   activity_main.xml  Ресурс   R.layout.activity_main  посилається на файл   activity_main.xml , розташований у папці   res/layout .\nЦей файл визначає графічний інтерфейс у форматі XML.\nВ Android Studio можна редагувати його в графічному режимі або безпосередньо в коді.\n  \nПеремикання між режимами здійснюється за допомогою кнопок   Code  та   Design  над редактором.\n   Структура   activity_main.xml  За замовчуванням, файл   activity_main.xml  містить наступну розмітку:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       tools:context  =  \".MainActivity\"  >\n   \n       \u003C  TextView\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Hello World!\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n   \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Основним контейнером є   ConstraintLayout , який забезпечує гнучке розташування елементів.\nВін містить елемент   TextView , що відображає текст   \"Hello World!\" .\nПараметри   layout_constraint...  визначають позиціонування   TextView  відносно батьківського контейнера.  Налаштування інтерфейсу  Для зміни тексту, що відображається, можна відредагувати властивість   android:text  у   TextView :     \u003C  TextView\n       android:layout_width  =  \"wrap_content\"\n       android:layout_height  =  \"wrap_content\"\n       android:text  =  \"Вітаємо у світі Android!\"\n       ... />\n  Кожен простір імен задається таким чином:   xmlns:префікс=«назва_ресурсу» . Наприклад, у     xmlns  :  android  =  \"http://schemas.android.com/apk/res/android\"\n  Назва ресурсу (або URI - Uniform Resource Indicator) -   \"http://schemas.android.com/apk/res/android\" . І цей ресурс зіставляється з префіксом   android  (  xmlns:android ).  Навіщо ці простори імен потрібні? Кожен ресурс або URI визначає деяку функціональність, яка використовується в застосунку, наприклад, надають   теги  та   атрибути , які необхідні для побудови застосунку.   xmlns:android=\"  http://schemas.android.com/apk/res/android \": містить основні атрибути, які надаються платформою Android, застосовуються в елементах керування та визначають їхні візуальні властивості (наприклад, розмір, позиціонування)  xmlns:app=\"  http://schemas.android.com/apk/res-auto \": містить атрибути, що визначені в межах додатка  xmlns:tools=\"  http://schemas.android.com/tools \": застосовується для роботи з режимі дизайнера в Android Studio  І щоб спростити роботу з цими ресурсами, застосовуються префікси. Наприклад, далі ми бачимо:     \u003C  ConstraintLayout\n   android:layout_width  =  \"match_parent\"\n   android:layout_height  =  \"match_parent\"\n   tools:context  =  \".MainActivity\"  >\n  Атрибут   tools:context  визначає, який клас   activity  (екрана додатка) пов'язаний із поточним визначенням інтерфейсу. У цьому випадку це клас   MainActivity . Це дає змогу використовувати в Android Studio різні можливості в режимі дизайнера, які залежать від класу   activity .  TextView  Текстове поле встановлює текст за допомогою атрибута   android:text .     \u003C  TextView\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Hello World!\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n     android  :layout_width  встановлює ширину віджета. Значення wrap_content задає для віджета величину, достатню для відображення в контейнері.    android  :layout_height  встановлює висоту віджета. Значення wrap_content аналогічно встановленню ширини задає для віджета висоту, достатню для відображення в контейнері    android  :text  встановлює текст, який буде виводитися в TextView (у даному випадку це рядок   \"Hello World!\" )    app  :layout_constraintLeft_toLeftOf  =  \"parent\" : вказує, що ліва межа елемента буде вирівнюватися по лівій стороні контейнера ConstraintLayout  Зверніть увагу, що цей атрибут визначено в просторі імен із префіксом app, тобто в \"  http://schemas.android.com/apk/res-auto \".    app  :layout_constraintTop_toTopOf  =  \"parent\" : вказує, що верхня межа елемента вирівнюватиметься по верхній стороні контейнера ConstraintLayout    app  :layout_constraintRight_toRightOf  =  \"parent\" : вказує, що права межа елемента буде вирівнюватися по правій стороні контейнера ConstraintLayout    app  :layout_constraintBottom_toBottomOf  =  \"parent\" : вказує, що нижня межа елемента вирівнюватиметься по нижній стороні контейнера ConstraintLayout  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":36,"path":37,"dir":14,"title":38,"description":39,"keywords":40,"body":43},"content:1.android:1.lesson1:3.ui-intro.md","/android/lesson1/ui-intro","Вступ до створення інтерфейсу","Графічний інтерфейс користувача в Android складається з ієрархії об'єктів android.view.View та android.view.ViewGroup. Кожен об'єкт ViewGroup є контейнером, який містить та впорядковує дочірні об'єкти View. До контейнерів належать такі елементи, як RelativeLayout, LinearLayout, GridLayout, ConstraintLayout та інші.",[41,42],"Підходи до визначення інтерфейсу","Створення інтерфейсу в коді Java","  Вступ до створення інтерфейсу  Графічний інтерфейс користувача в Android складається з ієрархії об'єктів   android.view.View  та   android.view.ViewGroup . Кожен об'єкт   ViewGroup  є контейнером, який містить та впорядковує дочірні об'єкти   View . До контейнерів належать такі елементи, як   RelativeLayout ,   LinearLayout ,   GridLayout ,   ConstraintLayout  та інші.  Прості об'єкти   View  представляють   елементи керування  та інші   віджети , наприклад, кнопки, текстові поля тощо, через які користувач взаємодіє з програмою.    Більшість візуальних елементів, що наслідуються від класу   View , такі як кнопки, текстові поля та інші, розташовані в пакеті   android.widget .  Підходи до визначення інтерфейсу  Існує три стратегії для визначення візуального інтерфейсу:    Програмне створення елементів керування в коді Java.   Оголошення елементів інтерфейсу в XML.   Поєднання обох способів : базові елементи розмітки визначаються в XML, а інші додаються під час виконання програми.  Спочатку розглянемо першу стратегію —   визначення інтерфейсу в коді Java.  Створення інтерфейсу в коді Java  Для роботи з візуальними елементами створимо новий проєкт. Як шаблон проєкту оберемо   Empty Views Activity .\n   Назвемо новий проєкт   ViewsApp .\n   Після створення проєкту нас цікавитимуть два основні файли для створення візуального інтерфейсу: клас   MainActivity  та файл   activity_main.xml , який визначає інтерфейс для цієї activity.\n   Визначимо в класі   MainActivity  найпростіший інтерфейс:     package   com.example.viewapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.widget.TextView  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n   \n           // створення TextView\n           TextView   textView   =   new   TextView  (  this  );\n           // встановлення тексту в TextView\n           textView.  setText  (  \"Hello Android!\"  );\n           // встановлення розміру тексту\n           textView.  setTextSize  (  28  );\n           // встановлення візуального інтерфейсу для activity\n           setContentView  (textView);\n       }\n   }\n  При створенні віджетів у коді Java використовується їхній конструктор, до якого передається контекст цього віджета, тобто об'єкт   android.content.Context , яким у даному випадку є поточний клас   MainActivity .     TextView   textView   =   new   TextView  (  this  );\n  У цьому прикладі весь інтерфейс представлений елементом   TextView , призначеним для виведення тексту. За допомогою методів, які зазвичай починаються на   set , можна встановити різні властивості   TextView . Наприклад, метод   setText()  встановлює текст у полі, а   setTextSize()  задає розмір шрифту.  Для встановлення елемента як інтерфейсу застосунку в коді   Activity  викликається метод   setContentView() , до якого передається візуальний елемент.    EdgeToEdge.  enable  (  this  );  — це метод, який часто використовується в Android для активації \"Edge-to-Edge\" режиму інтерфейсу користувача. Цей режим дозволяє застосунку займати весь екран пристрою, включаючи області біля вирізу (notch), статус-бару та навігаційної панелі.  Такий підхід використовується в сучасних Android-додатках для покращення візуального сприйняття на екранах з вирізами або округлими кутами.   this  — це посилання на поточний контекст (зазвичай   Activity  або   Fragment ), для якого активується режим.     ViewCompat.  setOnApplyWindowInsetsListener  (  findViewById  (R.id.main), (v, insets)   ->   {\n               Insets   systemBars   =   insets.  getInsets  (WindowInsetsCompat.Type.  systemBars  ());\n               v.  setPadding  (systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);\n               return   insets;\n           });\n  Код належить до роботи з віконними вставками (  Window Insets ) в Android і налаштовує відступи для View, щоб враховувати системні елементи, такі як статус-бар, навігаційна панель, або інші системні компоненти. Це забезпечує правильне відображення вмісту на екрані, навіть якщо він розтягується до країв (Edge-to-Edge режим).  Якщо запустити застосунок, отримаємо наступний візуальний інтерфейс:    Аналогічним чином можна створювати складніші інтерфейси. Наприклад,   TextView , вкладений у   ConstraintLayout :     package   com.example.viewapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   androidx.constraintlayout.widget.ConstraintLayout  ;\n   \n   import   android.os.Bundle  ;\n   import   android.widget.TextView  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n   \n           ConstraintLayout   constraintLayout   =   new   ConstraintLayout  (  this  );\n           TextView   textView   =   new   TextView  (  this  );\n           textView.  setText  (  \"Hello Android!\"  );\n           textView.  setTextSize  (  28  );\n           // встановлення параметрів розмірів та розташування елемента\n           ConstraintLayout  .  LayoutParams   layoutParams   =   new   ConstraintLayout.  LayoutParams  (\n                   ConstraintLayout.LayoutParams.WRAP_CONTENT,\n                   ConstraintLayout.LayoutParams.WRAP_CONTENT\n           );\n           // вирівнювання по лівому краю ConstraintLayout\n           layoutParams.leftToLeft   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           // вирівнювання по верхній межі ConstraintLayout\n           layoutParams.topToTop   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           textView.  setLayoutParams  (layoutParams);\n           constraintLayout.  addView  (textView);\n           setContentView  (constraintLayout);\n       }\n   }\n  У цьому випадку ми створюємо   ConstraintLayout  як контейнер для   TextView . Після створення   TextView  встановлюємо його текст та розмір шрифту. Потім створюємо об'єкт   ConstraintLayout.LayoutParams  для визначення параметрів розміру та розташування   TextView  всередині   ConstraintLayout . Встановлюємо вирівнювання по лівому краю та верхній межі контейнера, додаємо   TextView  до   ConstraintLayout  та встановлюємо   ConstraintLayout  як вміст Activity за допомогою   setContentView() .  Знову ж таки зазначу, що для конкретного контейнера конкретні дії можуть відрізнятися, але, як правило,   для всіх характерно три етапи :   Створення об'єкта   ViewGroup.LayoutParams  і встановлення його властивостей  Передача об'єкта   ViewGroup.LayoutParams  у метод   setLayoutParams()  елемента  Передача елемента для додавання в метод   addView()  об'єкта контейнера  Таким чином, ми можемо програмно створювати та налаштовувати інтерфейс користувача без використання XML-розмітки, що може бути корисним у деяких випадках, наприклад, для динамічного створення інтерфейсу під час виконання програми.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":45,"path":46,"dir":14,"title":47,"description":48,"keywords":49,"body":52},"content:1.android:1.lesson1:4.defining-xml.md","/android/lesson1/defining-xml","Визначення інтерфейсу у файлі XML. Файли Layout","Як правило, для визначення візуального інтерфейсу в проєктах під Android використовуються спеціальні файли XML. Ці файли є ресурсами розмітки та містять визначення візуального інтерфейсу у вигляді коду XML. Такий підхід нагадує створення веб-сайтів, де інтерфейс визначається у файлах HTML, а логіка додатку — в коді JavaScript.",[50,51],"Додавання файлу layout","Отримання та управління візуальними елементами в коді","  Визначення інтерфейсу у файлі XML. Файли Layout  Як правило, для визначення візуального інтерфейсу в проєктах під Android використовуються спеціальні файли XML. Ці файли є ресурсами розмітки та містять визначення візуального інтерфейсу у вигляді коду XML. Такий підхід нагадує створення веб-сайтів, де інтерфейс визначається у файлах HTML, а логіка додатку — в коді JavaScript.  Оголошення користувацького інтерфейсу в XML дозволяє відокремити інтерфейс додатку від коду. Це означає, що ми можемо змінювати визначення інтерфейсу без зміни Java-коду. Наприклад, можна створити XML-розмітки для різних орієнтацій екрана, розмірів пристроїв, мов тощо.  Файли розмітки графічного інтерфейсу розташовуються в проєкті в каталозі   res/layout . За замовчуванням при створенні проєкту з порожньою   activity  вже є один файл ресурсів розмітки   activity_main.xml , який може виглядати приблизно так:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       tools:context  =  \".MainActivity\"  >\n    \n       \u003C  TextView\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Hello World!\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  У файлі визначаються всі графічні елементи та їхні атрибути, які складають інтерфейс. При створенні розмітки в XML слід дотримуватися деяких правил: кожен файл розмітки повинен містити один кореневий елемент, який повинен представляти об'єкт   View  або   ViewGroup .  У цьому випадку кореневим елементом є елемент   ConstraintLayout , який містить елемент   TextView .  Як правило, кореневий елемент містить визначення використовуваних просторів імен XML. Наприклад, у коді за замовчуванням у   ConstraintLayout  ми можемо побачити такі атрибути:     xmlns:  android  =  \"http://schemas.android.com/apk/res/android\"\n   xmlns:  app  =  \"http://schemas.android.com/apk/res-auto\"\n   xmlns:  tools  =  \"http://schemas.android.com/tools\"\n  Кожен простір імен задається таким чином:   xmlns:префікс=\"назва_ресурсу\" . Наприклад, у     xmlns:  android  =  \"http://schemas.android.com/apk/res/android\"\n   Назва ресурсу  (або URI - Uniform Resource Indentifier) - \"  http://schemas.android.com/apk/res/android \". І цей ресурс зіставляється з префіксом android (  xmlns:android ). Тобто через префікс ми зможемо посилатися на функціональність цього простору імен.  Кожен простір імен визначає деяку функціональність, яка використовується в застосунку, наприклад, надають   теги  та   атрибути , які необхідні для побудови застосунку.    xmlns:android=\"http://schemas.android.com/apk/res/android\" : містить основні атрибути, які надаються платформою Android, застосовуються в елементах керування та визначають їхні візуальні властивості (наприклад, розмір, позиціонування). Наприклад, у коді   ConstraintLayout  використовується такий атрибут із простору імен   \"http://schemas.android.com/apk/res/android\" :     android:  layout_width  =  \"match_parent\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\" : містить атрибути, що визначені в межах програми. Наприклад, у коді   TextView :     app:  layout_constraintBottom_toBottomOf  =  \"parent\"\n    xmlns:tools=\"http://schemas.android.com/tools\" : застосовується для роботи з режимі дизайнера в Android Studio  Це найпоширеніші простори імен. І зазвичай кожен кореневий елемент (не обов'язково тільки   ConstraintLayout ) їх містить. Однак, якщо ви не плануєте користуватися графічним дизайнером в Android Studio і хочете працювати цілком у коді xml, то відповідно сенсу в просторі імен   \"http://schemas.android.com/tools\"  немає,   і його можна прибрати .  Під час компіляції кожен XML-файл розмітки компілюється в ресурс   View . Завантаження ресурсу розмітки здійснюється в методі   Activity.onCreate . Щоб встановити розмітку для поточного об'єкта   activity , треба в метод   setContentView()  як параметр передати посилання на ресурс розмітки.     setContentView  (R.layout.activity_main);\n  Для отримання посилання на ресурс у коді java необхідно використовувати вираз   R.layout.[назва_ресурсу] .   Назва ресурсу layout  збігатиметься з ім'ям файлу, тому щоб використовувати файл   activity_main.xml  як джерело візуального інтерфейсу, можна визначити наступний код у класі   MainActivity :     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n            \n           // загрузка интерфейса из файла activity_main.xml\n           setContentView  (R.layout.activity_main);\n       }\n   }\n  Додавання файлу layout  Але у нас може бути і кілька різних ресурсів   layout . Як правило, кожен окремий клас   Activity  використовує свій файл   layout . Або для одного класу   Activity  може використовуватися відразу кілька різних файлів   layout .  Наприклад, додамо в проєкт новий файл розмітки інтерфейсу. Для цього натиснемо на папку   res/layout  правою кнопкою миші і в меню, що з'явилося, виберемо пункт   New -> Layout Resource File :\n   Після цього в спеціальному віконці буде запропоновано вказати ім'я і кореневий елемент для файлу   layout :\n   Як назву вкажемо   second_layout . Усі інші налаштування залишимо за замовчуванням:   у полі   Root element  вказується кореневий елемент. За замовчуванням це   androidx .  constraintlayout.widget.ConstraintLayout .  поле   Source  set вказує, куди поміщати новий файл. За замовчуванням це   main  - область проєкту, з якою ми власне працюємо під час розроблення програми.  поле   Directory main  вказує папку в рамках каталогу, обраного в попередній опції, в який власне поміщається новий файл. За замовчуванням для файлів із розміткою інтерфейсу це   layout .  Після цього в папку   res/layout  буде додано новий файл   second_layout.xml , з яким ми можемо працювати так само, як і з   activity_main.xml . Зокрема, відкриємо файл   second_layout.xml  і змінимо його вміст таким чином:     \u003C?  xml version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns  :  android  =  \"http://schemas.android.com/apk/res/android\"\n       android  :  layout_width  =  \"match_parent\"\n       android  :  layout_height  =  \"match_parent\"  >\n    \n       \u003C  TextView\n           android  :  id  =  \"@+id/header\"\n           android  :  text  =  \"Welcome to Android\"\n           android  :  textSize  =  \"26sp\"\n           android  :  layout_width  =  \"match_parent\"\n           android  :  layout_height  =  \"match_parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Тут визначено текстове поле   TextView , яке має такі атрибути:    android:id  - ідентифікатор елемента, через який ми зможемо посилатися на нього в коді. У записі   android:id=\"@+id/header\"  символ   @  вказує XML-парсеру використовувати решту рядка атрибута як ідентифікатор. А знак   +  означає, що якщо для елемента не визначено   id  зі значенням   header , то його слід визначити.   android:text  - текст елемента - на екран виводитиметься рядок   \"Welcome to Android\" .   android:textSize  - висота шрифту (тут   26  одиниць)   android:layout_width  - ширина елемента. Значення   \"match_parent\"  вказує, що елемент буде розтягуватися по всій ширині контейнера   ConstraintLayout   android:layout_height  - висота елемента. Значення   \"match_parent\"  вказує, що елемент буде розтягуватися по всій висоті контейнера   ConstraintLayout  Застосуємо цей файл як визначення графічного інтерфейсу в класі   MainActivity :     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.second_layout);\n       }\n   }\n  Файл інтерфейсу називається   second_layout.xml , тому за замовчуванням для нього створюватиметься ресурс   R.layout.second_layout . Відповідно, щоб його використовувати, ми передаємо його до методу   setContentView . У підсумку ми побачимо на екрані таке:\n   Отримання та управління візуальними елементами в коді  Вище визначений елемент   TextView  має один дуже важливий атрибут -   id  або ідентифікатор елемента. Цей ідентифікатор дає змогу звертатися до елемента, який визначено у файлі xml, з коду Java. Наприклад, перейдемо до класу   MainActivity  і змінимо його код:     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           // встановлюємо як інтерфейс файл second_layout.xml\n           setContentView  (R.layout.second_layout);\n    \n           // отримуємо елемент textView\n           TextView   textView   =   findViewById  (R.id.header);\n           // перевстановлюємо в нього текст\n           textView.  setText  (  \"Hello from Java!\"  );\n       }\n   }\n  За допомогою методу   setContentView()  встановлюється розмітка з файлу   second_layout.xml .  Інший важливий момент, який варто відзначити - отримання візуального елемента   TextView . Оскільки в його коді ми визначили атрибут   android:id , то через цей   id  ми можемо його отримати.   Для отримання елементів за id клас   Activity  має метод   findViewById() . У цей метод передається ідентифікатор ресурсу у вигляді   R.id.[ідентифікатор_елемента] . Цей метод повертає об'єкт   View  - об'єкт базового класу для всіх елементів, тому результат методу ще необхідно привести до типу   TextView .  Далі ми можемо щось зробити з цим елементом, у цьому разі змінюємо його текст.  Причому що важливо, отримання елемента відбувається після того, як у методі   setContentView  було встановлено розмітку, в якій цей візуальний елемент було визначено.  І якщо ми запустимо проект, то побачимо, що   TextView  виводить новий текст:\n   html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":54,"path":55,"dir":14,"title":56,"description":57,"keywords":58,"body":65},"content:1.android:1.lesson1:5.dimensioning.md","/android/lesson1/dimensioning","Визначення розмірів","Розробляючи інтерфейс, ми часто стикаємося з необхідністю задати розміри елементів. У Android можна використовувати як фіксовані значення, так і спеціальні параметри, які адаптуються до контексту використання.",[59,60,61,62,63,64],"Фіксовані значення","Встановлення розмірів","Спеціальні параметри розмірів","Пріоритетність розмірів","Мінімальні та максимальні розміри","Приклад коду","  Визначення розмірів  Розробляючи інтерфейс, ми часто стикаємося з необхідністю задати розміри елементів. У Android можна використовувати як фіксовані значення, так і спеціальні параметри, які адаптуються до контексту використання.  Фіксовані значення  Фіксовані значення розмірів вказуються у вигляді чисел з одиницями вимірювання. Основні одиниці:    px  — пікселі поточного екрана. Однак ця одиниця виміру не рекомендується, оскільки реальне представлення зовнішнього вигляду може змінюватися залежно від пристрою; кожен пристрій має певний набір пікселів на дюйм, тому кількість пікселів на екрані може також змінюватися.   dp  або   dip  — density-independent pixels (пікселі, незалежні від щільності). Абстрактна одиниця виміру, заснована на фізичній щільності екрана з роздільною здатністю 160 dpi (точок на дюйм). У цьому випадку 1dp = 1px. Якщо розмір екрана більший або менший за 160 dpi, кількість пікселів, що застосовуються для відтворення 1dp відповідно збільшується або зменшується. Наприклад, на екрані з 240 dpi 1dp=1,5px, а на екрані з 320dpi 1dp=2px. Загальна формула для отримання кількості фізичних пікселів із dp: px = dp * (dpi / 160)   sp  — scale-independent pixels (незалежні від масштабування пікселі.). Допускають налаштування розмірів, здійснюване користувачем. Рекомендуються для роботи зі шрифтами.   mm  — міліметри   in  — дюйми  Наприклад, встановлення ширини елемента в 150 пікселів виглядає так:     android:  layout_width  =  \"150px\"\n  Проте, використання пікселів (  px ) не є рекомендованим, оскільки вони не адаптуються до різних екранів. Краще використовувати   dp  для розмірів та   sp  для тексту.   Кращими одиницями для використання є   dp . Це пов'язано з тим, що світ мобільних пристроїв на Android сильно фрагментований у плані роздільної здатності та розмірів екрана. І що більша щільність пікселів на дюйм, то відповідно більше пікселів нам буде доступно:    Використовуючи ж стандартні фізичні пікселі, ми можемо зіткнутися з проблемою, що розміри елементів також будуть сильно варіюватися залежно від щільності пікселів пристрою. Наприклад, візьмемо   3 пристрої з різними характеристиками екрана  Nexus 4, Nexus 5X і Nexus 6P і виведемо на екран квадрат розміром   300px  на   300px :\n  \nВ одному випадку квадрат за шириною займатиме 40%, в іншому - третину ширини, у третьому - 20%.  Тепер також візьмемо квадрат зі сторонами   300х300 , але тепер замість фізичних пікселів використовуємо одиниці   dp :\n  \nТепер же розміри квадрата на різних пристроях виглядають більш консистентно.  Для спрощення роботи з розмірами всі розміри розбиті на кілька груп:    ldpi (low) : ~120dpi   mdpi (medium) : ~160dpi   hdpi (high) : ~240dpi (до цієї групи можна віднести такий давній пристрій як Nexus One)   xhdpi (extra-high) : ~320dpi (Nexus 4)   xxhdpi (extra-extra-high) : ~480dpi (Nexus 5/5X, Samsung Galaxy S5)   xxxhdpi (extra-extra-extra-high) : ~640dpi (Nexus 6/6P, Samsung Galaxy S6)  Встановлення розмірів  Основна проблема, пов'язана з розмірами, пов'язана з їх встановленням у коді Java. Наприклад, деякі методи приймають як значення   фізичні пікселі , а не   density-independent pixels . У цьому випадку може знадобитися перевести значення з одного типу одиниць в інший. Для цього потрібно застосувати метод    TypedValue.  applyDimension  () , який приймає три параметри:     public   static   float   applyDimension  (  int   unit,\n                                      float   value,\n                                      android.util.DisplayMetrics metrics)\n  Параметр   unit  представляє тип одиниць, з якої треба отримати значення в пікселях. Тип одиниць описується однією з констант   TypedValue :    COMPLEX_UNIT_DIP  -   dp  або незалежні від щільності екрана пікселі   COMPLEX_UNIT_IN  -   in  або дюйми   COMPLEX_UNIT_MM  -   mm  або міліметри   COMPLEX_UNIT_PT  -   pt  або точки   COMPLEX_UNIT_PX  -   px  або фізичні пікселі   COMPLEX_UNIT_SP  -   sp  або незалежні від масштабування пікселі (scale-independent pixels)\nПараметр   value  представляє значення, яке треба перетворити.\nПараметр   metrics  представляє інформацію про метрику, в рамках якої треба виконати перетворення.  У підсумку метод   повертає перетворене значення . Розглянемо абстрактний приклад. Наприклад, нам треба отримати з   60dp  звичайні фізичні пікселі:     int   valueInDp   =   60  ;\n   int   valueInPx   =   (  int  ) TypedValue.  applyDimension  (\n                   TypedValue.COMPLEX_UNIT_DIP, valueInDp,   getResources  ().  getDisplayMetrics  ());\n  Як третій аргумент передається виклик методу   getResources().getDisplayMetrics() , який дає змогу отримати інформацію про метрику, пов'язану з поточним пристроєм. У підсумку ми отримаємо з   60dp  деяку кількість пікселів.  Спеціальні параметри розмірів  Замість фіксованих значень можна застосовувати наступні параметри:     match_parent  — елемент займає весь доступний простір свого контейнера.    wrap_content  — елемент займає мінімальний простір, необхідний для відображення його вмісту.  Приклад використання в XML:     \u003C  LinearLayout\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"wrap_content\"  >\n   \u003C/  LinearLayout  >\n  Пріоритетність розмірів  Параметри розмірів часто комбінуються з вагами (  weight ) для управління відносними розмірами елементів. Це особливо корисно в контейнерах, таких як   LinearLayout .     \u003C  LinearLayout\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:orientation  =  \"horizontal\"  >\n   \n       \u003C  TextView\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_weight  =  \"1\"\n           android:text  =  \"Елемент 1\"   />\n   \n       \u003C  TextView\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_weight  =  \"2\"\n           android:text  =  \"Елемент 2\"   />\n   \n   \u003C/  LinearLayout  >\n  У цьому прикладі:   Перший елемент займатиме 1 частину доступного простору.  Другий елемент — 2 частини.  Вага елементів  Мінімальні та максимальні розміри  Можна також задати обмеження:     android:minWidth  /    android:minHeight  — мінімальні розміри.    android:maxWidth  /    android:maxHeight  — максимальні розміри.  Приклад:     \u003C  TextView\n       android:layout_width  =  \"wrap_content\"\n       android:layout_height  =  \"wrap_content\"\n       android:minWidth  =  \"100dp\"\n       android:maxWidth  =  \"200dp\"\n       android:minHeight  =  \"50dp\"\n       android:maxHeight  =  \"100dp\"\n       android:text  =  \"Текст з обмеженнями\"   />\n   Розумне використання розмірів та ваг дозволяє створювати адаптивні інтерфейси для різних пристроїв.  Приклад коду     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  LinearLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:orientation  =  \"vertical\"\n       android:padding  =  \"16dp\"  >\n   \n       \u003C!-- TextView з мінімальним і максимальним розміром шрифту -->\n       \u003C  TextView\n           android:id  =  \"@+id/titleText\"\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Розміри у дизайні Android\"\n           android:textSize  =  \"24sp\"\n           android:minHeight  =  \"48dp\"\n           android:maxHeight  =  \"72dp\"\n           android:gravity  =  \"center\"\n           android:layout_marginBottom  =  \"16dp\"   />\n   \n       \u003C!-- Button з мінімальними розмірами -->\n       \u003C  Button\n           android:id  =  \"@+id/actionButton\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_marginBottom  =  \"16dp\"\n           android:minWidth  =  \"150dp\"\n           android:minHeight  =  \"48dp\"\n           android:text  =  \"Натисни мене\"\n           android:textSize  =  \"18sp\"   />\n   \n       \u003C!-- EditText із фіксованими розмірами -->\n       \u003C  EditText\n           android:id  =  \"@+id/inputField\"\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_marginBottom  =  \"16dp\"\n           android:hint  =  \"Введіть текст\"\n           android:textSize  =  \"16sp\"\n           android:minHeight  =  \"40dp\"\n           android:maxHeight  =  \"80dp\"   />\n   \n       \u003C!-- TextView з текстом, який автоматично змінює розмір -->\n       \u003C  TextView\n           android:id  =  \"@+id/adaptiveText\"\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Автоматичний розмір тексту\"\n           android:textSize  =  \"18sp\"\n           android:minHeight  =  \"40dp\"\n           android:maxHeight  =  \"80dp\"\n           android:layout_marginBottom  =  \"16dp\"   />\n   \u003C/  LinearLayout  >\n     package   com.example.sizerexample  ;\n   \n   import   android.os.Bundle  ;\n   import   android.widget.Button  ;\n   import   android.widget.EditText  ;\n   import   android.widget.TextView  ;\n   import   android.widget.Toast  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n   \n           // Отримання посилань на елементи\n           TextView   titleText   =   findViewById  (R.id.titleText);\n           Button   actionButton   =   findViewById  (R.id.actionButton);\n           EditText   inputField   =   findViewById  (R.id.inputField);\n           TextView   adaptiveText   =   findViewById  (R.id.adaptiveText);\n   \n           // Динамічне налаштування розмірів тексту\n           adaptiveText.  setTextSize  (  14  );   // Мінімальний розмір тексту\n           adaptiveText.  setMaxHeight  (  120  );   // Максимальна висота текстового блоку\n   \n           // Додавання події на кнопку\n           actionButton.  setOnClickListener  (view   ->   {\n               String   input   =   inputField.  getText  ().  toString  ();\n               if   (input.  isEmpty  ()) {\n                   Toast.  makeText  (  this  ,   \"Введіть текст\"  , Toast.LENGTH_SHORT).  show  ();\n               }   else   {\n                   // Виводимо текст у адаптивний TextView\n                   adaptiveText.  setText  (input);\n                   adaptiveText.  setTextSize  (input.  length  ()   >   20   ?   12   :   18  );   // Зменшення шрифту для довгого тексту\n               }\n           });\n   \n           // Зміна тексту titleText\n           titleText.  setText  (  \"Динамічні розміри в Android\"  );\n       }\n   }\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":67,"path":68,"dir":14,"title":69,"description":70,"keywords":71,"body":76},"content:1.android:1.lesson1:6.width-and-height.md","/android/lesson1/width-and-height","Ширина та висота елементів","Усі візуальні елементи, які ми використовуємо в додатку, зазвичай впорядковуються на екрані за допомогою контейнерів. В Android такими контейнерами є класи, як-от RelativeLayout, LinearLayout, GridLayout, TableLayout, ConstraintLayout, FrameLayout. Усі вони по-різному розташовують елементи та керують ними, але є деякі загальні моменти при компонуванні візуальних компонентів, які ми зараз розглянемо.",[72,73,74,75],"match_parent","wrap_content","Встановлення точних значень","Програмне встановлення ширини та висоти","  Ширина та висота елементів  Усі візуальні елементи, які ми використовуємо в додатку, зазвичай впорядковуються на екрані за допомогою контейнерів. В Android такими контейнерами є класи, як-от   RelativeLayout ,   LinearLayout ,   GridLayout ,   TableLayout ,   ConstraintLayout ,   FrameLayout . Усі вони по-різному розташовують елементи та керують ними, але є деякі загальні моменти при компонуванні візуальних компонентів, які ми зараз розглянемо.  Для організації елементів усередині контейнера використовуються параметри розмітки. Для їхнього задання у файлі XML застосовуються атрибути, які починаються з префікса   layout_ . Зокрема, до таких параметрів належать атрибути   layout_height  та   layout_width , які використовуються для встановлення розмірів і можуть приймати одну з наступних опцій:   Розтягнення на всю ширину або висоту контейнера за допомогою значення   match_parent  (для всіх контейнерів, окрім   ConstraintLayout ) або   0dp  (для   ConstraintLayout ).  Розтягнення елемента до тих меж, які достатні, щоб вмістити весь його вміст, за допомогою значення   wrap_content .  Точні розміри елемента, наприклад,   96dp .  match_parent  Встановлення значення   match_parent  дозволяє розтягнути елемент на всю ширину або висоту контейнера. Варто зазначити, що це значення застосовується до всіх контейнерів, окрім   ConstraintLayout . Наприклад, розтягнемо елемент   TextView  на всю ширину та висоту контейнера   LinearLayout :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  LinearLayout   \n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n   \n       \u003C  TextView\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"match_parent\"\n           android:text  =  \"Hello World!\"\n           android:textSize  =  \"30sp\"\n           android:background  =  \"#e0e0e0\"   />\n   \n   \u003C/  LinearLayout  >\n  Контейнер найвищого рівня, у цьому випадку   LinearLayout , для висоти та ширини має значення   match_parent , тобто він заповнюватиме всю область для activity — зазвичай, увесь екран.  І   TextView  також приймає подібні атрибути. Значення   android:layout_width=\"match_parent\"  забезпечує розтягнення по ширині, а   android:layout_height=\"match_parent\"  — по вертикалі. Для наочності в   TextView  застосовано атрибут   android:background , який представляє фон і в цьому випадку зафарбовує елемент у колір   #e0e0e0 , завдяки чому ми можемо побачити займану ним область.    Слід враховувати, що значення   match_parent  можна застосовувати майже в усіх вбудованих контейнерах, таких як   LinearLayout  або   RelativeLayout , та їхніх елементах. Однак   match_parent  не рекомендується застосовувати до елементів усередині   ConstraintLayout . Замість   match_parent  у   ConstraintLayout  можна використовувати значення   0dp , щоб розтягнути елемент по горизонталі або вертикалі:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       tools:context  =  \".MainActivity\"  >\n   \n       \u003C  TextView\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           android:text  =  \"Hello World!\"\n           android:textSize  =  \"30sp\"\n           android:background  =  \"#e0e0e0\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"   />\n   \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Варто зазначити, що   ConstraintLayout  сам також розтягується по ширині та висоті екрана за допомогою значення   match_parent  в атрибутах   layout_width  та   android:layout_height , але до вкладених елементів це значення не рекомендується застосовувати.  Оскільки   ConstraintLayout  має деякі особливості при встановленні розмірів, то робота з розмірами елементів саме в   ConstraintLayout  розкрита більш детально в одній із наступних тем.  wrap_content  Значення   wrap_content  встановлює ті значення для ширини або висоти, які необхідні, щоб розмістити на екрані вміст елемента:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       tools:context  =  \".MainActivity\"  >\n   \n       \u003C  TextView\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Hello World!\"\n           android:textSize  =  \"30sp\"\n           android:background  =  \"#e0e0e0\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n   \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  У цьому випадку   TextView  матиме такі розміри, які необхідні для відображення тексту \"Hello World!\". Тобто ширина та висота елемента будуть відповідати розмірам його вмісту.    Встановлення точних значень  Крім   match_parent  та   wrap_content , можна встановлювати точні розміри елементів, використовуючи різні одиниці вимірювання, такі як   dp ,   sp ,   px  тощо.     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       tools:context  =  \".MainActivity\"  >\n    \n       \u003C  TextView\n           android:layout_height  =  \"90dp\"\n           android:layout_width  =  \"150dp\"\n           android:text  =  \"Hello World!\"\n           android:textSize  =  \"30sp\"\n           android:background  =  \"#e0e0e0\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n   \nКрім того, можна комбінувати кілька значень, наприклад, розтягнути по ширині вмісту і встановити точні значення для висоти:     \u003C  TextView\n           android:layout_height  =  \"80dp\"\n           android:layout_width  =  \"wrap_content\"\n           android:text  =  \"Hello World!\"\n           android:textSize  =  \"30sp\"\n           android:background  =  \"#e0e0e0\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n   />\n  Якщо для встановлення ширини та довжини використовується значення   wrap_content , то ми можемо додатково обмежити мінімальні та максимальні значення за допомогою атрибутів   minWidth /  maxWidth  і   minHeight /  maxHeight :     \u003C  TextView\n           android:minWidth  =  \"200dp\"\n           android:maxWidth  =  \"250dp\"\n           android:minHeight  =  \"100dp\"\n           android:maxHeight  =  \"200dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_width  =  \"wrap_content\"\n           android:text  =  \"Hello World!\"\n           android:textSize  =  \"30sp\"\n           android:background  =  \"#e0e0e0\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n   />\n  У цьому разі ширина   TextView  буде такою, яка достатня для вміщення тексту, але не більшою за значення   maxWidth  і не меншою за значення   minWidth . Те ж саме для встановлення висоти.  Програмне встановлення ширини та висоти  Окрім встановлення ширини та висоти елементів у файлі розмітки XML, ці параметри можна задавати програмно. Для цього використовується клас   ViewGroup.LayoutParams  та його похідні, залежно від типу контейнера. Наприклад, для   LinearLayout  використовується клас   LinearLayout.LayoutParams , для   RelativeLayout  —   RelativeLayout.LayoutParams  тощо.  Приклад  Припустимо, ми маємо такий файл розмітки:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  LinearLayout   \n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:orientation  =  \"vertical\"  >\n   \u003C/  LinearLayout  >\n  У цьому контейнері ми створимо   TextView  та встановимо для нього ширину та висоту програмно.     LinearLayout   layout   =   findViewById  (R.id.linearLayout);\n   \n   // Створюємо новий TextView\n   TextView   textView   =   new   TextView  (  this  );\n   textView.  setText  (  \"Програмно заданий текст\"  );\n   \n   // Встановлюємо розміри\n   LinearLayout  .  LayoutParams   layoutParams   =   new   LinearLayout.  LayoutParams  (\n       LinearLayout.LayoutParams.MATCH_PARENT,    // ширина\n       LinearLayout.LayoutParams.WRAP_CONTENT     // висота\n   );\n   textView.  setLayoutParams  (layoutParams);\n   \n   // Додаємо TextView до контейнера\n   layout.  addView  (textView);\n  Опис коду     LinearLayout.LayoutParams.MATCH_PARENT  — ширина елемента буде дорівнювати ширині контейнера.    LinearLayout.LayoutParams.WRAP_CONTENT  — висота елемента буде відповідати розмірам його вмісту.    layout.addView(textView)  — додаємо   TextView  до контейнера.  Таким чином, параметри ширини та висоти елементів можна динамічно змінювати під час виконання програми.  Наприклад, щоб встановити точні розміри програмно, можна скористатися методом   setLayoutParams  із конвертацією одиниць:     int   widthInDp   =   100  ;\n   int   heightInDp   =   50  ;\n   \n   // Конвертуємо dp у пікселі\n   int   widthInPx   =   (  int  ) TypedValue.  applyDimension  (\n       TypedValue.COMPLEX_UNIT_DIP, widthInDp,   getResources  ().  getDisplayMetrics  ());\n   int   heightInPx   =   (  int  ) TypedValue.  applyDimension  (\n       TypedValue.COMPLEX_UNIT_DIP, heightInDp,   getResources  ().  getDisplayMetrics  ());\n   \n   // Встановлюємо параметри\n   LinearLayout  .  LayoutParams   layoutParams   =   new   LinearLayout.  LayoutParams  (widthInPx, heightInPx);\n   textView.  setLayoutParams  (layoutParams);\n  Використання правильних одиниць вимірювання гарантує, що ваш інтерфейс залишатиметься адаптивним на пристроях із різною щільністю пікселів.    Уникайте використання абсолютних пікселів (  px ), якщо ваш додаток має працювати на різних пристроях. Використовуйте   dp  або   sp  для забезпечення адаптивності.    Важливе попередження!   Не використовуйте    match_parent  для вкладених елементів у   ConstraintLayout . Замість цього застосовуйте    0dp  для забезпечення коректного розтягнення.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":78,"path":79,"dir":14,"title":80,"description":81,"keywords":82,"body":87},"content:1.android:1.lesson1:7.padding-and-margin.md","/android/lesson1/padding-and-margin","Внутрішні та зовнішні відступи","Параметри розмітки дозволяють задати відступи як від зовнішніх меж елемента до меж контейнера, так і всередині самого елемента між його межами та вмістом.",[83,84,85,86],"Зовнішні відступи (Margin)","Внутрішні відступи (Padding)","Спільне використання Margin та Padding","Програмне встановлення відступів","  Внутрішні та зовнішні відступи  Параметри розмітки дозволяють задати відступи як від зовнішніх меж елемента до меж контейнера, так і всередині самого елемента між його межами та вмістом.  Зовнішні відступи (Margin)  Для визначення зовнішніх відступів використовується атрибут    android:layout_margin . Цей параметр задає відступ між межами елемента та іншими елементами або контейнером. Якщо потрібно окремо встановити відступи для кожної сторони, використовуються такі атрибути:     android:layout_marginTop  — верхній відступ.    android:layout_marginBottom  — нижній відступ.    android:layout_marginLeft  — відступ зліва.    android:layout_marginRight  — відступ справа.    android:layout_marginStart  — відступ з початку (для підтримки напрямку тексту).    android:layout_marginEnd  — відступ із кінця.  !   Приклад використання зовнішніх відступів     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  LinearLayout   \n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:orientation  =  \"vertical\"  >\n   \n       \u003C  TextView\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Привіт, світ!\"\n           android:layout_margin  =  \"16dp\"   />\n   \u003C/  LinearLayout  >\n  У цьому прикладі у   TextView  встановлено відступ у 16dp з усіх сторін.   Внутрішні відступи (Padding)  Внутрішні відступи задають простір між межами елемента та його вмістом. Для цього використовується атрибут    android:padding . Як і у випадку з   margin , можна окремо вказувати внутрішні відступи для кожної сторони:     android:paddingTop  — верхній відступ.    android:paddingBottom  — нижній відступ.    android:paddingLeft  — відступ зліва.    android:paddingRight  — відступ справа.    android:paddingStart  — відступ із початку.    android:paddingEnd  — відступ із кінця.  !   Приклад використання внутрішніх відступів     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  LinearLayout   \n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:orientation  =  \"vertical\"  >\n   \n       \u003C  TextView\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Привіт, світ!\"\n           android:padding  =  \"16dp\"   />\n   \u003C/  LinearLayout  >\n  У цьому прикладі у   TextView  додано відступ у 16dp всередині елемента.   Спільне використання Margin та Padding  Зовнішні та внутрішні відступи можуть використовуватися одночасно для одного елемента. Наприклад:\n!      \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  LinearLayout   \n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:orientation  =  \"vertical\"  >\n   \n       \u003C  TextView\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Привіт, світ!\"\n           android:layout_margin  =  \"16dp\"\n           android:padding  =  \"8dp\"   />\n   \u003C/  LinearLayout  >\n  У цьому випадку відступ у 16dp задається від зовнішніх меж елемента, а відступ у 8dp — між межами елемента та його текстом.    Зверніть увагу, що   margin  впливає на розташування елемента щодо інших елементів або меж контейнера, а   padding  — на внутрішній простір самого елемента.  Програмне встановлення відступів  Для програмного встановлення внутрішніх відступів у елементи викликається метод   setPadding(left, top, right, bottom) , у який передаються чотири значення для кожної зі сторін. Також можна окремо задати відступи за допомогою методів   getPaddingLeft() ,   getPaddingTop() ,   getPaddingRight()  і   getPaddingBottom() .  Для встановлення зовнішніх відступів необхідно реалізувати об'єкт   LayoutParams  для того контейнера, який застосовується. І потім викликати у цього об'єкта   LayoutParams  метод   setMargins(left, top, right, bottom) :     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   androidx.constraintlayout.widget.ConstraintLayout  ;\n    \n   import   android.os.Bundle  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n    \n           ConstraintLayout   constraintLayout   =   new   ConstraintLayout  (  this  );\n           TextView   textView   =   new   TextView  (  this  );\n           // встановлення кольору текстового поля\n           textView.  setBackgroundColor  (  0xFFE0E0E0  );\n           // встановлення тексту текстового поля\n           textView.  setText  (  \"Hello Android\"  );\n           // встановлення розміру тексту\n           textView.  setTextSize  (  30  );\n    \n           ConstraintLayout  .  LayoutParams   layoutParams   =   new   ConstraintLayout  .  LayoutParams\n                   (ConstraintLayout.LayoutParams.WRAP_CONTENT , ConstraintLayout.LayoutParams.WRAP_CONTENT);\n           // встановлення зовнішніх відступів\n           layoutParams.  setMargins  (  60  ,   50  ,   60  ,   50  );\n           // позиціонування в лівому верхньому кутку контейнера\n           // еквівалент app:layout_constraintLeft_toLeftOf=\"parent\"\n           layoutParams.leftToLeft   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           // еквівалент app:layout_constraintTop_toTopOf=\"parent\"\n           layoutParams.topToTop   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           // встановлюємо розміри\n           textView.  setLayoutParams  (layoutParams);\n           // встановлення внутрішніх відступів\n           textView.  setPadding  (  40  ,  40  ,  40  ,  40  );\n           // додаємо TextView у ConstraintLayout\n           constraintLayout.  addView  (textView);\n    \n           setContentView  (constraintLayout);\n       }\n   }\n  Оскільки в цьому разі елемент   TextView  додається в контейнер типу   ConstraintLayout , то для його позиціонування застосовується об'єкт   ConstraintLayout.LayoutParams  (відповідно для   LinearLayout  це буде   LinearLayout.LayoutParams ), у якого викликається метод   setMargins() .  !   Але якщо подивитися на останній скріншот, то можна побачити, що, незважаючи на те, що відступи начебто задано так само, як і в передостанньому прикладі у файлі   layout , однак у реальності на екрані ми побачимо відступи із зовсім іншими значеннями. Річ у тім, що методи   setPadding()  і   setMargins()  приймають значення в пікселях, тоді як у файлі   layout  застосовувалися одиниці   dp . І щоб використовувати   dp  також у коді, необхідно виконати перетворення:     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   androidx.constraintlayout.widget.ConstraintLayout  ;\n    \n   import   android.os.Bundle  ;\n   import   android.util.TypedValue  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n    \n           ConstraintLayout   constraintLayout   =   new   ConstraintLayout  (  this  );\n           TextView   textView   =   new   TextView  (  this  );\n           textView.  setBackgroundColor  (  0xFFE0E0E0  );\n           textView.  setText  (  \"Hello Android!\"  );\n           textView.  setTextSize  (  30  );\n    \n           // отримуємо відступ у пікселях для 50 dp\n           int   margin50inDp   =   (  int  ) TypedValue.  applyDimension  (\n                   TypedValue.COMPLEX_UNIT_DIP,   50  ,   getResources  ().  getDisplayMetrics  ());\n           // отримуємо відступ у пікселях для 60 dp\n           int   margin60inDp   =   (  int  ) TypedValue.  applyDimension  (\n                   TypedValue.COMPLEX_UNIT_DIP,   60  ,   getResources  ().  getDisplayMetrics  ());\n           // отримуємо відступ у пікселях для 40 dp\n           int   padding40inDp   =   (  int  ) TypedValue.  applyDimension  (\n                   TypedValue.COMPLEX_UNIT_DIP,   40  ,   getResources  ().  getDisplayMetrics  ());\n    \n           ConstraintLayout  .  LayoutParams   layoutParams   =   new   ConstraintLayout  .  LayoutParams\n                   (ConstraintLayout.LayoutParams.WRAP_CONTENT , ConstraintLayout.LayoutParams.WRAP_CONTENT);\n           // встановлення зовнішніх відступів\n           layoutParams.  setMargins  (margin60inDp, margin50inDp, margin60inDp, margin50inDp);\n           // вирівнювання по лівому краю ConstraintLayout\n           layoutParams.leftToLeft   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           // вирівнювання за верхньою межею ConstraintLayout\n           layoutParams.topToTop   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           // встановлюємо розміри\n           textView.  setLayoutParams  (layoutParams);\n           // встановлення внутрішніх відступів\n           textView.  setPadding  (padding40inDp, padding40inDp, padding40inDp, padding40inDp);\n           // додаємо TextView у ConstraintLayout\n           constraintLayout.  addView  (textView);\n    \n           setContentView  (constraintLayout);\n       }\n   }\n  !   html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":89,"path":90,"dir":14,"title":91,"description":92,"keywords":93,"body":97},"content:1.android:1.lesson1:8.constraint-layout.md","/android/lesson1/constraint-layout","ConstraintLayout","ConstraintLayout — це контейнер, який дозволяє створювати гнучкі та масштабовані візуальні інтерфейси.",[94,95,96],"Позиціонування в центрі","Зсув","Приклад","  ConstraintLayout   ConstraintLayout  — це контейнер, який дозволяє створювати гнучкі та масштабовані візуальні інтерфейси.  Для позиціонування елемента всередині ConstraintLayout необхідно вказати обмеження (  constraints ). Існує декілька типів обмежень. Зокрема, для встановлення позиції відносно певного елемента використовуються наступні обмеження:     layout_constraintLeft_toLeftOf : ліва межа позиціонується відносно лівої межі іншого елемента    layout_constraintLeft_toRightOf : ліва межа позиціонується відносно правої межі іншого елемента    layout_constraintRight_toLeftOf : права межа позиціонується відносно лівої межі іншого елемента    layout_constraintRight_toRightOf : права межа позиціонується відносно правої межі іншого елемента    layout_constraintTop_toTopOf : верхня межа позиціонується відносно верхньої межі іншого елемента    layout_constraintTop_toBottomOf : верхня межа позиціонується відносно нижньої межі іншого елемента    layout_constraintBottom_toBottomOf : нижня межа позиціонується відносно нижньої межі іншого елемента    layout_constraintBottom_toTopOf : нижня межа позиціонується відносно верхньої межі іншого елемента    layout_constraintBaseline_toBaselineOf : базова лінія позиціонується відносно базової лінії іншого елемента    layout_constraintStart_toEndOf : елемент починається там, де закінчується інший елемент    layout_constraintStart_toStartOf : елемент починається там, де починається інший елемент    layout_constraintEnd_toStartOf : елемент закінчується там, де починається інший елемент    layout_constraintEnd_toEndOf : елемент закінчується там, де закінчується інший елемент  Можливо, щодо чотирьох останніх властивостей виникло певне непорозуміння, що саме мається на увазі під початком або завершенням елемента. Справа в тому, що деякі мови (наприклад, арабська або фарсі) мають правосторонню орієнтацію, тобто символи йдуть справа наліво, а не зліва направо, як у європейських мовах. І залежно від поточної орієнтації — лівостороння чи правостороння — буде змінюватися те, де саме початок, а де завершення елемента. Наприклад, при лівосторонній орієнтації початок — зліва, а завершення — справа, тому атрибут   layout_constraintStart_toEndOf  фактично буде аналогічний атрибуту   layout_constraintLeft_toRightOf . А при правосторонній орієнтації — атрибуту   layout_constraintRight_toLeftOf , оскільки початок справа, а завершення — зліва.  Кожне обмеження встановлює позиціонування елемента або по горизонталі, або по вертикалі. І для визначення позиції елемента в ConstraintLayout необхідно вказати щонайменше одне обмеження по горизонталі та одне обмеження по вертикалі.  Позиціонування може здійснюватися відносно меж самого контейнера ConstraintLayout (у цьому випадку обмеження має значення   parent ), або ж відносно будь-якого іншого елемента всередині ConstraintLayout, тоді як значення обмеження вказується   id  цього елемента.  Простий приклад:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       tools:context  =  \".MainActivity\"  >\n   \n       \u003C  TextView\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Hello World!\"\n           android:textSize  =  \"30sp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n   \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  У цьому випадку для елемента   TextView  встановлено два обмеження: одне по горизонталі (  app:layout_constraintLeft_toLeftOf=\"parent\" ), друге — по вертикалі (  app:layout_constraintTop_toTopOf=\"parent\" ). Обидва обмеження встановлюються відносно контейнера   ConstraintLayout , тому вони приймають значення   parent , тобто   ConstraintLayout .  Обмеження   app:layout_constraintLeft_toLeftOf=\"parent\"  встановлює ліву межу   TextView  біля лівої межі контейнера.  Обмеження   app:layout_constraintTop_toTopOf=\"parent\"  встановлює верхню межу   TextView  біля верхньої межі контейнера.  У результаті   TextView  буде розташовуватися у верхньому лівому куті контейнера.     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       tools:context  =  \".MainActivity\"  >\n   \n       \u003C  TextView\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Hello World!\"\n           android:textSize  =  \"30sp\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"   />\n   \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n    Варто звернути увагу, що всі ці атрибути обмежень беруть із простору імен   \"http://schemas.android.com/apk/res-auto\" , який проектується на префікс   app .  Якщо необхідно встановити обмеження щодо іншого елемента, то необхідно вказати   id  цього елемента:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       tools:context  =  \".MainActivity\"  >\n    \n       \u003C  EditText\n           android:id  =  \"@+id/editText\"\n           android:layout_width  =  \"180dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:hint  =  \"Введите Email\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n       \u003C  Button\n           android:id  =  \"@+id/button\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Отправить\"\n           app:layout_constraintLeft_toRightOf  =  \"@id/editText\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Тут для текстового поля введення   EditText  встановлюються два обмеження щодо батьківського контейнера   ConstraintLayout , тож обмеження мають значення parent, а сам   EditText  вирівнюється по лівій і верхній межі контейнера. Верхня межа кнопки Button також вирівнюється по верхній межі контейнера. А ось ліва межа кнопки вирівнюється по правій межі   EditText . Для цього як значення атрибута передається id   EditText :     app:  layout_constraintLeft_toRightOf  =  \"@id/editText\"\n   \nПодібним чином можна складати різні комбінації атрибутів для визначення потрібного нам позиціонування. Наприклад, змінимо код кнопки:     \u003C  Button\n       android:id  =  \"@+id/button\"\n       android:layout_width  =  \"wrap_content\"\n       android:layout_height  =  \"wrap_content\"\n       android:text  =  \"Отправить\"\n       app:layout_constraintLeft_toRightOf  =  \"@id/editText\"\n       app:layout_constraintTop_toBottomOf  =  \"@id/editText\"   />\n  У цьому випадку верхня межа кнопки вирівнюється по нижній межі   EditText   Ба більше, ми можемо позиціонувати обидва елементи один відносно іншого:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       tools:context  =  \".MainActivity\"  >\n    \n       \u003C  EditText\n           android:id  =  \"@+id/editText\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:hint  =  \"Введите Email\"\n           app:layout_constraintRight_toLeftOf  =  \"@+id/button\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n       \u003C  Button\n           android:id  =  \"@+id/button\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Отправить\"\n           app:layout_constraintLeft_toRightOf  =  \"@id/editText\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Позиціонування в центрі  Якщо необхідно розташувати елемент у центрі контейнера по вертикалі, то треба використовувати пару атрибутів     app:  layout_constraintTop_toTopOf  =  \"parent\"\n   app:  layout_constraintBottom_toBottomOf  =  \"parent\"\n  Якщо необхідно розташувати елемент у центрі контейнера по горизонталі, то треба використовувати таку пару атрибутів     app:  layout_constraintLeft_toLeftOf  =  \"parent\"\n   app:  layout_constraintRight_toRightOf  =  \"parent\"\n  Відповідно для розташування в центрі контейнера по вертикалі та горизонталі треба застосувати всі вище зазначені чотири атрибути:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       tools:context  =  \".MainActivity\"  >\n    \n       \u003C  TextView\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Hello Android\"\n           android:textSize  =  \"30sp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n    Зсув  Якщо елементи розташовані по центру,   ConstraintLayout  дає змогу їх зрушувати по горизонталі та по вертикалі. Для зсуву по горизонталі застосовується атрибут   layout_constraintHorizontal_bias , а для зсуву по вертикалі - атрибут   layout_constraintVertical_bias . Як значення вони приймають число з плаваючою крапкою від   0  до   1 . Значення за замовчуванням -   0.5  (розташування по центру). Наприклад:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       tools:context  =  \".MainActivity\"  >\n    \n       \u003C  TextView\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Top TextView\"\n           android:textSize  =  \"30sp\"\n           android:background  =  \"#e0e0e0\"\n    \n           app:layout_constraintHorizontal_bias  =  \"0.2\"\n    \n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  />\n    \n       \u003C  TextView\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Bottom TextView\"\n           android:textSize  =  \"30sp\"\n           android:background  =  \"#e0e0e0\"\n    \n           app:layout_constraintHorizontal_bias  =  \".9\"\n    \n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"  />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Перший   TextView  зсувається на   20%  від лівої межі контейнера (значення за замовчуванням -   0 .  5 , тому при значенні   0.2  елемент зсувається вліво). Другий   TextView  зсувається на   90%  від лівої межі контейнера. Наприклад, значення   1  означало б, що елемент присунутий до правої межі, а значення   0  - до лівої\n  \nАналогічно працює атрибут   layout_constraintVertical_bias , який зсуває по вертикалі.  Приклад     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"  >\n   \n       \u003C!-- Заголовок, прикріплений до верхньої частини батьківського контейнера -->\n       \u003C  TextView\n           android:id  =  \"@+id/titleText\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"ConstraintLayout Demo\"\n           android:textSize  =  \"24sp\"\n           android:textStyle  =  \"bold\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintStart_toStartOf  =  \"parent\"\n           app:layout_constraintEnd_toEndOf  =  \"parent\"\n           android:layout_marginBottom  =  \"16dp\"   />\n   \n       \u003C!-- Поле введення тексту, вирівняне по центру горизонтально -->\n       \u003C  EditText\n           android:id  =  \"@+id/inputField\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:hint  =  \"Введіть текст\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/titleText\"\n           app:layout_constraintStart_toStartOf  =  \"parent\"\n           app:layout_constraintEnd_toEndOf  =  \"parent\"\n           android:layout_marginHorizontal  =  \"16dp\"\n           android:layout_marginBottom  =  \"16dp\"   />\n   \n       \u003C!-- Кнопка з прив’язкою до нижньої частини поля введення -->\n       \u003C  Button\n           android:id  =  \"@+id/submitButton\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Надіслати\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/inputField\"\n           app:layout_constraintStart_toStartOf  =  \"parent\"\n           app:layout_constraintEnd_toEndOf  =  \"parent\"\n           android:layout_marginBottom  =  \"16dp\"   />\n   \n       \u003C!-- Іконка, вирівняна по правому краю з пропорційним розміром -->\n       \u003C  ImageView\n           android:id  =  \"@+id/iconImage\"\n           android:layout_width  =  \"100dp\"\n           android:layout_height  =  \"100dp\"\n           android:src  =  \"@drawable/ic_launcher_foreground\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/submitButton\"\n           app:layout_constraintEnd_toEndOf  =  \"parent\"\n           android:layout_margin  =  \"8dp\"   />\n   \n       \u003C!-- Текст, прив'язаний до іконки з використанням bias -->\n       \u003C  TextView\n           android:id  =  \"@+id/descriptionText\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Це приклад використання ConstraintLayout.\"\n           android:textSize  =  \"16sp\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/submitButton\"\n           app:layout_constraintStart_toStartOf  =  \"parent\"\n           app:layout_constraintEnd_toStartOf  =  \"@id/iconImage\"\n           app:layout_constraintHorizontalBias  =  \"0.3\"   />\n   \n       \u003C!-- Нижній текст, вирівняний до низу екрану -->\n       \u003C  TextView\n           android:id  =  \"@+id/footerText\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Footer текст\"\n           android:textSize  =  \"14sp\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintStart_toStartOf  =  \"parent\"\n           app:layout_constraintEnd_toEndOf  =  \"parent\"\n           android:layout_marginTop  =  \"16dp\"   />\n   \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n    Прив’язка до батьківського контейнера :   Елемент   titleText  закріплений до верхньої частини контейнера через:\n     app:  layout_constraintTop_toTopOf  =  \"parent\"\n   app:  layout_constraintStart_toStartOf  =  \"parent\"\n   app:  layout_constraintEnd_toEndOf  =  \"parent\"\n   Прив’язка між елементами :   Кнопка   submitButton  прив’язана до нижньої частини   inputField  через:\n     app:  layout_constraintTop_toBottomOf  =  \"@id/inputField\"\n   Розмір із використанням нуля (  0dp ) :   Поле введення   inputField  займає всю доступну ширину, завдяки:\n     android:  layout_width  =  \"0dp\"\n   app:  layout_constraintStart_toStartOf  =  \"parent\"\n   app:  layout_constraintEnd_toEndOf  =  \"parent\"\n   Пропорційне розташування (bias) :   Текст опису   descriptionText  розташований ближче до лівого краю через:\n     app:  layout_constraintHorizontalBias  =  \"0.3\"\n   Вирівнювання елементів між собою :   Елемент   footerText  вирівняний до низу екрану:\n     app:  layout_constraintBottom_toBottomOf  =  \"parent\"\n   Розтягнення та обмеження розмірів :   Поля, такі як   inputField  і   descriptionText , розтягуються між прив’язками   start  і   end , забезпечуючи адаптивний інтерфейс.     html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":99,"path":100,"dir":14,"title":101,"description":102,"keywords":103,"body":106},"content:1.android:1.lesson1:9.element-sizes-in-cl.md","/android/lesson1/element-sizes-in-cl","Розміри елементів у ConstraintLayout","У ConstraintLayout застосовуються три способи встановлення розмірів:",[63,104,105],"Розміри у відсотках","Встановлення співвідношення висоти та ширини","  Розміри елементів у ConstraintLayout  У   ConstraintLayout  застосовуються три способи встановлення розмірів:   Встановлення точних розмірів, наприклад,   123dp  Значення   WRAP_CONTENT , яке задає для віджета розміри, достатні для розташування його вмісту  Значення   0dp , яке еквівалентне значенню \"  MATCH_CONSTRAINT \" у коді Java. У цьому разі розміри елемента встановлюються виходячи із зазначених для нього обмежень. За замовчуванням елемент займає весь доступний простір.  Застосуємо всі три типи встановлення розмірів:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       tools:context  =  \".MainActivity\"  >\n    \n       \u003C  TextView\n           android:layout_width  =  \"160dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Top TextView\"\n           android:textSize  =  \"30sp\"\n           android:background  =  \"#e0e0e0\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  />\n    \n       \u003C  TextView\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Center TextView\"\n           android:textSize  =  \"30sp\"\n           android:background  =  \"#e0e0e0\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"  />\n    \n       \u003C  TextView\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Bottom TextView\"\n           android:textSize  =  \"30sp\"\n           android:background  =  \"#e0e0e0\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"  />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Тут створюються три елементи   TextView . Усі вони центруються по горизонталі, але по вертикалі розташовуються по верхній і нижній межі контейнера і в центрі. Для всіх трьох   TextView  для висоти задано значення   wrap_content , тобто всі три елементи займатимуть ту висоту, яка для них є кращою, щоб вмістити вміст:     android:  layout_height  =  \"wrap_content\"\n  Однак для кожного елемента задано свої налаштування ширини. Для верхнього TextView встановлено точні розміри -   160  одиниць:     android:  layout_width  =  \"160dp\"\n  Для центрального   TextView  встановлено значення   \"0dp\" , завдяки чому елемент за замовчуванням займатиме весь доступний для нього простір (у цьому разі розтягуватиметься по горизонталі):     android:  layout_width  =  \"0dp\"\n  Для нижнього   TextView  встановлено значення   \"wrap_content\" , тобто елемент прийматиме ту ширину, яка необхідна для вміщення його вмісту:     android:  layout_width  =  \"wrap_content\"\n   \nВарто зазначити, що у вкладених віджетах у   ConstraintLayout  не рекомендується використовувати значення   match_parent , яке дає змогу віджету зайняти весь доступний простір. Замість цього рекомендується використовувати   0dp  або   \"MATCH_CONSTRAINT\"  - разом з іншими обмеженнями вони дадуть необхідний ефект. Так, для розтягування по ширині контейнера застосовуються такі атрибути:     android:  layout_width  =  \"0dp\"\n   app:  layout_constraintLeft_toLeftOf  =  \"parent\"\n   app:  layout_constraintRight_toRightOf  =  \"parent\"\n  А для розтягування по висоті контейнера застосовуються такі атрибути:     android:  layout_height  =  \"0dp\"\n   app:  layout_constraintTop_toTopOf  =  \"parent\"\n   app:  layout_constraintBottom_toBottomOf  =  \"parent\"\n  Наприклад, розтягнення   TextView  по всій довжині та ширині контейнера:     \u003C  TextView\n       android:layout_width  =  \"0dp\"\n       android:layout_height  =  \"0dp\"\n       android:text  =  \"Hello Android\"\n       android:textSize  =  \"30sp\"\n       android:background  =  \"#e0e0e0\"\n       app:layout_constraintLeft_toLeftOf  =  \"parent\"\n       app:layout_constraintRight_toRightOf  =  \"parent\"\n       app:layout_constraintTop_toTopOf  =  \"parent\"\n       app:layout_constraintBottom_toBottomOf  =  \"parent\"  />\n  Мінімальні та максимальні розміри  Низка атрибутів задають максимальні та мінімальні розміри:    layout_constraintWidth_min  і   layout_constraintHeight_min : представляють відповідно мінімальну ширину і висоту   layout_constraintWidth_max  і   layout_constraintHeight_max : представляють відповідно максимальну ширину і висоту  Як значення вони приймають точне значення в   dp  або значення   wrap  (аналогічно   wrap_content ). Наприклад:     \u003C  TextView\n       android:layout_width  =  \"260dp\"\n       android:layout_height  =  \"wrap_content\"\n       android:text  =  \"Hello Android\"\n       android:textSize  =  \"30sp\"\n       android:background  =  \"#e0e0e0\"\n    \n       app:layout_constraintHeight_max  =  \"200dp\"\n       app:layout_constraintWidth_max  =  \"200dp\"\n       app:layout_constraintHeight_min  =  \"wrap\"\n       app:layout_constraintWidth_min  =  \"wrap\"\n    \n       app:layout_constraintLeft_toLeftOf  =  \"parent\"\n       app:layout_constraintRight_toRightOf  =  \"parent\"\n       app:layout_constraintTop_toTopOf  =  \"parent\"\n       app:layout_constraintBottom_toBottomOf  =  \"parent\"  />\n  Хоча в цьому разі ширина   TextView  встановлена в   260dp , оскільки максимальна ширина задана в   200dp , то реальна ширина не перевищить   200dp .  Розміри у відсотках  Атрибут   layout_constraintWidth_percent  задає ширину елемента у відсотках по відношенню до доступного простору по горизонталі. Аналогічно атрибут   layout_constraintHeight_percent  задає висоту у відсотках щодо доступного простору по вертикалі.  Для їх застосування необхідно дотриматися таких умов:   Відповідний атрибут для встановлення розміру (  android:layout_width  - якщо ми встановлюємо ширину або   android:layout_height  - якщо ми встановлюємо висоту у відсотках) повинен мати значення   MATCH_CONSTRAINT  або   0dp .  Також необхідно встановити атрибут   app:layout_constraintWidth_default=\"percent\"  при встановленні ширини і   app:layout_constraintHeight_default=\"percent\"  при встановленні висоти.  Як значення атрибути   layout_constraintWidth_percent  і   layout_constraintHeight_percent  приймають дробове число від   0  до   1 .  Наприклад, нехай   TextView  займає по вертикалі   25% , а по горизонталі   50%  простору:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       tools:context  =  \".MainActivity\"  >\n    \n       \u003C  TextView\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           android:text  =  \"Hello Android\"\n           android:textSize  =  \"30sp\"\n           android:background  =  \"#e0e0e0\"\n            \n           app:layout_constraintWidth_default  =  \"percent\"\n           app:layout_constraintHeight_default  =  \"percent\"\n            \n           app:layout_constraintWidth_percent  =  \"0.5\"\n           app:layout_constraintHeight_percent  =  \"0.25\"\n            \n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"  />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n    Інший приклад - пропорційний поділ простору між кількома елементами:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       tools:context  =  \".MainActivity\"  >\n    \n       \u003C  EditText\n           android:id  =  \"@+id/editText\"\n           android:hint  =  \"Введите Email\"\n           android:layout_height  =  \"wrap_content\"\n            \n           android:layout_width  =  \"0dp\"\n           app:layout_constraintWidth_default  =  \"percent\"\n           app:layout_constraintWidth_percent  =  \"0.66\"\n            \n           app:layout_constraintRight_toLeftOf  =  \"@+id/button\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n       \u003C  Button\n           android:id  =  \"@+id/button\"\n           android:text  =  \"Отправить\"\n           android:layout_height  =  \"wrap_content\"\n            \n           android:layout_width  =  \"0dp\"\n           app:layout_constraintWidth_default  =  \"percent\"\n           app:layout_constraintWidth_percent  =  \"0.33\"\n            \n           app:layout_constraintLeft_toRightOf  =  \"@id/editText\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  У цьому разі текстове поле EditText займатиме 66%, а кнопка - 33% ширини:\n   Встановлення співвідношення висоти та ширини   ConstraintLayout  також дає змогу встановлювати в елементів висоту відносно ширини / ширину відносно висоти. Для цього застосовується атрибут   layout_constraintDimensionRatio . Як значення він приймає відношення у вигляді   Width:Height , наприклад,   1:0.5  - тут число   1  представляє ширину, а   0.5  - висоту. Тобто ширина буде вдвічі більшою за висоту. Але при цьому хоча б для одного виміру має бути встановлено   0dp  (  MATCH_CONSTRAINT ). Наприклад:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       tools:context  =  \".MainActivity\"  >\n    \n       \u003C  TextView\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"0dp\"\n           android:text  =  \"Hello Android\"\n           android:textSize  =  \"30sp\"\n           android:background  =  \"#e0e0e0\"\n           app:layout_constraintDimensionRatio  =  \"1:0.6\"\n    \n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"  />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  У цьому разі ширина   TextView  буде такою, яка необхідна для його вмісту, а висота   60%  від ширини.\n   Якщо і для ширини, і для висоти встановлено   0dp , то в цьому випадку система вибере найбільший вимір, що відповідає всім обмеженням, і відносно нього встановить значення іншого виміру. Щоб конкретизувати вимір, щодо якого йтиме розрахунок, можна вказати символ   W  (ширина) або   H  (висота). Наприклад:     \u003C  TextView\n       android:layout_width  =  \"0dp\"\n       android:layout_height  =  \"0dp\"\n       android:text  =  \"Hello Android\"\n       android:textSize  =  \"30sp\"\n       android:background  =  \"#e0e0e0\"\n            \n       app:layout_constraintDimensionRatio  =  \"W, 1:4\"\n    \n       app:layout_constraintLeft_toLeftOf  =  \"parent\"\n       app:layout_constraintRight_toRightOf  =  \"parent\"\n       app:layout_constraintTop_toTopOf  =  \"parent\"\n       app:layout_constraintBottom_toBottomOf  =  \"parent\"  />\n  У цьому разі ширина буде в 4 рази меншою за висоту.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":108,"path":109,"dir":14,"title":110,"description":111,"keywords":112,"body":116},"content:1.android:1.lesson1:10.element-chains-in-cl.md","/android/lesson1/element-chains-in-cl","Ланцюжки елементів у ConstraintLayout","ConstraintLayout дає змогу організувати розташування елементів у ряд по горизонталі або по вертикалі, або те, що в Android називається chains або ланцюжки. Ми можемо по ланцюжку встановити позиціонування одного елемента відносно іншого і таким чином організувати ряд елементів.",[113,114,115],"Горизонтальний ланцюжок елементів","Вага елемента","Вертикальний ланцюжок","  Ланцюжки елементів у ConstraintLayout   ConstraintLayout  дає змогу організувати розташування елементів у ряд по горизонталі або по вертикалі, або те, що в Android називається   chains  або ланцюжки. Ми можемо по ланцюжку встановити позиціонування одного елемента відносно іншого і таким чином організувати ряд елементів.  Горизонтальний ланцюжок елементів  Наприклад, ряд елементів по горизонталі:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       tools:context  =  \".MainActivity\"  >\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView1\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:background  =  \"#efefef\"\n           android:text  =  \"First\"\n           android:textSize  =  \"30sp\"\n           app:layout_constraintRight_toLeftOf  =  \"@id/textView2\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView2\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:background  =  \"#e0e0e0\"\n           android:text  =  \"Second\"\n           android:textSize  =  \"30sp\"\n           app:layout_constraintLeft_toRightOf  =  \"@id/textView1\"\n           app:layout_constraintRight_toLeftOf  =  \"@id/textView3\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView3\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:background  =  \"#efefef\"\n           android:text  =  \"Third\"\n           android:textSize  =  \"30sp\"\n           app:layout_constraintLeft_toRightOf  =  \"@id/textView2\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  У підсумку елементи ланцюжка рівномірно будуть розтягнуті по всій ширині контейнера:\n   Горизонтальний ланцюжок елементів досягається за рахунок двох факторів:   Перший елемент вирівнюється відносно лівої межі контейнера (  app:layout_constraintLeft_toLeftOf=\"parent\" ), останній елемент вирівнюється відносно правої межі контейнера (  app:layout_constraintRight_toRightOf=\"parent\" ).  Завдяки встановленню атрибутів   app:layout_constraintLeft_toRightOf  та   app:layout_constraintRight_toLeftOf  розташовуємо один елемент праворуч або ліворуч від іншого.  Крім того, ConstraintLayout дає змогу налаштувати положення елементів усередині ланцюжка. Для цього застосовується атрибут   layout_constraintHorizontal_chainStyle , який може набувати таких значень:    spread : значення за замовчуванням, за якого елементи ланцюжка рівномірно розтягуються по всій довжині ланцюжка, як у прикладі вище   spread_inside : перший і останній елемент ланцюжка примикають до меж контейнера   packed : елементи ланцюжка розташовуються впритул один до одного.  Наприклад, застосуємо значення   spread_inside :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       tools:context  =  \".MainActivity\"  >\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView1\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:background  =  \"#efefef\"\n           android:text  =  \"First\"\n           android:textSize  =  \"30sp\"\n    \n           app:layout_constraintHorizontal_chainStyle  =  \"spread_inside\"\n    \n           app:layout_constraintRight_toLeftOf  =  \"@id/textView2\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView2\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:background  =  \"#e0e0e0\"\n           android:text  =  \"Second\"\n           android:textSize  =  \"30sp\"\n           app:layout_constraintLeft_toRightOf  =  \"@id/textView1\"\n           app:layout_constraintRight_toLeftOf  =  \"@id/textView3\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView3\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:background  =  \"#efefef\"\n           android:text  =  \"Third\"\n           android:textSize  =  \"30sp\"\n           app:layout_constraintLeft_toRightOf  =  \"@id/textView2\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Причому в цьому випадку достатньо встановити атрибут у першого елемента ланцюжка:\n   Значення   packed :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       tools:context  =  \".MainActivity\"  >\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView1\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:background  =  \"#efefef\"\n           android:text  =  \"First\"\n           android:textSize  =  \"30sp\"\n    \n           app:layout_constraintHorizontal_chainStyle  =  \"packed\"\n    \n           app:layout_constraintRight_toLeftOf  =  \"@id/textView2\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView2\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:background  =  \"#e0e0e0\"\n           android:text  =  \"Second\"\n           android:textSize  =  \"30sp\"\n           app:layout_constraintLeft_toRightOf  =  \"@id/textView1\"\n           app:layout_constraintRight_toLeftOf  =  \"@id/textView3\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView3\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:background  =  \"#efefef\"\n           android:text  =  \"Third\"\n           android:textSize  =  \"30sp\"\n           app:layout_constraintLeft_toRightOf  =  \"@id/textView2\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n    Вага елемента  Варто зазначити, що вище в елементів встановлювалася ширина, необхідна для їхнього вмісту. Але ми могли б встановити і нульову ширину, тоді елементи рівномірно б розподілялися по всьому ланцюжку без утворення проміжків між ними.     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       tools:context  =  \".MainActivity\"  >\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView1\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:background  =  \"#efefef\"\n           android:text  =  \"First\"\n           android:textSize  =  \"30sp\"\n           app:layout_constraintRight_toLeftOf  =  \"@id/textView2\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView2\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:background  =  \"#e0e0e0\"\n           android:text  =  \"Second\"\n           android:textSize  =  \"30sp\"\n           app:layout_constraintLeft_toRightOf  =  \"@id/textView1\"\n           app:layout_constraintRight_toLeftOf  =  \"@id/textView3\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView3\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:background  =  \"#efefef\"\n           android:text  =  \"Third\"\n           android:textSize  =  \"30sp\"\n           app:layout_constraintLeft_toRightOf  =  \"@id/textView2\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n    У цьому разі значення атрибута   app:layout_constraintHorizontal_chainStyle  не відіграє жодної ролі, тому що всі елементи отже розтягуються по всьому ланцюжку.  Однак така поведінка може не влаштовувати, наприклад, ми хочемо, щоб один елемент був удвічі більшим за інший. І в цьому випадку ми можемо за допомогою атрибута   layout_constraintHorizontal_weight . Однак слід враховувати, що при застосуванні ваг у елементів, вони повинні мати нульову ширину:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       tools:context  =  \".MainActivity\"  >\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView1\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:background  =  \"#efefef\"\n           android:text  =  \"First\"\n           android:textSize  =  \"30sp\"\n            \n           app:layout_constraintHorizontal_weight  =  \"1\"\n            \n           app:layout_constraintRight_toLeftOf  =  \"@id/textView2\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView2\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:background  =  \"#e0e0e0\"\n           android:text  =  \"Second\"\n           android:textSize  =  \"30sp\"\n            \n           app:layout_constraintHorizontal_weight  =  \"2\"\n            \n           app:layout_constraintLeft_toRightOf  =  \"@id/textView1\"\n           app:layout_constraintRight_toLeftOf  =  \"@id/textView3\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView3\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:background  =  \"#efefef\"\n           android:text  =  \"Third\"\n           android:textSize  =  \"30sp\"\n    \n           app:layout_constraintHorizontal_weight  =  \"1\"\n            \n           app:layout_constraintLeft_toRightOf  =  \"@id/textView2\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Як значення атрибут   layout_constraintHorizontal_weight  приймає число -   вагу елемента . Так, у цьому випадку вага першого елемента -   1 , вага другого -   2 , а вага третього -   1 . Тому вся ширина контейнера буде умовно поділена на   1 + 2 + 1 = 4  частини, з яких по одній частині займуть перший і третій елемент, а другий займе   2  частини, тобто другий елемент буде вдвічі більшим за перший і третій елемент.\n   У принципі ми можемо залишити елементи і з шириною   \"wrap_content\"  або конкретним значенням, відмінним від   \"0dp\" , просто в цьому разі вони не братимуть участі в розподілі простору контейнера, а вага в такого елемента ролі не відіграватиме.  Вертикальний ланцюжок  Для утворення вертикального ланцюжка також має дотримуватися дві умови:   Перший елемент вирівнюється щодо верхньої межі контейнера (  app:layout_constraintTop_toTopOf=\"parent\" ), останній елемент вирівнюється щодо нижньої межі контейнера (  app:layout_constraintBottom_toBottomOf=\"parent\" ).  Завдяки встановленню атрибутів   app:layout_constraintBottom_toTopOf  і   app:layout_constraintBottom_toTopOf  розташовуємо один елемент поверх іншого.  Щоб налаштувати положення елементів усередині ланцюжка, застосовується атрибут   layout_constraintVertical_chainStyle , який може набувати таких значень:    spread : значення за замовчуванням, за якого елементи ланцюжка рівномірно розтягуються по всій довжині ланцюжка   spread_inside : перший і останній елемент ланцюжка примикають до кордонів контейнера   packed : елементи ланцюжка прилягають впритул один до одного.  Наприклад, вертикальний ланцюжок зі значенням за замовчуванням -   spread :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       tools:context  =  \".MainActivity\"  >\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView1\"\n           android:layout_width  =  \"200dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:background  =  \"#efefef\"\n           android:text  =  \"First\"\n           android:textSize  =  \"30sp\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/textView2\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView2\"\n           android:layout_width  =  \"200dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:background  =  \"#e0e0e0\"\n           android:text  =  \"Second\"\n           android:textSize  =  \"30sp\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/textView1\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/textView3\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"   />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView3\"\n           android:layout_width  =  \"200dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:background  =  \"#efefef\"\n           android:text  =  \"Third\"\n           android:textSize  =  \"30sp\"\n    \n           app:layout_constraintTop_toBottomOf  =  \"@id/textView2\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n    Також достатньо застосувати до першого елемента ланцюжка атрибут   layout_constraintVertical_chainStyle , щоб змінити положення елементів:     \u003C  TextView\n           android:id  =  \"@+id/textView1\"\n           android:layout_width  =  \"200dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:background  =  \"#efefef\"\n           android:text  =  \"First\"\n           android:textSize  =  \"30sp\"\n            \n           app:layout_constraintVertical_chainStyle  =  \"spread_inside\"\n            \n           app:layout_constraintBottom_toTopOf  =  \"@id/textView2\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    І як при горизонтальній орієнтації у вертикальному ланцюжку можна використовувати вагу елементів за допомогою атрибута   layout_constraintVertical_weight . Для встановлення ваги в елемента в якості висоти має бути встановлене значення   0dp     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       tools:context  =  \".MainActivity\"  >\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView1\"\n           android:layout_width  =  \"200dp\"\n           android:layout_height  =  \"0dp\"\n           android:background  =  \"#efefef\"\n           android:text  =  \"First\"\n           android:textSize  =  \"30sp\"\n           app:layout_constraintVertical_weight  =  \"1\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/textView2\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView2\"\n           android:layout_width  =  \"200dp\"\n           android:layout_height  =  \"0dp\"\n           android:background  =  \"#e0e0e0\"\n           android:text  =  \"Second\"\n           android:textSize  =  \"30sp\"\n           app:layout_constraintVertical_weight  =  \"3\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/textView1\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/textView3\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"   />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView3\"\n           android:layout_width  =  \"200dp\"\n           android:layout_height  =  \"0dp\"\n           android:background  =  \"#efefef\"\n           android:text  =  \"Third\"\n           android:textSize  =  \"30sp\"\n           app:layout_constraintVertical_weight  =  \"2\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/textView2\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Сукупна вага елементів у цьому випадку   1 + 3 + 2 = 6 . Тому вся висота контейнера ділитиметься на   6  частин, з яких перший елемент займе   1  частину, другий -   3  частини і третій -   2  частини відповідно до своєї ваги.      html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":118,"path":119,"dir":14,"title":120,"description":121,"keywords":122,"body":123},"content:1.android:1.lesson1:11.programmatically-create-cl.md","/android/lesson1/programmatically-create-cl","Програмне створення ConstraintLayout і позиціонування","Для створення контейнера в коді Java застосовується однойменний клас ConstraintLayout, для створення об'єкта якого в конструктор передають значення для ширини і висоти елемента:",[],"  Програмне створення ConstraintLayout і позиціонування  Для створення контейнера в коді Java застосовується однойменний клас   ConstraintLayout , для створення об'єкта якого в конструктор передають значення для ширини і висоти елемента:     ConstraintLayout  .  LayoutParams   layoutParams   =   new   ConstraintLayout  .  LayoutParams\n                   (ConstraintLayout.LayoutParams.WRAP_CONTENT , ConstraintLayout.LayoutParams.WRAP_CONTENT);\n  Перший параметр встановлює ширину елемента, а другий - висоту.   ConstraintLayout.LayoutParams.WRAP_CONTENT  вказує, що елемент матиме ті розміри, які необхідні для того, щоб вивести на екран його вміст. Крім   ConstraintLayout.LayoutParams.WRAP_CONTENT  можна застосовувати константу   ConstraintLayout.LayoutParams.MATCH_CONSTRAINT , яка аналогічна застосуванню значення   \"0dp\"  в атрибутах   layout_width  та   layout_height  та яка розтягує елемент за шириною або висотою контейнера.  Також можна використовувати точні розміри, наприклад:     ConstraintLayout  .  LayoutParams   layoutParams   =   new   ConstraintLayout  .  LayoutParams\n                   (ConstraintLayout.LayoutParams.MATCH_CONSTRAINT,   200  );\n  Для налаштування позиціонування всередині   ConstraintLayout  застосовується клас   ConstraintLayout.LayoutParams . Він має досить багато функціоналу. Розглянемо в цьому випадку тільки ті поля, які дають змогу встановити розташування елемента:    baselineToBaseline : вирівнює базову лінію елемента по базовій лінії іншого елемента,   id  якого присвоюється властивості.   bottomToBottom : вирівнює нижню межу елемента по нижній межі іншого елемента.   bottomToTop : вирівнює нижню межу елемента по верхній межі іншого елемента.   leftToLeft : вирівнює ліву межу елемента по лівій межі іншого елемента.   leftToRight : вирівнює ліву межу елемента по правій межі іншого елемента.   rightToLeft : вирівнює праву межу елемента по лівій межі іншого елемента.   rightToRight : вирівнює праву межу елемента по правій межі іншого елемента.   startToEnd : вирівнює початок елемента по завершенню іншого елемента.   startToStart : вирівнює початок елемента по початку іншого елемента.   topToBottom : вирівнює верхню межу елемента по нижній межі іншого елемента.   topToTop : вирівнює верхню межу елемента по верхній межі іншого елемента.   endToEnd : вирівнює заврішення елемента по завершенню іншого елемента.   endToStart : вирівнює завершення елемента по початку іншого елемента.  Як значення ці поля приймають   id  (ідентифікатор) елемента, щодо якого виконується позиціонування. Якщо розташування встановлюється щодо контейнера   ConstraintLayout , то застосовується константа   ConstraintLayout.LayoutParams.PARENT_ID .  Розглянемо найпростіший приклад:     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   androidx.constraintlayout.widget.ConstraintLayout  ;\n   import   android.os.Bundle  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           //setContentView(R.layout.activity_main);\n    \n           ConstraintLayout   constraintLayout   =   new   ConstraintLayout  (  this  );\n           TextView   textView   =   new   TextView  (  this  );\n           // установка текста текстового поля\n           textView.  setText  (  \"Hello Android\"  );\n           // установка размера текста\n           textView.  setTextSize  (  30  );\n    \n           ConstraintLayout  .  LayoutParams   layoutParams   =   new   ConstraintLayout  .  LayoutParams\n                   (ConstraintLayout.LayoutParams.WRAP_CONTENT , ConstraintLayout.LayoutParams.WRAP_CONTENT);\n           // позиционирование в левом верхнем углу контейнера\n           // эквивалент app:layout_constraintLeft_toLeftOf=\"parent\"\n           layoutParams.leftToLeft   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           // эквивалент app:layout_constraintTop_toTopOf=\"parent\"\n           layoutParams.topToTop   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           // устанавливаем размеры\n           textView.  setLayoutParams  (layoutParams);\n           // добавляем TextView в ConstraintLayout\n           constraintLayout.  addView  (textView);\n    \n           setContentView  (constraintLayout);\n       }\n   }\n  У цьому разі значення   ConstraintLayout.LayoutParams.WRAP_CONTENT  для ширини та висоти вказує, що елемент матиме ті розміри, які необхідні для того, щоб вивести на екран його вміст.  Далі вирівнюємо ліву межу елемента по лівій стороні контейнера:     layoutParams.leftToLeft   = ConstraintLayout.LayoutParams.PARENT_ID  ;\n  Ця установка аналогічна використанню атрибута   app:layout_constraintLeft_toLeftOf=\"parent\" .  Потім вирівнюємо верхню межу елемента по верхній стороні контейнера:     layoutParams.topToTop   = ConstraintLayout.LayoutParams.PARENT_ID  ;\n  Ця установка аналогічна використанню атрибута   app:layout_constraintTop_toTopOf=\"parent\" .  І наприкінці застосовуємо об'єкт   ConstraintLayout.LayoutParams  до   TextView :     constraintLayout.addView(textView)  ;\n  У підсумку елемент   TextView  буде розташований у верхньому лівому кутку   ConstraintLayout :\n   Розглянемо інший приклад - встановлення розташування елементів відносно один одного:     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   androidx.constraintlayout.widget.ConstraintLayout  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.Button  ;\n   import   android.widget.EditText  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           //setContentView(R.layout.activity_main);\n    \n           ConstraintLayout   constraintLayout   =   new   ConstraintLayout  (  this  );\n    \n           EditText   editText   =   new   EditText  (  this  );\n           editText.  setHint  (  \"Введите Email\"  );\n           editText.  setId  (View.  generateViewId  ());\n            \n           Button   button   =   new   Button  (  this  );\n           button.  setText  (  \"Отправить\"  );\n           button.  setId  (View.  generateViewId  ());\n    \n           ConstraintLayout  .  LayoutParams   editTextLayout   =   new   ConstraintLayout  .  LayoutParams\n                   (ConstraintLayout.LayoutParams.WRAP_CONTENT , ConstraintLayout.LayoutParams.WRAP_CONTENT);\n           editTextLayout.leftToLeft   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           editTextLayout.topToTop   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           editTextLayout.rightToLeft   =   button.  getId  ();\n           editText.  setLayoutParams  (editTextLayout);\n           constraintLayout.  addView  (editText);\n    \n           ConstraintLayout  .  LayoutParams   buttonLayout   =   new   ConstraintLayout  .  LayoutParams\n                   (ConstraintLayout.LayoutParams.WRAP_CONTENT , ConstraintLayout.LayoutParams.WRAP_CONTENT);\n           buttonLayout.leftToRight   =   editText.  getId  ();\n           buttonLayout.topToTop   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           button.  setLayoutParams  (buttonLayout);\n           constraintLayout.  addView  (button);\n    \n           setContentView  (constraintLayout);\n       }\n   }\n  При розташуванні одного елемента відносно іншого, нам потрібно знати id вторрого елемента. Якщо елемент визначено в коді Java, то спочатку треба згенерувати ідентифікатор:     editText.setId(View.generateViewId())  ;\n   button.setId(View.generateViewId())  ;\n  Потім можна застосовувати ідентифікатори елементів для встановлення позиціонування позиціонування. Так, права межа   EditText  вирівнюється по лівій межі кнопки:     editTextLayout.rightToLeft   = button.getId()  ;\n  А ліва межа кнопки вирівнюється по правій межі елемента   EditText :     buttonLayout.leftToRight   = editText.getId()  ;\n    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":125,"path":126,"dir":14,"title":127,"description":128,"keywords":129,"body":132},"content:1.android:1.lesson1:12.linear-layout.md","/android/lesson1/linear-layout","LinearLayout","Контейнер LinearLayout представляє найпростіший контейнер - об'єкт ViewGroup, який упорядковує всі дочірні елементи в одному напрямку: по горизонталі або по вертикалі. Усі елементи розташовані один за одним. Напрямок розмітки вказується за допомогою атрибута android:orientation.",[114,130,131,96],"Програмне створення LinearLayout","Layout_gravity","  LinearLayout  Контейнер   LinearLayout  представляє найпростіший контейнер - об'єкт   ViewGroup , який упорядковує всі дочірні елементи в одному напрямку: по горизонталі або по вертикалі. Усі елементи розташовані один за одним. Напрямок розмітки вказується за допомогою атрибута   android:orientation .  Якщо, наприклад, орієнтація розмітки вертикальна (  android:orientation=\"vertical\" ), то всі елементи розташовуються в стовпчик - по одному елементу на кожному рядку. Якщо орієнтація горизонтальна (  android:orientation=\"horizontal\" ), то елементи розташовуються в один рядок. Наприклад, розташуємо елементи в горизонтальний ряд:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  LinearLayout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:orientation  =  \"horizontal\"   >\n    \n       \u003C  TextView\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_margin  =  \"5dp\"\n           android:text  =  \"Hello\"\n           android:textSize  =  \"26sp\"   />\n       \u003C  TextView\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_margin  =  \"5dp\"\n           android:text  =  \"Android\"\n           android:textSize  =  \"26sp\"   />\n       \u003C  TextView\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_margin  =  \"5dp\"\n           android:text  =  \"World\"\n           android:textSize  =  \"26sp\"   />\n   \u003C/  LinearLayout  >\n   \nЯкби ми вказали для   LinearLayout  атрибут   android:orientation=\"vertical\" , то елементи розміщувалися б по вертикалі:\n   Вага елемента   LinearLayout  підтримує таку властивість, як вага елемента, яка передається атрибутом   android:layout_weight . Ця властивість приймає значення, що вказує, яку частину вільного місця контейнера, що залишилося, стосовно інших об'єктів займе цей елемент. Наприклад, якщо один елемент у нас матиме для властивості   android:layout_weight  значення   2 , а інший - значення   1 , то в сумі вони дадуть   3 , тому перший елемент займатиме   2/3  решти простору, а другий -   1/3 .  Якщо всі елементи мають значення   android:layout_weight=\"1\" , то всі ці елементи будуть рівномірно розподілені по всій площі контейнера:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  LinearLayout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:orientation  =  \"vertical\"   >\n       \u003C  TextView\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"0dp\"\n           android:text  =  \"Hello\"\n           android:background  =  \"#e0e0e0\"\n           android:layout_weight  =  \"1\"\n           android:textSize  =  \"26sp\"   />\n       \u003C  TextView\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"0dp\"\n           android:background  =  \"#eeeeee\"\n           android:text  =  \"Android\"\n           android:layout_weight  =  \"1\"\n           android:textSize  =  \"26sp\"   />\n       \u003C  TextView\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"0dp\"\n           android:text  =  \"World\"\n           android:background  =  \"#bdbdbd\"\n           android:layout_weight  =  \"1\"\n           android:textSize  =  \"26sp\"   />\n   \u003C/  LinearLayout  >\n  У цьому випадку   LinearLayout  має вертикальну орієнтацію, тому всі елементи розташовуватимуться зверху вниз. Усі три елементи мають значення   android:layout_weight=\"1\" , тому сума ваг усіх елементів дорівнюватиме   3 , а кожен елемент отримає по третині простору в   LinearLayout :\n   При цьому оскільки у нас вертикальний стек, то нам треба також встановити для властивості   layout_height  значення   0dp . Якби   LinearLayout  мав горизонтальну орієнтацію, то для властивості   layout_width  треба було б встановити значення   0dp .  Ще один атрибут   android:weightSum  дає змогу вказати суму ваг усіх елементів. Наприклад:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  LinearLayout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:orientation  =  \"vertical\"\n       android:weightSum  =  \"7\"  >\n    \n       \u003C  TextView\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"0dp\"\n           android:text  =  \"Hello\"\n           android:background  =  \"#e0e0e0\"\n           android:layout_weight  =  \"1\"\n           android:textSize  =  \"26sp\"   />\n       \u003C  TextView\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"0dp\"\n           android:background  =  \"#eeeeee\"\n           android:text  =  \"Android\"\n           android:layout_weight  =  \"3\"\n           android:textSize  =  \"26sp\"   />\n       \u003C  TextView\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"0dp\"\n           android:text  =  \"World\"\n           android:background  =  \"#bdbdbd\"\n           android:layout_weight  =  \"2\"\n           android:textSize  =  \"26sp\"   />\n   \u003C/  LinearLayout  >\n   LinearLayout  тут задає суму ваг рівну   7 . Тобто весь простір по вертикалі (оскільки вертикальна орієнтація) умовно ділиться на сім рівних частин.  Перший   TextView  має вагу   1 , тобто з цих семи частин займає тільки одну. Другий   TextView  має вагу   3 , тобто займає три частини із семи. І третій має вагу   2 . Підсумкова сума становить   6 . Але оскільки   LinearLayout  задає вагу   7 , то одна частина буде вільна від усіх елементів.    Програмне створення LinearLayout     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.widget.LinearLayout  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           //setContentView(R.layout.activity_main);\n           LinearLayout   linearLayout   =   new   LinearLayout  (  this  );\n           // горизонтальна орієнтація\n           linearLayout.  setOrientation  (LinearLayout.HORIZONTAL);\n            \n           TextView   textView   =   new   TextView  (  this  );\n           textView.  setText  (  \"Hello\"  );\n           textView.  setTextSize  (  30  );\n           // створюємо параметри позиціонування для елемента\n           LinearLayout  .  LayoutParams   layoutParams   =   new   LinearLayout  .  LayoutParams\n                   (LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT);\n           // встановлюємо відступи\n           layoutParams.  setMargins  (  100  ,   100  ,   0  ,   0  );\n           textView.  setLayoutParams  (layoutParams);\n           // додаємо елемент у LinearLayout\n           linearLayout.  addView  (textView);\n    \n           setContentView  (linearLayout);\n       }\n   }\n    Додаткова версія конструктора   LinearLayout.LayoutParams()  як третій параметр дає змогу вказати вагу елемента:     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.widget.LinearLayout  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n            \n           LinearLayout   linearLayout   =   new   LinearLayout  (  this  );\n           linearLayout.  setOrientation  (LinearLayout.VERTICAL);\n            \n           // перше текстове поле\n           TextView   textView1   =   new   TextView  (  this  );\n           textView1.  setText  (  \"Hello\"  );\n           textView1.  setTextSize  (  30  );\n           // textView1 має вагу 3\n           linearLayout.  addView  (textView1,   new   LinearLayout  .  LayoutParams\n                   (LinearLayout.LayoutParams.MATCH_PARENT,   0  ,   3  ));\n    \n           // второе текстовое поле\n           TextView   textView2   =   new   TextView  (  this  );\n           textView2.  setText  (  \"Android\"  );\n           textView2.  setBackgroundColor  (  0xFFBDBDBD  );\n           textView2.  setTextSize  (  30  );\n           // textView2 має вагу 2\n           linearLayout.  addView  (textView2,   new   LinearLayout  .  LayoutParams\n                   (LinearLayout.LayoutParams.MATCH_PARENT,   0  ,   2  ));\n    \n           setContentView  (linearLayout);\n       }\n   }\n    Layout_gravity  Атрибут   layout_gravity  дає змогу встановлювати позиціонування щодо   LinearLayout . Він приймає такі значення:    top : вирівнює елемент по верхній межі контейнера   bottom : вирівнює елемент по нижній межі контейнера   left : вирівнює елемент по лівій межі контейнера   right : вирівнює елемент по правій межі контейнера   center_vertical : вирівнює елемент по центру по вертикалі   center_horizontal : вирівнює елемент по центру по горизонталі   center : елемент позиціонується в центрі   fill_vertical : елемент розтягується по вертикалі   fill_horizontal : елемент розтягується по горизонталі   fill : елемент заповнює весь простір контейнера   clip_vertical : обрізає верхню і нижню межу елемента   clip_horizontal : обрізає праву і ліву межу елемента   start : елемент позиціонується на початку (у верхньому лівому кутку) контейнера   end : елемент позиціонується в кінці контейнера (у верхньому правому куті)  Наприклад:     \u003C  LinearLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:orientation  =  \"vertical\"  >\n       \u003C  TextView\n           android:layout_gravity  =  \"left\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"30sp\"\n           android:text  =  \"Hello Java!\"\n           android:background  =  \"#e8eaf6\"  />\n       \u003C  TextView\n           android:layout_gravity  =  \"center\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"30sp\"\n           android:text  =  \"Hello World!\"\n           android:background  =  \"#e8eaf6\"  />\n       \u003C  TextView\n           android:layout_gravity  =  \"right\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"30sp\"\n           android:text  =  \"Hello Android!\"\n           android:background  =  \"#e8eaf6\"  />\n       \u003C  TextView\n           android:layout_gravity  =  \"center\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"30sp\"\n           android:text  =  \"Hello Kotlin!\"\n           android:background  =  \"#e8eaf6\"  />\n   \u003C/  LinearLayout  >\n  У цьому випадку перший елемент   TextView  буде позиціонуватися по лівому боці контейнера (  android:layout_gravity=\"left\" ), другий   TextView  по центру (  android:layout_gravity=\"center\" ), третій - по правому боці (  android:layout_gravity=\"right\" ) та четвертий - по центру (  android:layout_gravity=\"center\" ).    Варто враховувати орієнтацію контейнера. Наприклад, за вертикальної орієнтації всі елементи представлятимуть вертикальний стек, що йде зверху вниз. Тому значення, які відносяться до позиціонування елемента по вертикалі (наприклад,   top  або   bottom ) ніяк не впливатимуть на елемент. Також за горизонтальної орієнтації LinearLayout не матимуть жодного впливу значення, які позиціонують елемент по горизонталі, наприклад,   left  і   right .  Для встановлення програмно параметра   layout_gravity  треба задати поле   gravity  в об'єкта   LinearLayout.LayoutParams :     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.view.Gravity  ;\n   import   android.widget.LinearLayout  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n    \n           LinearLayout   linearLayout   =   new   LinearLayout  (  this  );\n           linearLayout.  setOrientation  (LinearLayout.VERTICAL);\n           LinearLayout  .  LayoutParams   layoutParams   =   new   LinearLayout  .  LayoutParams\n                   (LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT);\n   // установка layout_gravity\n           layoutParams.gravity   =   Gravity.CENTER;\n           // перше текстове поле\n           TextView   textView1   =   new   TextView  (  this  );\n           textView1.  setText  (  \"Hello\"  );\n           textView1.  setTextSize  (  30  );\n           linearLayout.  addView  (textView1, layoutParams);\n           setContentView  (linearLayout);\n       }\n   }\n  Як значення передається одна з констант класу Gravity, які аналогічні значенням атрибута.  Приклад     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  LinearLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:orientation  =  \"vertical\"\n       android:padding  =  \"16dp\"  >\n   \n       \u003C!-- Заголовок екрана -->\n       \u003C  TextView\n           android:id  =  \"@+id/titleText\"\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Оформлення замовлення\"\n           android:textSize  =  \"20sp\"\n           android:textStyle  =  \"bold\"\n           android:gravity  =  \"center\"\n           android:layout_marginBottom  =  \"16dp\"   />\n   \n       \u003C!-- Поле для введення імені -->\n       \u003C  EditText\n           android:id  =  \"@+id/nameInput\"\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"wrap_content\"\n           android:hint  =  \"Ім'я клієнта\"\n           android:inputType  =  \"textPersonName\"\n           android:layout_marginBottom  =  \"8dp\"   />\n   \n       \u003C!-- Поле для введення номера телефону -->\n       \u003C  EditText\n           android:id  =  \"@+id/phoneInput\"\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"wrap_content\"\n           android:hint  =  \"Телефон\"\n           android:inputType  =  \"phone\"\n           android:layout_marginBottom  =  \"16dp\"   />\n   \n       \u003C!-- Горизонтальне вирівнювання для вибору способу доставки -->\n       \u003C  LinearLayout\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"wrap_content\"\n           android:orientation  =  \"horizontal\"\n           android:layout_marginBottom  =  \"16dp\"  >\n   \n           \u003C!-- Варіант \"Самовивіз\" -->\n           \u003C  RadioButton\n               android:id  =  \"@+id/pickupOption\"\n               android:layout_width  =  \"0dp\"\n               android:layout_height  =  \"wrap_content\"\n               android:layout_weight  =  \"1\"\n               android:text  =  \"Самовивіз\"   />\n   \n           \u003C!-- Варіант \"Доставка\" -->\n           \u003C  RadioButton\n               android:id  =  \"@+id/deliveryOption\"\n               android:layout_width  =  \"0dp\"\n               android:layout_height  =  \"wrap_content\"\n               android:layout_weight  =  \"1\"\n               android:text  =  \"Доставка\"   />\n       \u003C/  LinearLayout  >\n   \n       \u003C!-- Поле введення адреси для доставки -->\n       \u003C  EditText\n           android:id  =  \"@+id/addressInput\"\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"wrap_content\"\n           android:hint  =  \"Адреса доставки\"\n           android:inputType  =  \"textPostalAddress\"\n           android:layout_marginBottom  =  \"16dp\"\n           android:visibility  =  \"gone\"   />   \u003C!-- Спочатку приховано -->\n   \n       \u003C!-- Горизонтальне вирівнювання для кнопок -->\n       \u003C  LinearLayout\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"wrap_content\"\n           android:orientation  =  \"horizontal\"\n           android:gravity  =  \"end\"  >\n   \n           \u003C!-- Кнопка \"Очистити\" -->\n           \u003C  Button\n               android:id  =  \"@+id/clearButton\"\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"Очистити\"\n               android:layout_marginEnd  =  \"8dp\"   />\n   \n           \u003C!-- Кнопка \"Оформити замовлення\" -->\n           \u003C  Button\n               android:id  =  \"@+id/submitButton\"\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"Оформити\"   />\n       \u003C/  LinearLayout  >\n   \n   \u003C/  LinearLayout  >\n  Що використано в цьому прикладі   Вертикальне розташування (  orientation=\"vertical\" )   Основний контейнер   LinearLayout  розташовує всі елементи вертикально.  Вирівнювання тексту по центру (  gravity=\"center\" )   Заголовок   titleText  вирівняний горизонтально по центру.  Використання   layout_weight  у вкладеному горизонтальному лейауті   У секції вибору способу доставки (  RadioButton ) кожен варіант займає рівну частину простору завдяки   layout_weight=\"1\" .  Динамічне керування видимістю   Поле введення адреси (  addressInput ) приховане спочатку через   android:visibility=\"gone\" , і його можна показувати програмно.  Вирівнювання елементів усередині горизонтального контейнера   Кнопки внизу вирівняні по правому краю через   android:gravity=\"end\" .  Міжелементні відступи (  layout_margin )   Додано відступи для візуального розділення елементів.    Реальний сценарій  Цей інтерфейс можна використати в бізнес-застосунку для оформлення замовлення:   Клієнт вводить своє ім’я та телефон.  Вибирає спосіб доставки (самовивіз або доставка).  Якщо вибрано доставку, програмно відображається поле введення адреси.  Кнопки \"Очистити\" та \"Оформити\" дозволяють або очистити введені дані, або завершити оформлення замовлення.    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":134,"path":135,"dir":14,"title":136,"description":7,"keywords":137,"body":140},"content:1.android:1.lesson1:13.relative-layout.md","/android/lesson1/relative-layout","Relative Layout",[138,139],"RelativeLayout (застарілий)","Програмне створення RelativeLayout","  RelativeLayout (застарілий)   RelativeLayout  представляє об'єкт   ViewGroup , який розташовує дочірні елементи відносно позиції інших дочірніх елементів розмітки або відносно області самої розмітки   RelativeLayout . Використовуючи відносне позиціонування, ми можемо встановити елемент за правим краєм або по центру чи іншим способом, який надає цей контейнер. Для встановлення елемента у файлі xml ми можемо застосовувати такі атрибути:    android:layout_above : розташовує елемент над елементом із зазначеним Id   android:layout_below : розташовує елемент під елементом із зазначеним Id   android:layout_toLeftOf : розташовується ліворуч від елемента із зазначеним Id   android:layout_toRightOf : розташовується праворуч від елемента із зазначеним Id   android:layout_toStartOf : розташовує початок поточного елемента, де починається елемент із зазначеним Id   android:layout_toEndOf : розташовує початок поточного елемента, де завершується елемент із зазначеним Id   android:layout_alignBottom : вирівнює елемент по нижній межі іншого елемента із зазначеним Id   android:layout_alignLeft : вирівнює елемент по лівій межі іншого елемента із зазначеним Id   android:layout_alignRight : вирівнює елемент по правій межі іншого елемента із зазначеним Id   android:layout_alignStart : вирівнює елемент по лінії, біля якої починається інший елемент із зазначеним Id   android:layout_alignEnd : вирівнює елемент по лінії, біля якої завершується інший елемент із зазначеним Id   android:layout_alignTop : вирівнює елемент по верхній межі іншого елемента із зазначеним Id   android:layout_alignBaseline : вирівнює базову лінію елемента по базовій лінії іншого елемента із зазначеним Id   android:layout_alignParentBottom : якщо атрибут має значення true, то елемент притискається до нижньої межі контейнера   android:layout_alignParentRight : якщо атрибут має значення true, то елемент притискається до правого краю контейнера   android:layout_alignParentLeft : якщо атрибут має значення true, то елемент притискається до лівого краю контейнера   android:layout_alignParentStart : якщо атрибут має значення true, то елемент притискається до початкового краю контейнера (за лівосторонньої орієнтації тексту - лівий край)   android:layout_alignParentEnd : якщо атрибут має значення true, то елемент притискається до кінцевого краю контейнера (при лівосторонній орієнтації тексту - правий край)   android:layout_alignParentTop : якщо атрибут має значення true, то елемент притискається до верхньої межі контейнера   android:layout_centerInParent : якщо атрибут має значення true, то елемент розташовується по центру батьківського контейнера   android:layout_centerHorizontal : при значенні true вирівнює елемент по центру по горизонталі   android:layout_centerVertical : при значенні true вирівнює елемент по центру по вертикалі  Наприклад, позиціонування щодо контейнера   RelativeLayout :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  RelativeLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  TextView   android:text  =  \"Left Top\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_width  =  \"wrap_content\"\n           android:textSize  =  \"26sp\"\n           android:layout_alignParentLeft  =  \"true\"\n           android:layout_alignParentTop  =  \"true\"   />\n    \n       \u003C  TextView   android:text  =  \"Right Top\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_width  =  \"wrap_content\"\n           android:textSize  =  \"26sp\"\n           android:layout_alignParentRight  =  \"true\"\n           android:layout_alignParentTop  =  \"true\"   />\n    \n       \u003C  TextView   android:text  =  \"Left Bottom\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_width  =  \"wrap_content\"\n           android:textSize  =  \"26sp\"\n           android:layout_alignParentLeft  =  \"true\"\n           android:layout_alignParentBottom  =  \"true\"   />\n    \n       \u003C  TextView   android:text  =  \"Right Bottom\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_width  =  \"wrap_content\"\n           android:textSize  =  \"26sp\"\n           android:layout_alignParentRight  =  \"true\"\n           android:layout_alignParentBottom  =  \"true\"   />\n   \u003C/  RelativeLayout  >\n    Для позиціонування відносно іншого елемента, нам треба вказати id цього елемента. Так, помістимо на RelativeLayout текстове поле і кнопку:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  RelativeLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  EditText\n           android:id  =  \"@+id/edit_message\"\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_centerInParent  =  \"true\"  />\n       \u003C  Button\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Отправить\"\n           android:layout_alignRight  =  \"@id/edit_message\"\n           android:layout_below  =  \"@id/edit_message\"\n           />\n   \u003C/  RelativeLayout  >\n  У цьому разі поле   EditText  розташовується по центру в   RelativeLayout , а кнопка поміщається під   EditText  і вирівнюється по його правій межі:  Програмне створення RelativeLayout  Створимо елемент   RelativeLayout  програмно в коді Java:     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.widget.Button  ;\n   import   android.widget.EditText  ;\n   import   android.widget.RelativeLayout  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n            \n           RelativeLayout   relativeLayout   =   new   RelativeLayout  (  this  );\n    \n           EditText   editText   =   new   EditText  (  this  );\n           editText.  setId  (EditText.  generateViewId  ());\n    \n           Button   button   =   new   Button  (  this  );\n           button.  setText  (  \"Отправить\"  );\n    \n           // встановлюємо параметри положення для EditText\n           RelativeLayout  .  LayoutParams   editTextParams   =   new   RelativeLayout.  LayoutParams  (\n                   RelativeLayout.LayoutParams.MATCH_PARENT,\n                   RelativeLayout.LayoutParams.WRAP_CONTENT\n           );\n           // вирівнювання по центру батьківського контейнера\n           editTextParams.  addRule  (RelativeLayout.CENTER_IN_PARENT);\n           // додаємо в RelativeLayout\n           relativeLayout.  addView  (editText, editTextParams);\n    \n           // увстановлюємо параметри положення для Button\n           RelativeLayout  .  LayoutParams   buttonParams   =   new   RelativeLayout.  LayoutParams  (\n                   RelativeLayout.LayoutParams.WRAP_CONTENT,\n                   RelativeLayout.LayoutParams.WRAP_CONTENT\n           );\n           // вирівнювання праворуч і знизу від поля EditText\n           buttonParams.  addRule  (RelativeLayout.BELOW, editText.  getId  ());\n           buttonParams.  addRule  (RelativeLayout.ALIGN_RIGHT, editText.  getId  ());\n           // додаємо в RelativeLayout\n           relativeLayout.  addView  (button, buttonParams);\n    \n           setContentView  (relativeLayout);\n       }\n   }\n  Щоб задати положення елемента в контейнері, застосовується клас   RelativeLayout.LayoutParams . Через конструктор встановлюються значення для для ширини і висоти. Наприклад, в елемента   EditText  для ширини встановлюється значення   MATCH_PARENT , а для висоти -   WRAP_CONTENT .  За допомогою методу   addRule()  ми можемо додавати додаткові правила для позиціонування елемента. Цей метод як параметр приймає числову константу, яка представляє параметр позиціювання і яка аналогічна атрибуту. Наприклад, атрибуту   android:layout_centerInParent  відповідатиме константа   CENTER_IN_PARENT , а атрибуту   android:layout_alignRight  константа   ALIGN_RIGHT .  Варто зазначити, що з метою спрощення коду для встановлення id у   EditText  викликається метод   generateViewId(); , який дає змогу програмно згенерувати id для елемента управління.  Потім встановлений   id  передається як другий параметр у метод   addRule  під час встановлення правил для кнопки:     buttonParams.  addRule  (RelativeLayout.BELOW, editText.  getId  ());\n  Тим самим ми вказуємо щодо якого елемента треба задати розташування.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":142,"path":143,"dir":14,"title":144,"description":145,"keywords":146,"body":149},"content:1.android:1.lesson1:14.table-layout.md","/android/lesson1/table-layout","TableLayout","Контейнер TableLayout структурує елементи керування у вигляді таблиці за стовпчиками та рядками. Визначимо у файлі activity_main.xml елемент TableLayout, який міститиме два рядки і два стовпці:",[147,96,148],"Програмне створення TableLayout","Коли використовувати TableLayout","  TableLayout  Контейнер   TableLayout  структурує елементи керування у вигляді таблиці за стовпчиками та рядками. Визначимо у файлі   activity_main.xml  елемент   TableLayout , який міститиме два рядки і два стовпці:     \u003C  TableLayout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"match_parent\"   \n       android:layout_height  =  \"match_parent\"  >\n       \u003C  TableRow  >\n           \u003C  TextView\n               android:layout_weight  =  \"0.5\"\n               android:text  =  \"Логин\"\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"   />\n    \n           \u003C  EditText\n               android:layout_weight  =  \"1\"\n               android:layout_width  =  \"match_parent\"\n               android:layout_height  =  \"wrap_content\"    />\n       \u003C/  TableRow  >\n    \n       \u003C  TableRow  >\n           \u003C  TextView\n               android:layout_weight  =  \"0.5\"\n               android:text  =  \"Email\"\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"   />\n    \n           \u003C  EditText\n               android:layout_weight  =  \"1\"\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"   />\n       \u003C/  TableRow  >\n   \u003C/  TableLayout  >\n    Використовуючи елемент   TableRow , ми створюємо окремий рядок. Як розмітка дізнається скільки стовпців треба створити? Android знаходить рядок із максимальною кількістю віджетів одного рівня, і ця кількість означатиме кількість стовпців. Наприклад, у цьому випадку в нас визначено два рядки і в кожному по два елементи. Якби в якомусь із них було б три віджети, то відповідно стовпців було б також три, навіть якщо в іншому рядку залишилося б два віджети.  Причому елемент   TableRow  успадковується від класу   LinearLayout , тому ми можемо до нього застосовувати той самий функціонал, що й до   LinearLayout . Зокрема, для визначення простору для елементів у рядку використовується атрибут   android:layout_weight .  Якщо якийсь елемент має бути розтягнутий на низку стовпців, то ми можемо розтягнути його за допомогою атрибута   layout_span , який вказує, на яку кількість стовпців треба розтягнути елемент:     \u003C  TableLayout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n       \u003C  TableRow  >\n           \u003C  TextView\n               android:textSize  =  \"22sp\"\n               android:text  =  \"Логин\"\n               android:layout_width  =  \"100dp\"\n               android:layout_height  =  \"wrap_content\"   />\n    \n           \u003C  EditText\n               android:textSize  =  \"22sp\"\n               android:layout_width  =  \"200dp\"\n               android:layout_height  =  \"wrap_content\"    />\n       \u003C/  TableRow  >\n    \n       \u003C  TableRow  >\n           \u003C  TextView\n               android:textSize  =  \"22sp\"\n               android:text  =  \"Email\"\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"   />\n    \n           \u003C  EditText\n               android:textSize  =  \"22sp\"\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"   />\n       \u003C/  TableRow  >\n       \u003C  TableRow  >\n           \u003C  Button\n               android:text  =  \"Отправить\"\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"\n               android:layout_span  =  \"2\"  />\n       \u003C/  TableRow  >\n   \u003C/  TableLayout  >\n   \nТакож можна розтягнути елемент на весь рядок, встановивши в нього атрибут   android:layout_weight=«1» :     \u003C  TableRow  >\n       \u003C  Button\n           android:text  =  \"Отправить\"\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_weight  =  \"1\"   />\n   \u003C/  TableRow  >\n  Програмне створення TableLayout  Створимо   TableLayout  програмним чином, переклавши на код java найперший приклад із цієї статті:     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.widget.EditText  ;\n   import   android.widget.TableLayout  ;\n   import   android.widget.TableRow  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n    \n           TableLayout   tableLayout   =   new   TableLayout  (   this  );\n            \n           // перший рядок\n           TableRow   tableRow1   =   new   TableRow  (  this  );\n    \n           TextView   textView1   =   new   TextView  (  this  );\n           textView1.  setText  (  \"Логин\"  );\n           tableRow1.  addView  (textView1,   new   TableRow.  LayoutParams  (\n                   TableRow.LayoutParams.WRAP_CONTENT, TableRow.LayoutParams.WRAP_CONTENT,   0.5f  ));\n    \n           EditText   editText1   =   new   EditText  (  this  );\n           tableRow1.  addView  (editText1,   new   TableRow.  LayoutParams  (\n                   TableRow.LayoutParams.WRAP_CONTENT, TableRow.LayoutParams.WRAP_CONTENT,   1.0f  ));\n    \n           // другий рядок\n           TableRow   tableRow2   =   new   TableRow  (  this  );\n    \n           TextView   textView2   =   new   TextView  (  this  );\n           textView2.  setText  (  \"Email\"  );\n           tableRow2.  addView  (textView2,   new   TableRow.  LayoutParams  (\n                   TableRow.LayoutParams.WRAP_CONTENT, TableRow.LayoutParams.WRAP_CONTENT,   0.5f  ));\n    \n           EditText   editText2   =   new   EditText  (  this  );\n           tableRow2.  addView  (editText2,   new   TableRow.  LayoutParams  (\n                   TableRow.LayoutParams.WRAP_CONTENT, TableRow.LayoutParams.WRAP_CONTENT,   1.f  ));\n    \n           tableLayout.  addView  (tableRow1);\n           tableLayout.  addView  (tableRow2);\n           setContentView  (tableLayout);\n       }\n   }\n  Приклад     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C!-- Стовпець 1 буде автоматично розтягуватися -->\n   \u003C  TableLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"wrap_content\"\n       android:stretchColumns  =  \"1\"   \n       android:padding  =  \"16dp\"  >\n   \n       \u003C!-- Заголовок таблиці -->\n       \u003C!-- Об'єднання двох стовпців -->\n       \u003C  TableRow  >\n           \u003C  TextView\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"Дані клієнта\"\n               android:textSize  =  \"20sp\"\n               android:textStyle  =  \"bold\"\n               android:layout_span  =  \"2\"   \n               android:gravity  =  \"center\"   />\n       \u003C/  TableRow  >\n   \n       \u003C!-- Рядок 1: Ім'я -->\n       \u003C  TableRow  >\n           \u003C  TextView\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"Ім'я:\"   />\n   \n           \u003C  EditText\n               android:layout_width  =  \"match_parent\"\n               android:layout_height  =  \"wrap_content\"\n               android:hint  =  \"Введіть ім'я\"\n               android:inputType  =  \"textPersonName\"   />\n       \u003C/  TableRow  >\n   \n       \u003C!-- Рядок 2: Телефон -->\n       \u003C  TableRow  >\n           \u003C  TextView\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"Телефон:\"   />\n   \n           \u003C  EditText\n               android:layout_width  =  \"match_parent\"\n               android:layout_height  =  \"wrap_content\"\n               android:hint  =  \"Введіть телефон\"\n               android:inputType  =  \"phone\"   />\n       \u003C/  TableRow  >\n   \n       \u003C!-- Рядок 3: Email -->\n       \u003C  TableRow  >\n           \u003C  TextView\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"Email:\"   />\n   \n           \u003C  EditText\n               android:layout_width  =  \"match_parent\"\n               android:layout_height  =  \"wrap_content\"\n               android:hint  =  \"Введіть email\"\n               android:inputType  =  \"textEmailAddress\"   />\n       \u003C/  TableRow  >\n   \n       \u003C!-- Рядок 4: Кнопки -->\n       \u003C  TableRow  >\n           \u003C  Button\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"Очистити\"   />\n   \n           \u003C  Button\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"Зберегти\"   />\n       \u003C/  TableRow  >\n   \n   \u003C/  TableLayout  >\n  Коли використовувати TableLayout  Ситуації для використання:   Табличні форми: наприклад, для введення даних користувача чи форм замовлень, де кожен рядок містить мітку та відповідне поле для введення.  Звіти: відображення невеликої кількості даних у табличному вигляді (наприклад, кількість замовлень чи статистика).  Прості таблиці: коли потрібно забезпечити вирівнювання елементів за стовпцями.   RecyclerView : кращий вибір для великих табличних даних, оскільки підтримує оптимізовану роботу з великим набором елементів і додає можливості для прокручування.    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":151,"path":152,"dir":14,"title":153,"description":154,"keywords":155,"body":157},"content:1.android:1.lesson1:15.frame-layout.md","/android/lesson1/frame-layout","FrameLayout","Контейнер FrameLayout призначений для виведення на екран одного поміщеного в нього візуального елемента. Якщо ж ми помістимо кілька елементів, то вони накладатимуться один на одного. Проте також можна розташовувати в FrameLayout кілька елементів.",[156,96],"Програмне створення FrameLayout у коді MainActivity:","  FrameLayout  Контейнер   FrameLayout  призначений для виведення на екран одного поміщеного в нього візуального елемента. Якщо ж ми помістимо кілька елементів, то вони накладатимуться один на одного. Проте також можна розташовувати в   FrameLayout  кілька елементів.  Припустимо, вкладемо в   FrameLayout  два елементи   TextView :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  FrameLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  TextView\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Hello World!\"\n           android:textSize  =  \"26sp\"  />\n       \u003C  TextView\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Hello Android!\"\n           android:textSize  =  \"26sp\"\n           android:layout_marginTop  =  \"50dp\"  />\n    \n   \u003C/  FrameLayout  >\n  Тут обидва елементи позиціонуються в одне й те саме місце - у лівий верхній кут контейнера   FrameLayout , і щоб уникнути накладення, у цьому разі у другого   TextView  встановлюється відступ зверху в   50  одиниць.\n   Нерідко   FrameLayout  застосовується для створення похідних контейнерів, наприклад,   ScrollView , який забезпечує прокрутку.  Елементи керування, які поміщаються у   FrameLayout , можуть встановити своє позиціонування за допомогою атрибута   android:layout_gravity :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  FrameLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  TextView\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Hello World!\"\n           android:textSize  =  \"26sp\"\n           android:layout_gravity  =  \"center_horizontal\"   />\n       \u003C  TextView\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Welcome to Java World\"\n           android:textSize  =  \"26sp\"\n           android:layout_gravity  =  \"center\"  />\n       \u003C  TextView\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Hello Android!\"\n           android:textSize  =  \"26sp\"\n           android:layout_gravity  =  \"bottom|center_horizontal\"  />\n    \n   \u003C/  FrameLayout  >\n  Під час зазначення значення ми можемо комбінувати низку значень, розділяючи їх вертикальною рискою:   bottom|center_horizontal   Програмне створення FrameLayout у коді MainActivity:     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n   import   android.view.Gravity  ;\n   import   android.widget.FrameLayout  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n    \n           FrameLayout   frameLayout   =   new   FrameLayout  (  this  );\n           TextView   textView   =   new   TextView  (  this  );\n           textView.  setText  (  \"Hello World!\"  );\n    \n           FrameLayout  .  LayoutParams   layoutParams   =   new   FrameLayout  .  LayoutParams\n                   (FrameLayout.LayoutParams.WRAP_CONTENT, FrameLayout.LayoutParams.WRAP_CONTENT);\n           layoutParams.gravity   =   Gravity.CENTER_HORIZONTAL   |   Gravity.TOP;\n    \n           textView.  setLayoutParams  (layoutParams);\n           textView.  setTextSize  (  26  );\n           frameLayout.  addView  (textView);\n           setContentView  (frameLayout);\n       }\n   }\n   FrameLayout  — це простий контейнер, що дозволяє розташовувати елементи один над одним, ідеальний для сценаріїв, коли потрібно мати стек елементів або відображати один елемент у певний момент часу.  Приклад     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  FrameLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"  >\n   \n       \u003C!-- Фонова картинка -->\n       \u003C  ImageView\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"match_parent\"\n           android:src  =  \"@drawable/background_image\"\n           android:scaleType  =  \"centerCrop\"   />\n   \n       \u003C!-- Основний контент (текст в центрі) -->\n       \u003C  TextView\n           android:id  =  \"@+id/mainText\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_gravity  =  \"center\"\n           android:text  =  \"Ласкаво просимо!\"\n           android:textSize  =  \"24sp\"\n           android:textColor  =  \"@android:color/white\"\n           android:textStyle  =  \"bold\"   />\n   \n       \u003C!-- Завантаження (Loading) -->\n       \u003C  ProgressBar\n           android:id  =  \"@+id/loadingSpinner\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_gravity  =  \"center\"\n           android:visibility  =  \"gone\"   />\n   \u003C/  FrameLayout  >\n     package   com.example.framelayoutdemo  ;\n   \n   import   android.os.Bundle  ;\n   import   android.os.Handler  ;\n   import   android.view.View  ;\n   import   android.widget.ProgressBar  ;\n   import   android.widget.TextView  ;\n   import   androidx.appcompat.app.AppCompatActivity  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       private   ProgressBar   loadingSpinner;\n       private   TextView   mainText;\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_frame_layout);\n   \n           // Ініціалізація елементів\n           loadingSpinner   =   findViewById  (R.id.loadingSpinner);\n           mainText   =   findViewById  (R.id.mainText);\n   \n           // Симуляція завантаження\n           showLoading  (  true  );\n   \n           // Затримка для симуляції даних (3 секунди)\n           new   Handler  ().  postDelayed  (()   ->   {\n               showLoading  (  false  );\n               mainText.  setText  (  \"Дані успішно завантажені!\"  );\n           },   3000  );\n       }\n   \n       /**\n        * Метод для керування завантаженням\n        *\n        *   @param   isLoading   якщо true - показує ProgressBar, ховає текст.\n        */\n       private   void   showLoading  (  boolean   isLoading  ) {\n           if   (isLoading) {\n               loadingSpinner.  setVisibility  (View.VISIBLE);\n               mainText.  setVisibility  (View.GONE);\n           }   else   {\n               loadingSpinner.  setVisibility  (View.GONE);\n               mainText.  setVisibility  (View.VISIBLE);\n           }\n       }\n   }\n   FrameLayout  часто використовується у таких випадках:   Екрани завантаження: відображення спінера поверх вмісту, поки відбувається завантаження.  Картки з фоновими зображеннями: додавання тексту поверх зображення (наприклад, назва продукту).    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":159,"path":160,"dir":14,"title":161,"description":162,"keywords":163,"body":166},"content:1.android:1.lesson1:16.grid-layout.md","/android/lesson1/grid-layout","GridLayout (застарілий)","GridLayout представляє ще один контейнер, який дає змогу створювати табличні подання. GridLayout складається з колекції рядків, кожен з яких складається з окремих комірок:",[164,165],"Програмне створення GridLayout","GridLayout.LayoutParams","  GridLayout (застарілий)   GridLayout  представляє ще один контейнер, який дає змогу створювати табличні подання.   GridLayout  складається з колекції рядків, кожен з яких складається з окремих комірок:     \u003C  GridLayout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:rowCount  =  \"3\"\n       android:columnCount  =  \"3\"  >\n    \n       \u003C  Button   android:text  =  \"1\"   />\n       \u003C  Button   android:text  =  \"2\"   />\n       \u003C  Button   android:text  =  \"3\"   />\n       \u003C  Button   android:text  =  \"4\"   />\n       \u003C  Button   android:text  =  \"5\"   />\n       \u003C  Button   android:text  =  \"6\"   />\n       \u003C  Button   android:text  =  \"7\"   />\n    \n       \u003C  Button   android:text  =  \"8\"   />\n    \n       \u003C  Button   android:text  =  \"9\"   />\n   \u003C/  GridLayout  >\n  За допомогою атрибутів   android:rowCount  і   android:columnCount  встановлюється число рядків і стовпців відповідно. Так, у цьому випадку встановлюємо 3 рядки і 3 стовпці. GridLayout автоматично може позиціонувати вкладені елементи управління за рядками. Так, у нашому випадку перша кнопка потрапляє в перший осередок (перший рядок, перший стовпчик), друга кнопка - у другий осередок і так далі.    При цьому ширина стовпців встановлюється автоматично за шириною найширшого елемента.  Однак ми можемо явно задати номер стовпця і рядка для певного елемента, а за необхідності розтягнути на кілька стовпців або рядків. Для цього ми можемо застосовувати такі атрибути:    android:layout_column : номер стовпця (відлік іде від нуля)   android:layout_row : номер рядка   android:layout_columnSpan : кількість стовпців, на які розтягується елемент   android:layout_rowSpan : кількість рядків, на які розтягується елемент  Наприклад:     \u003C  GridLayout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:rowCount  =  \"3\"\n       android:columnCount  =  \"3\"  >\n    \n       \u003C  Button\n           android:text  =  \"1\"\n           android:layout_column  =  \"0\"\n           android:layout_row  =  \"0\"   />\n       \u003C  Button   android:text  =  \"2\"\n           android:layout_column  =  \"1\"\n           android:layout_row  =  \"0\"  />\n       \u003C  Button   android:text  =  \"3\"\n           android:layout_column  =  \"2\"\n           android:layout_row  =  \"0\"    />\n       \u003C  Button   android:text  =  \"4\"\n           android:layout_width  =  \"180dp\"\n           android:layout_columnSpan  =  \"2\"  />\n       \u003C  Button   android:text  =  \"5\"\n           android:layout_height  =  \"100dp\"\n           android:layout_rowSpan  =  \"2\"  />\n       \u003C  Button   android:text  =  \"6\"   />\n       \u003C  Button   android:text  =  \"7\"  />\n   \u003C/  GridLayout  >\n    Програмне створення GridLayout  Серед методів   GridLayout  слід відзначити методи   setRowCount()  і   setColumnCount() , які дають змогу задати відповідно кількість рядків і стовпців. Наприклад, визначимо в коді   GridLayout , аналогічний першому прикладу в статті:     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.view.Gravity  ;\n   import   android.widget.Button  ;\n   import   android.widget.EditText  ;\n   import   android.widget.GridLayout  ;\n   import   android.widget.LinearLayout  ;\n   import   android.widget.TableLayout  ;\n   import   android.widget.TableRow  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n    \n           GridLayout   gridLayout   =   new   GridLayout  (   this  );\n           gridLayout.  setRowCount  (  3  );\n           gridLayout.  setColumnCount  (  3  );\n    \n           for  (  int   i   =   1  ; i   \u003C=  9  ; i  ++  ){\n               Button   btn   =   new   Button  (  this  );\n               btn.  setText  (String.  valueOf  (i));\n               gridLayout.  addView  (btn);\n           }\n           setContentView  (gridLayout);\n       }\n   }\n  У цьому випадку   GridLayout  має три рядки і три стовпці. Під час додавання віджетів (у цьому разі кнопок) вони послідовно поміщаються в комірки грида по одному віджету в комірці.  GridLayout.LayoutParams  Для більш детального налаштування розташування віджета в гриді можна використовувати клас   GridLayout.LayoutParams . Цей клас має низку властивостей, які дають змогу налаштувати розташування:    columnSpec : задає стовпець для розташування у вигляді об'єкта   GridLayout.Spec   rowSpec : задає рядок для розташування у вигляді об'єкта   GridLayout.Spec   leftMargin : задає відступ зліва   rightMargin : задає відступ праворуч   topMargin : задає відступ зверху   bottomMargin : задає відступ знизу   width : задає ширину віджета   height : задає висоту віджета  Об'єкт   GridLayout.Spec  дає змогу задати розміщення в комірках стовпчика або рядка. Для створення цього об'єкта застосовується статичний метод   GridLayout.spec() , який має низку версій. Відзначимо серед них такі:    GridLayout.spec(int) : задає стовпець або рядок, де розташовується віджет. Відлік комірок починається з нуля. Віджет займає тільки одну клітинку   GridLayout.spec(int, int) : перший параметр задає стовпець або рядок, де розташовується віджет. Другий параметр вказує, наскільки комірок розтягується віджет   GridLayout.spec(int, android.widget.GridLayout.Alignment) : перший параметр задає стовпець або рядок, де розташовується віджет. Другий параметр встановлює вирівнювання віджета   GridLayout.spec(int, int, android.widget.GridLayout.Alignment) : перший параметр задає стовпець або рядок, де розташовується віджет. Другий параметр вказує, наскільки комірок розтягується віджет. Третій параметр встановлює вирівнювання віджета  Приклад застосування:     Button   btn   =   new   Button  (  this  );\n   btn.  setText  (  \"нажми\"  );\n   GridLayout  .  LayoutParams   layoutParams   =   new   GridLayout.  LayoutParams  ();\n    // кнопка помещается в нулевой столбец и растягивается на 2 столбца\n   layoutParams.columnSpec   =   GridLayout.  spec  (  0  ,  2  );\n    // кнопка помещается во вторую строку и растягивается на 1 строку\n   layoutParams.rowSpec   =   GridLayout.  spec  (  1  ,  1  );\n   layoutParams.leftMargin  =  5  ;\n   layoutParams.rightMargin  =  5  ;\n   layoutParams.topMargin  =  4  ;\n   layoutParams.bottomMargin  =  4  ;\n   layoutParams.width   =   GridLayout.LayoutParams.MATCH_PARENT;\n   layoutParams.height   =   GridLayout.LayoutParams.WRAP_CONTENT;\n   gridLayout.  addView  (btn, layoutParams);\n  Наприклад, реалізуємо в коді другий приклад із цієї статті:     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.util.TypedValue  ;\n   import   android.view.Gravity  ;\n   import   android.widget.Button  ;\n   import   android.widget.EditText  ;\n   import   android.widget.GridLayout  ;\n   import   android.widget.LinearLayout  ;\n   import   android.widget.TableLayout  ;\n   import   android.widget.TableRow  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n    \n           GridLayout   gridLayout   =   new   GridLayout  (   this  );\n    \n           // количество строк\n           gridLayout.  setRowCount  (  3  );\n           // количество столбцов\n           gridLayout.  setColumnCount  (  3  );\n    \n           for  (  int   i   =   1  ; i   \u003C=  3  ; i  ++  ){\n               Button   btn   =   new   Button  (  this  );\n               btn.  setText  (String.  valueOf  (i));\n               gridLayout.  addView  (btn);\n           }\n    \n           Button   btn4   =   new   Button  (  this  );\n           btn4.  setText  (  \"4\"  );\n           GridLayout  .  LayoutParams   layoutParams4   =   new   GridLayout.  LayoutParams  ();\n           layoutParams4.columnSpec   =   GridLayout.  spec  (  0  ,  2  );\n           layoutParams4.width   =   (  int  ) TypedValue.  applyDimension  (\n                   TypedValue.COMPLEX_UNIT_DIP,   180  ,   getResources  ().  getDisplayMetrics  ());\n           gridLayout.  addView  (btn4, layoutParams4);\n    \n    \n           Button   btn5   =   new   Button  (  this  );\n           btn5.  setText  (  \"5\"  );\n           GridLayout  .  LayoutParams   layoutParams5   =   new   GridLayout.  LayoutParams  ();\n           layoutParams5.rowSpec   =   GridLayout.  spec  (  1  ,  2  );\n           layoutParams5.height   =   (  int  ) TypedValue.  applyDimension  (\n                   TypedValue.COMPLEX_UNIT_DIP,   100  ,   getResources  ().  getDisplayMetrics  ());\n           gridLayout.  addView  (btn5, layoutParams5);\n    \n           Button   btn6   =   new   Button  (  this  );\n           btn6.  setText  (  \"6\"  );\n           Button   btn7   =   new   Button  (  this  );\n           btn7.  setText  (  \"7\"  );\n           gridLayout.  addView  (btn6);\n           gridLayout.  addView  (btn7);\n            \n           setContentView  (gridLayout);\n       }\n   }\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":168,"path":169,"dir":14,"title":170,"description":171,"keywords":172,"body":173},"content:1.android:1.lesson1:17.scroll-view.md","/android/lesson1/scroll-view","ScrollView","Контейнер ScrollView призначений для створення прокрутки для такого інтерфейсу, усі елементи якого одномоментно не можуть поміститися на екрані пристрою. ScrollView може вміщати тільки один елемент, тому якщо ми хочемо розмістити кілька елементів, то їх треба помістити в який-небудь контейнер.",[96],"  ScrollView  Контейнер   ScrollView  призначений для створення прокрутки для такого інтерфейсу, усі елементи якого одномоментно не можуть поміститися на екрані пристрою.   ScrollView    може вміщати тільки один елемент , тому якщо ми хочемо розмістити кілька елементів, то їх треба помістити в який-небудь контейнер.  Наприклад, визначимо ряд   TextView  з великими текстами:     \u003C  ScrollView\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n       \u003C  LinearLayout\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"match_parent\"\n           android:orientation  =  \"vertical\"\n           >\n           \u003C  TextView\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"What is Lorem Ipsum?\"\n               android:textSize  =  \"34sp\"   />\n           \u003C  TextView\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"Lorem Ipsum is simply dummy text of the printing and typesetting industry...like Aldus PageMaker including versions of Lorem Ipsum.\"\n               android:textSize  =  \"14sp\"  />\n           \u003C  TextView\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"Why do we use it?\"\n               android:layout_marginTop  =  \"16dp\"\n               android:textSize  =  \"34sp\"  />\n           \u003C  TextView\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"Lorem Ipsum is simply dummy text of the printing and typesetting industry...like Aldus PageMaker including versions of Lorem Ipsum.\"\n               android:textSize  =  \"14sp\"  />\n           \u003C  TextView\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"Where can I get some?\"\n               android:layout_marginTop  =  \"16dp\"\n               android:textSize  =  \"34sp\"  />\n           \u003C  TextView\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"There are many variations of passages of Lorem Ipsum available ... or non-characteristic words etc.\"\n               android:textSize  =  \"14sp\"  />\n       \u003C/  LinearLayout  >\n   \u003C/  ScrollView  >\n  Оскільки в   ScrollView  можна помістити тільки один елемент, то всі   TextView  укладені в   LinearLayout . І якщо площа екрана буде недостатньою, щоб помістити весь вміст   LinearLayout , то стане доступною прокрутка:    Створення   ScrollView  програмно в коді   MainActivity :     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n   import   android.view.ViewGroup  ;\n   import   android.widget.ScrollView  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           //setContentView(R.layout.activity_main);\n    \n           ScrollView   scrollView   =   new   ScrollView  (  this  );\n    \n           TextView   textView   =   new   TextView  (  this  );\n           textView.  setText  (  \"Lorem Ipsum is simply dummy text of the printing and typesetting industry...like Aldus PageMaker including versions of Lorem Ipsum.\"  );\n           textView.  setLayoutParams  (  new   ViewGroup  .  LayoutParams\n                   (ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));\n           textView.  setTextSize  (  26  );\n           scrollView.  addView  (textView);\n           setContentView  (scrollView);\n       }\n   }\n  Приклад     \u003C  ScrollView\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:fillViewport  =  \"true\"\n       android:background  =  \"@color/white\"  >\n   \n       \u003C!-- Контейнер для елементів -->\n       \u003C  LinearLayout\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"wrap_content\"\n           android:orientation  =  \"vertical\"\n           android:padding  =  \"16dp\"  >\n   \n           \u003C!-- Заголовок форми -->\n           \u003C  TextView\n               android:id  =  \"@+id/formTitle\"\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"Реєстрація\"\n               android:textSize  =  \"24sp\"\n               android:textStyle  =  \"bold\"\n               android:gravity  =  \"center\"\n               android:layout_gravity  =  \"center\"\n               android:paddingBottom  =  \"16dp\"   />\n   \n           \u003C!-- Поле для введення імені -->\n           \u003C  EditText\n               android:id  =  \"@+id/nameInput\"\n               android:layout_width  =  \"match_parent\"\n               android:layout_height  =  \"wrap_content\"\n               android:hint  =  \"Ім'я\"\n               android:inputType  =  \"textPersonName\"\n               android:padding  =  \"12dp\"\n               android:background  =  \"@drawable/input_background\"\n               android:layout_marginBottom  =  \"8dp\"   />\n   \n           \u003C!-- Поле для введення email -->\n           \u003C  EditText\n               android:id  =  \"@+id/emailInput\"\n               android:layout_width  =  \"match_parent\"\n               android:layout_height  =  \"wrap_content\"\n               android:hint  =  \"Email\"\n               android:inputType  =  \"textEmailAddress\"\n               android:padding  =  \"12dp\"\n               android:background  =  \"@drawable/input_background\"\n               android:layout_marginBottom  =  \"8dp\"   />\n   \n           \u003C!-- Поле для введення паролю -->\n           \u003C  EditText\n               android:id  =  \"@+id/passwordInput\"\n               android:layout_width  =  \"match_parent\"\n               android:layout_height  =  \"wrap_content\"\n               android:hint  =  \"Пароль\"\n               android:inputType  =  \"textPassword\"\n               android:padding  =  \"12dp\"\n               android:background  =  \"@drawable/input_background\"\n               android:layout_marginBottom  =  \"8dp\"   />\n   \n           \u003C!-- Поле для введення телефону -->\n           \u003C  EditText\n               android:id  =  \"@+id/phoneInput\"\n               android:layout_width  =  \"match_parent\"\n               android:layout_height  =  \"wrap_content\"\n               android:hint  =  \"Телефон\"\n               android:inputType  =  \"phone\"\n               android:padding  =  \"12dp\"\n               android:background  =  \"@drawable/input_background\"\n               android:layout_marginBottom  =  \"16dp\"   />\n   \n           \u003C!-- Кнопка для подання форми -->\n           \u003C  Button\n               android:id  =  \"@+id/submitButton\"\n               android:layout_width  =  \"match_parent\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"Зареєструватися\"\n               android:backgroundTint  =  \"@color/primary\"\n               android:textColor  =  \"@color/white\"\n               android:layout_marginBottom  =  \"16dp\"   />\n   \n       \u003C/  LinearLayout  >\n   \u003C/  ScrollView  >\n     import   android.os.Bundle  ;\n   import   android.widget.Button  ;\n   import   android.widget.EditText  ;\n   import   android.widget.Toast  ;\n   import   androidx.appcompat.app.AppCompatActivity  ;\n   \n   public   class   RegistrationActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_registration);\n   \n           // Пошук елементів\n           EditText   nameInput   =   findViewById  (R.id.nameInput);\n           EditText   emailInput   =   findViewById  (R.id.emailInput);\n           EditText   passwordInput   =   findViewById  (R.id.passwordInput);\n           EditText   phoneInput   =   findViewById  (R.id.phoneInput);\n           Button   submitButton   =   findViewById  (R.id.submitButton);\n   \n           // Обробка натискання на кнопку\n           submitButton.  setOnClickListener  (v   ->   {\n               String   name   =   nameInput.  getText  ().  toString  ();\n               String   email   =   emailInput.  getText  ().  toString  ();\n               String   password   =   passwordInput.  getText  ().  toString  ();\n               String   phone   =   phoneInput.  getText  ().  toString  ();\n   \n               // Перевірка заповнення полів\n               if   (name.  isEmpty  ()   ||   email.  isEmpty  ()   ||   password.  isEmpty  ()   ||   phone.  isEmpty  ()) {\n                   Toast.  makeText  (  this  ,   \"Будь ласка, заповніть усі поля\"  , Toast.LENGTH_SHORT).  show  ();\n               }   else   {\n                   // Обробка даних форми (наприклад, надсилання на сервер)\n                   Toast.  makeText  (  this  ,   \"Реєстрація успішна!\"  , Toast.LENGTH_SHORT).  show  ();\n               }\n           });\n       }\n   }\n   Якщо вміст дуже великий, це може призводити до зниження продуктивності. Для динамічних списків краще використовувати RecyclerView.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":175,"path":176,"dir":14,"title":177,"description":178,"keywords":179,"body":180},"content:1.android:1.lesson1:18.nested-layout.md","/android/lesson1/nested-layout","Вкладені layout","Один layout може містити інший layout. Для цього застосовується елемент include.",[],"  Вкладені layout  Один layout може містити інший layout. Для цього застосовується елемент   include .  Наприклад, додамо в папку   res/layout  два файли   layout , які нехай називатимуться   text_panel.xml  і   button_panel.xml :\n  \nУ файлі   text_panel.xml  визначимо такий код:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"wrap_content\"\n       android:layout_height  =  \"wrap_content\"  >\n       \u003C  TextView\n           android:id  =  \"@+id/clicksText\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"30sp\"\n           android:text  =  \"0 Clicks\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           />\n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  По суті тут просто визначено поле   TextView  для виведення тексту.\nУ файлі   button_panel.xml  визначимо таку розмітку:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"wrap_content\"\n       android:layout_height  =  \"wrap_content\"  >\n       \u003C  Button\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Click\"\n           android:onClick  =  \"onClick\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Тут визначено кнопку, натискання якої ми будемо обробляти.  Основним файлом розмітки, який визначає інтерфейс програми, як і раніше, є   activity_main.xml . Змінимо його:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"\n       tools:context  =  \".MainActivity\"  >\n    \n       \u003C  include\n           android:id  =  \"@+id/textView\"\n           layout  =  \"@layout/text_panel\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toTopOf  =  \"@+id/button\"\n           />\n       \u003C  include\n           android:id  =  \"@+id/button\"\n           layout  =  \"@layout/button_panel\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/textView\"\n           />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  За допомогою   ConstraintLayout  весь інтерфейс тут організовується у вигляді вертикального стека. За допомогою елементів include всередину   ConstraintLayout  додається вміст файлів   text_panel.xml  і   button_panel.xml . Для зазначення назви файлу застосовується атрибут   layout .  Це все одно, що якби ми безпосередньо замість елемента   include  додали вміст файлів. Однак такий спосіб має свої переваги. Наприклад, якась частина розмітки, група елементів управління може повторюватися в різних   activity . І щоб не визначати по сто разів ці елементи, можна винести їх в окремий файл layout і за допомогою   include  підключати їх.  Після додавання в   ConstraintLayout  до елементів   include  можна застосовувати всі ті стандартні атрибути, які застосовуються в цьому контейнері до вкладених елементів, наприклад, налаштувати розміри, розташування. Також варто зазначити, що додавати зовнішні   layout  можна не тільки в   ConstraintLayout , а й в інші контейнери (  LinearLayout ,   RelativeLayout  тощо).  Також змінимо код   MainActivity :     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       int   clicks   =   0  ;\n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n    \n       public   void   onClick  (  View   view  ){\n           TextView   clicksText   =   findViewById  (R.id.clicksText);\n           clicks  ++  ;\n           clicksText.  setText  (clicks   +   \" Clicks\"  );\n       }\n   }\n  У   MainActivity  ми можемо звертатися до елементів у вкладених файлах   layout . Наприклад, ми можемо встановити обробник натискання кнопки, у якому під час натискання змінюватимемо текст у   TextView .    При цьому ми кілька разів можемо додавати в один файл   layout  інший файл   layout . Для цього спочатку змінимо файл   button_panel.xml  таким чином:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"wrap_content\"\n       android:layout_height  =  \"wrap_content\"\n       android:background  =  \"#3F51B5\"\n       android:paddingTop  =  \"10dp\"\n       android:paddingBottom  =  \"10dp\"  >\n       \u003C  Button\n           android:id  =  \"@+id/clickBtn\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  І змінимо файл activity_main.xml:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"\n       tools:context  =  \".MainActivity\"  >\n    \n       \u003C  include\n           layout  =  \"@layout/text_panel\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           />\n       \u003C  include   layout  =  \"@layout/button_panel\"\n           android:id  =  \"@+id/plus_button\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintRight_toLeftOf  =  \"@+id/minus_button\"  />\n    \n       \u003C  include   layout  =  \"@layout/button_panel\"\n           android:id  =  \"@+id/minus_button\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_marginLeft  =  \"36dp\"\n           app:layout_constraintLeft_toRightOf  =  \"@id/plus_button\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"  />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Тепер файл   button_panel.xml  додається двічі. Важливо, що під час додавання цього файлу кожному елементу   include  присвоєно певний   id . За цим   id  ми зможемо дізнатися, про який саме елемент   include  ідеться.  Також змінимо   MainActivity :     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.Button  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       int   clicks   =   0  ;\n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           View   plusButtonView   =   findViewById  (R.id.plus_button);\n           View   minusButtonView   =   findViewById  (R.id.minus_button);\n           TextView   clicksText   =   findViewById  (R.id.clicksText);\n    \n           Button   plusButton   =   plusButtonView.  findViewById  (R.id.clickBtn);\n           Button   minusButton   =   minusButtonView.  findViewById  (R.id.clickBtn);\n    \n           plusButton.  setText  (  \"+\"  );\n           minusButton.  setText  (  \"-\"  );\n    \n           plusButton.  setOnClickListener  (v   ->   {\n               clicks  ++  ;\n               clicksText.  setText  (clicks   +   \" Clicks\"  );\n           });\n           minusButton.  setOnClickListener  (v   ->   {\n               clicks  --  ;\n               clicksText.  setText  (clicks   +   \" Clicks\"  );\n           });\n       }\n   }\n  Тут спочатку ми отримуємо окремі елементи   include  за   id . Потім у межах цих елементів отримуємо кнопку. Після цього ми можемо встановити біля кнопки будь-який текст і повісити обробник події натискання. І таким чином, поведінка обох кнопок буде відрізнятися.    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":182,"path":183,"dir":14,"title":184,"description":185,"keywords":186,"body":188},"content:1.android:1.lesson1:19.gravity.md","/android/lesson1/gravity","Атрибут gravity","Атрибут gravity задає позиціонування вмісту всередині візуального елемента. Він може приймати такі значення:",[96,187,96],"Програмне встановлення gravity","  Атрибут gravity  Атрибут   gravity  задає позиціонування вмісту всередині візуального елемента. Він може приймати такі значення:     top : елементи розташовуються у верхній частині.    bottom : елементи розташовуються у нижній частині.    left : елементи розташовуються з лівого боку.    right : елементи розташовуються з правого боку контейнера.    center_vertical : вирівнює елементи по центру вертикально.    center_horizontal : вирівнює елементи по центру горизонтально.    center : елементи розташовуються по центру.    fill_vertical : елемент розтягується вертикально.    fill_horizontal : елемент розтягується горизонтально.    fill : елемент заповнює весь простір контейнера.    clip_vertical : обрізає верхню і нижню межі елементів.    clip_horizontal : обрізає праву і ліву межі елементів.    start : елемент позиціонується на початку (у верхньому лівому куті) контейнера.    end : елемент позиціонується в кінці (у верхньому правому куті) контейнера.  Приклад  Розмістимо текст у нижній частині елемента   TextView :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       tools:context  =  \".MainActivity\"  >\n    \n       \u003C  TextView\n           android:gravity  =  \"bottom\"\n            \n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"200dp\"\n           android:text  =  \"Hello Android!\"\n           android:textSize  =  \"30sp\"\n           android:background  =  \"#e8eaf6\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n   \nЗа необхідності ми можемо комбінувати значення, розділяючи їх вертикальною рискою:     \u003C  TextView\n       android:gravity  =  \"bottom|right\"\n            \n       android:layout_width  =  \"0dp\"\n       android:layout_height  =  \"200dp\"\n       android:text  =  \"Hello Android!\"\n       android:textSize  =  \"30sp\"\n       android:background  =  \"#e8eaf6\"\n       app:layout_constraintLeft_toLeftOf  =  \"parent\"\n       app:layout_constraintRight_toRightOf  =  \"parent\"\n       app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    Програмне встановлення   gravity  Щоб встановити параметр   gravity  програмним шляхом, потрібно викликати метод   setGravity() . У якості параметра до методу передається одна з констант класу   Gravity , які відповідають значенням атрибута (з тією різницею, що назви записані у верхньому регістрі).  Приклад  Розглянемо приклад програмного встановлення   gravity  для елемента   TextView :     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   androidx.constraintlayout.widget.ConstraintLayout  ;\n    \n   import   android.os.Bundle  ;\n   import   android.view.Gravity  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n    \n           ConstraintLayout   constraintLayout   =   new   ConstraintLayout  (  this  );\n           TextView   textView   =   new   TextView  (  this  );\n           textView.  setText  (  \"Hello Android!\"  );\n           textView.  setTextSize  (  30  );\n           textView.  setBackgroundColor  (  0xffe8eaf6  );\n    \n           // установка гравітації\n           textView.  setGravity  (Gravity.CENTER);\n    \n           // встановлення висоти та ширини\n           ConstraintLayout  .  LayoutParams   layoutParams   =   new   ConstraintLayout  .  LayoutParams\n                   (ConstraintLayout.LayoutParams.MATCH_CONSTRAINT,   200  );\n           layoutParams.leftToLeft   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           layoutParams.rightToRight   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           layoutParams.topToTop   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           layoutParams.bottomToBottom   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           textView.  setLayoutParams  (layoutParams);\n    \n           constraintLayout.  addView  (textView);\n           setContentView  (constraintLayout);\n       }\n   }\n    Для поєднання кількох значень також можна використовувати вертикальну риску:     textView.  setGravity  (Gravity.BOTTOM   |   Gravity.CENTER);\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":190,"path":191,"dir":192,"title":33,"description":193,"keywords":194,"body":198},"content:1.android:2.lesson2:1.text-view.md","/android/lesson2/text-view","lesson2","Для простого виведення тексту на екран використовується елемент TextView. Він просто відображає текст без можливості його редагування.",[195,196,197],"Основні атрибути","Можливі значення android:textAlignment","Типи шрифтів (android:fontFamily)","  TextView  Для простого виведення тексту на екран використовується елемент   TextView . Він просто відображає текст без можливості його редагування.  Основні атрибути     android:text : встановлює текст елемента.    android:textSize : задає розмір тексту. Одиницями вимірювання є   sp  (scale-independent pixels).    android:background : задає фоновий колір елемента у вигляді шестнадцяткового коду кольору або через ресурс кольору.    android:textColor : задає колір тексту.    android:textAllCaps : якщо значення   true , всі символи тексту стають великими.    android:textDirection : встановлює напрямок тексту. За замовчуванням напрямок — зліва направо (  ltr ), але можна встановити справа наліво (  rtl ).    android:textAlignment : задає вирівнювання тексту.  Можливі значення   android:textAlignment     center : вирівнювання по центру.    textStart : вирівнювання по лівому краю.    textEnd : вирівнювання по правому краю.    viewStart : при напрямку тексту зліва направо — вирівнювання по лівому краю; справа наліво — по правому.    viewEnd : при напрямку тексту зліва направо — вирівнювання по правому краю; справа наліво — по лівому.  Типи шрифтів (  android:fontFamily )  Можна встановити наступні шрифти:     monospace    serif    serif-monospace    sans-serif    sans-serif-condensed    sans-serif-smallcaps    sans-serif-light    casual    cursive  Наприклад, визначимо три текстових поля:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  TextView\n           android:layout_height  =  \"wrap_content\"\n           android:layout_width  =  \"0dp\"\n           android:layout_margin  =  \"10dp\"\n    \n           android:text  =  \"Hello Android \"\n           android:fontFamily  =  \"sans-serif\"\n           android:textSize  =  \"26sp\"\n           android:background  =  \"#ffebee\"\n           android:textColor  =  \"#f44336\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"  />\n       \u003C  TextView\n           android:layout_height  =  \"wrap_content\"\n           android:layout_width  =  \"0dp\"\n           android:layout_margin  =  \"10dp\"\n    \n           android:text  =  \"Hello Java\"\n           android:textAllCaps  =  \"true\"\n           android:textSize  =  \"26sp\"\n           android:background  =  \"#ede7f6\"\n           android:textColor  =  \"#7e57c2\"\n    \n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"  />\n    \n       \u003C  TextView\n           android:layout_height  =  \"wrap_content\"\n           android:layout_width  =  \"0dp\"\n           android:layout_margin  =  \"10dp\"\n    \n           android:text  =  \"Hello World\"\n           android:textAlignment  =  \"textEnd\"\n           android:textSize  =  \"26sp\"\n           android:background  =  \"#e8eaf6\"\n           android:textColor  =  \"#5c6bc0\"\n            \n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"  />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n    Встановлення елемента в коді теж не відрізняється складністю. Наприклад, створимо елемент і виведемо його на екран:     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   androidx.constraintlayout.widget.ConstraintLayout  ;\n    \n   import   android.graphics.Typeface  ;\n   import   android.os.Bundle  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n    \n           ConstraintLayout   constraintLayout   =   new   ConstraintLayout  (  this  );\n           TextView   textView   =   new   TextView  (  this  );\n           textView.  setBackgroundColor  (  0xffe8eaf6  );\n           textView.  setTextColor  (  0xff5c6bc0  );\n           textView.  setAllCaps  (  true  );\n           textView.  setTextAlignment  (TextView.TEXT_ALIGNMENT_CENTER);\n           textView.  setText  (  \"Hello Android!\"  );\n           textView.  setTypeface  (Typeface.  create  (  \"casual\"  , Typeface.NORMAL));\n           textView.  setTextSize  (  26  );\n    \n           ConstraintLayout  .  LayoutParams   layoutParams   =   new   ConstraintLayout  .  LayoutParams\n                   (ConstraintLayout.LayoutParams.WRAP_CONTENT, ConstraintLayout.LayoutParams.WRAP_CONTENT);\n           layoutParams.leftToLeft   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           layoutParams.topToTop   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           textView.  setLayoutParams  (layoutParams);\n    \n           constraintLayout.  addView  (textView);\n           setContentView  (constraintLayout);\n       }\n   }\n    Іноді необхідно вивести на екран якесь посилання або телефон, після натискання на які здійснювалася б певна дія. Для цього в   TextView  визначено атрибут   android:autoLink :     \u003C  TextView\n       android:text  =  \"Посетите сайт https://metanit.com\"\n       android:textSize  =  \"21sp\"\n       android:layout_width  =  \"wrap_content\"\n       android:layout_height  =  \"wrap_content\"\n       android:autoLink  =  \"web|email\"\n        \n       app:layout_constraintLeft_toLeftOf  =  \"parent\"\n       app:layout_constraintTop_toTopOf  =  \"parent\"  />\n    Атрибут   android:autoLink  дозволяє автоматично розпізнавати та активувати різні типи посилань у тексті. Він може приймати наступні значення:     none : вимикає всі посилання.    web : активує всі веб-посилання.    email : активує посилання на електронні адреси.    phone : активує посилання на номери телефонів.    map : активує посилання на карту.    all : активує всі вищезгадані типи посилань.  Тобто при налаштуванні   android:autoLink=\"web\"  якщо в тексті є згадка адреси url, то ця адреса буде виділятися, а під час натискання на неї буде здійснено перехід до веббраузера, який відкриє сторінку за цією адресою. За допомогою прямої риски ми можемо об'єднувати умови, як у цьому випадку:   android:autoLink=\"web|email\"    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":200,"path":201,"dir":192,"title":202,"description":203,"keywords":204,"body":205},"content:1.android:2.lesson2:2.edit-text.md","/android/lesson2/edit-text","EditText","EditText — це підклас TextView, який представляє текстове поле з можливістю введення і редагування тексту. В елементі EditText можна використовувати всі можливості TextView, а також додаткові атрибути, специфічні для введення даних.",[195],"  EditText   EditText  — це підклас   TextView , який представляє текстове поле з можливістю введення і редагування тексту. В елементі   EditText  можна використовувати всі можливості   TextView , а також додаткові атрибути, специфічні для введення даних.   Основні атрибути    android:hint  Дозволяє встановити текст-підказку, який буде відображатися, якщо поле порожнє.    android:inputType  Дозволяє задати тип клавіатури для введення тексту. Доступні значення:     text : стандартна клавіатура для введення однорядкового тексту.    textMultiLine : багаторядкове текстове поле.    textEmailAddress : клавіатура з символом   @ , призначена для введення email-адрес.    textUri : клавіатура з символом   / , призначена для введення інтернет-адрес.    textPassword : клавіатура для введення паролів.    textCapWords : кожне введене слово починається з великої літери.    number : цифрова клавіатура.    phone : клавіатура у стилі телефонної для введення номерів.    date : клавіатура для введення дати.    time : клавіатура для введення часу.    datetime : клавіатура для введення дати та часу.     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  EditText\n           android:id  =  \"@+id/name\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:hint  =  \"Введіть ім'я\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"  />\n       \u003C  EditText\n           android:id  =  \"@+id/message\"\n           android:layout_marginTop  =  \"16dp\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           android:hint  =  \"Введіть повідомлення\"\n           android:inputType  =  \"textMultiLine\"\n           android:gravity  =  \"top\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/name\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"   />\n        \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Перше поле тут звичайне однорядкове, а друге - багаторядкове. Щоб у другому полі текст вирівнювався по верху, додатково встановлюється атрибут   android:gravity=\"top\" .    Однією з можливостей елемента   EditText  також є можливість обробити введені символи в міру введення користувача. Для цього визначимо у файлі   activity_main.xml  таку розмітку:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"34sp\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"  />\n       \u003C  EditText\n           android:id  =  \"@+id/editText\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:hint  =  \"Введите имя\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/textView\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"   />\n    \n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Передбачається, що введені в   EditText  символи одразу ж відображатимуться в елементі   TextView . І для цього також змінимо код   MainActivity :     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.text.Editable  ;\n   import   android.text.TextWatcher  ;\n   import   android.widget.EditText  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           EditText   editText   =   findViewById  (R.id.editText);\n    \n           editText.  addTextChangedListener  (  new   TextWatcher  () {\n    \n               public   void   afterTextChanged  (  Editable   s  ) {}\n    \n               public   void   beforeTextChanged  (  CharSequence   s  ,   int   start  ,\n                                             int   count  ,   int   after  ) {\n               }\n    \n               public   void   onTextChanged  (  CharSequence   s  ,   int   start  ,   int   before  ,   int   count  ) {\n                   TextView   textView   =   findViewById  (R.id.textView);\n                   textView.  setText  (s);\n               }\n           });\n       }\n   }\n  За допомогою методу   addTextChangedListener()  до елемента   EditText  можна додати слухача введення тексту — об'єкт   TextWatcher . Для його використання необхідно реалізувати три методи, але на практиці достатньо реалізації методу   onTextChanged , який викликається при зміні тексту.\nВведений текст передається в цей метод як параметр   CharSequence . У самому методі просто передаємо цей текст в елемент   TextView .  У результаті при введенні тексту в   EditText  всі символи також відображатимуться у   TextView .      html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":207,"path":208,"dir":192,"title":209,"description":210,"keywords":211,"body":213},"content:1.android:2.lesson2:3.button.md","/android/lesson2/button","Button","Одним із часто використовуваних елементів є кнопки, які представлені класом android.widget.Button. Ключовою особливістю кнопок є можливість взаємодії з користувачем через натискання.",[212],"Основні атрибути кнопок:","  Button  Одним із часто використовуваних елементів є кнопки, які представлені класом   android.widget.Button . Ключовою особливістю кнопок є можливість взаємодії з користувачем через натискання.   Основні атрибути кнопок:     text : задає текст на кнопці.    textColor : задає колір тексту на кнопці.    background : задає фоновий колір кнопки.    textAllCaps : при значенні   true  встановлює текст у верхньому регістрі. За замовчуванням використовується значення   true .    onClick : задає обробник натискання кнопки.   Отже, змінимо код у файлі   activity_main.xml  наступним чином:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"34sp\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"  />\n       \u003C  EditText\n           android:id  =  \"@+id/editText\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:hint  =  \"Введите имя\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/textView\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"   />\n       \u003C  Button\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Ввод\"\n           android:onClick  =  \"sendMessage\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/editText\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"   />\n    \n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  За допомогою атрибута   android:onClick  можна задати метод у коді java, який оброблятиме натискання кнопки. Так, у вищенаведеному прикладі це метод   sendMessage . Тепер перейдемо до коду   MainActivity  і пропишемо в ньому такий метод:     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.EditText  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n       // Обработка нажатия кнопки\n       public   void   sendMessage  (  View   view  ) {\n           TextView   textView   =   findViewById  (R.id.textView);\n           EditText   editText   =   findViewById  (R.id.editText);\n           textView.  setText  (  \"Добро пожаловать, \"   +   editText.  getText  ());\n       }\n   }\n  При створенні методу обробки натискання слід враховувати наступні моменти:   Метод повинен оголошуватися з модифікатором   public .  Повинен повертати значення   void .  Як параметр приймати об'єкт   View . Цей об'єкт   View  і є натиснутою кнопкою.  У цьому випадку після натискання на кнопку в   TextView  виводиться текст із   EditText .    Аналогічний приклад повністю в коді   MainActivity :     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   androidx.constraintlayout.widget.ConstraintLayout  ;\n    \n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.Button  ;\n   import   android.widget.EditText  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       EditText   editText;\n       TextView   textView;\n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           //setContentView(R.layout.activity_main);\n    \n           ConstraintLayout   constraintLayout   =   new   ConstraintLayout  (  this  );\n           textView   =   new   TextView  (  this  );\n           textView.  setId  (View.  generateViewId  ());\n           ConstraintLayout  .  LayoutParams   textViewLayout   =    new   ConstraintLayout.  LayoutParams  (\n                   ConstraintLayout.LayoutParams.MATCH_CONSTRAINT, ConstraintLayout.LayoutParams.WRAP_CONTENT\n           );\n           textViewLayout.topToTop   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           textViewLayout.leftToLeft   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           textViewLayout.rightToRight   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           textView.  setLayoutParams  (textViewLayout);\n           constraintLayout.  addView  (textView);\n    \n           editText   =   new   EditText  (  this  );\n           editText.  setId  (View.  generateViewId  ());\n           editText.  setHint  (  \"Введите имя\"  );\n           ConstraintLayout  .  LayoutParams   editTextLayout   =    new   ConstraintLayout.  LayoutParams  (\n                   ConstraintLayout.LayoutParams.MATCH_CONSTRAINT, ConstraintLayout.LayoutParams.WRAP_CONTENT\n           );\n           editTextLayout.topToBottom   =   textView.  getId  ();\n           editTextLayout.leftToLeft   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           editTextLayout.rightToRight   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           editText.  setLayoutParams  (editTextLayout);\n           constraintLayout.  addView  (editText);\n    \n           Button   button   =   new   Button  (  this  );\n           button.  setText  (  \"Ввод\"  );\n           ConstraintLayout  .  LayoutParams   buttonLayout   =    new   ConstraintLayout.  LayoutParams  (\n                   ConstraintLayout.LayoutParams.WRAP_CONTENT, ConstraintLayout.LayoutParams.WRAP_CONTENT\n           );\n           buttonLayout.topToBottom   =   editText.  getId  ();\n           buttonLayout.leftToLeft   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           button.  setLayoutParams  (buttonLayout);\n           constraintLayout.  addView  (button);\n    \n           button.  setOnClickListener  (  new   View.  OnClickListener  () {\n               public   void   onClick  (  View   v) {\n                   // Обробка натискання\n                   textView.  setText  (  \"Добро пожаловать, \"   +   editText.  getText  ());\n               }\n           });\n    \n           setContentView  (constraintLayout);\n       }\n   }\n  При програмному створенні кнопки ми можемо визначити у неї слухач натискання   View .  OnClickListener  і за допомогою його методу   onClick  також обробити натискання:     button.  setOnClickListener  (  new   View.  OnClickListener  () {\n       public   void   onClick  (  View   v) {\n           // Обробка натискання\n       }\n   });\n    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":215,"path":216,"dir":192,"title":217,"description":218,"keywords":219,"body":225},"content:1.android:2.lesson2:4.calculator.md","/android/lesson2/calculator","Калькулятор","Цей приклад демонструє створення простого калькулятора для Android із використанням найкращих практик, але без застосування архітектури MVVM.",[220,221,222,223,224],"Основні функціональні вимоги","Структура проєкту","Файл розмітки activity_main.xml","Код MainActivity.java","Висновок","  Калькулятор  Цей приклад демонструє створення простого калькулятора для Android із використанням найкращих практик, але без застосування архітектури MVVM.   Основні функціональні вимоги    Функції : додавання, віднімання, множення, ділення.   Інтерфейс : кнопки для цифр та операцій, а також поле для виведення результатів.   Обробка помилок : перевірка введення та уникнення поділу на нуль.   Структура проєкту     MainActivity  — головна активність.   Розмітка  — файл XML для UI.   Файл розмітки   activity_main.xml  Розмітка містить:   Поле для введення та відображення результатів.  Кнопки для цифр та математичних операцій.     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  LinearLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:orientation  =  \"vertical\"\n       android:padding  =  \"16dp\"  >\n   \n       \u003C  EditText\n           android:id  =  \"@+id/editTextResult\"\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"wrap_content\"\n           android:hint  =  \"0\"\n           android:textSize  =  \"24sp\"\n           android:gravity  =  \"right\"\n           android:inputType  =  \"none\"\n           android:focusable  =  \"false\"   />\n   \n       \u003C  GridLayout\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"wrap_content\"\n           android:columnCount  =  \"4\"\n           android:paddingTop  =  \"16dp\"  >\n   \n           \u003C!-- Buttons for numbers -->\n           \u003C  Button\n               android:text  =  \"7\"\n               android:layout_width  =  \"0dp\"\n               android:layout_height  =  \"wrap_content\"\n               android:layout_columnWeight  =  \"1\"\n               android:onClick  =  \"onNumberClick\"   />\n   \n           \u003C  Button\n               android:text  =  \"8\"\n               android:layout_width  =  \"0dp\"\n               android:layout_height  =  \"wrap_content\"\n               android:layout_columnWeight  =  \"1\"\n               android:onClick  =  \"onNumberClick\"   />\n   \n           \u003C  Button\n               android:text  =  \"9\"\n               android:layout_width  =  \"0dp\"\n               android:layout_height  =  \"wrap_content\"\n               android:layout_columnWeight  =  \"1\"\n               android:onClick  =  \"onNumberClick\"   />\n   \n           \u003C  Button\n               android:text  =  \"/\"\n               android:layout_width  =  \"0dp\"\n               android:layout_height  =  \"wrap_content\"\n               android:layout_columnWeight  =  \"1\"\n               android:onClick  =  \"onOperatorClick\"   />\n   \n           \u003C!-- Кнопки другого ряду -->\n           \u003C  Button\n               android:text  =  \"4\"\n               android:layout_width  =  \"0dp\"\n               android:layout_height  =  \"wrap_content\"\n               android:layout_columnWeight  =  \"1\"\n               android:onClick  =  \"onNumberClick\"   />\n   \n           \u003C  Button\n               android:text  =  \"5\"\n               android:layout_width  =  \"0dp\"\n               android:layout_height  =  \"wrap_content\"\n               android:layout_columnWeight  =  \"1\"\n               android:onClick  =  \"onNumberClick\"   />\n   \n           \u003C  Button\n               android:text  =  \"6\"\n               android:layout_width  =  \"0dp\"\n               android:layout_height  =  \"wrap_content\"\n               android:layout_columnWeight  =  \"1\"\n               android:onClick  =  \"onNumberClick\"   />\n   \n           \u003C  Button\n               android:text  =  \"*\"\n               android:layout_width  =  \"0dp\"\n               android:layout_height  =  \"wrap_content\"\n               android:layout_columnWeight  =  \"1\"\n               android:onClick  =  \"onOperatorClick\"   />\n   \n           \u003C!-- Кнопки третього ряду -->\n           \u003C  Button\n               android:text  =  \"1\"\n               android:layout_width  =  \"0dp\"\n               android:layout_height  =  \"wrap_content\"\n               android:layout_columnWeight  =  \"1\"\n               android:onClick  =  \"onNumberClick\"   />\n   \n           \u003C  Button\n               android:text  =  \"2\"\n               android:layout_width  =  \"0dp\"\n               android:layout_height  =  \"wrap_content\"\n               android:layout_columnWeight  =  \"1\"\n               android:onClick  =  \"onNumberClick\"   />\n   \n           \u003C  Button\n               android:text  =  \"3\"\n               android:layout_width  =  \"0dp\"\n               android:layout_height  =  \"wrap_content\"\n               android:layout_columnWeight  =  \"1\"\n               android:onClick  =  \"onNumberClick\"   />\n   \n           \u003C  Button\n               android:text  =  \"-\"\n               android:layout_width  =  \"0dp\"\n               android:layout_height  =  \"wrap_content\"\n               android:layout_columnWeight  =  \"1\"\n               android:onClick  =  \"onOperatorClick\"   />\n   \n           \u003C!-- Кнопки останнього ряду -->\n           \u003C  Button\n               android:text  =  \"0\"\n               android:layout_width  =  \"0dp\"\n               android:layout_height  =  \"wrap_content\"\n               android:layout_columnWeight  =  \"1\"\n               android:onClick  =  \"onNumberClick\"   />\n   \n           \u003C  Button\n               android:text  =  \"C\"\n               android:layout_width  =  \"0dp\"\n               android:layout_height  =  \"wrap_content\"\n               android:layout_columnWeight  =  \"1\"\n               android:onClick  =  \"onClearClick\"   />\n   \n           \u003C  Button\n               android:text  =  \".\"\n               android:layout_width  =  \"0dp\"\n               android:layout_height  =  \"wrap_content\"\n               android:layout_columnWeight  =  \"1\"\n               android:onClick  =  \"onDecimalClick\"   />\n   \n           \u003C  Button\n               android:text  =  \"+\"\n               android:layout_width  =  \"0dp\"\n               android:layout_height  =  \"wrap_content\"\n               android:layout_columnWeight  =  \"1\"\n               android:onClick  =  \"onOperatorClick\"   />\n   \n       \u003C/  GridLayout  >\n   \n       \u003C  Button\n           android:text  =  \"=\"\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"wrap_content\"\n           android:onClick  =  \"onEqualClick\"   />\n   \u003C/  LinearLayout  >\n   Код   MainActivity.java  Головна логіка обробки подій натискання кнопок.     package   com.example.calculator  ;\n   \n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.Button  ;\n   import   android.widget.EditText  ;\n   import   androidx.appcompat.app.AppCompatActivity  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n       private   EditText   editTextResult;\n       private   String   currentOperator   =   \"\"  ;\n       private   double   firstValue   =   0  ;\n       private   boolean   isOperatorClicked   =   false  ;\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n   \n           editTextResult   =   findViewById  (R.id.editTextResult);\n       }\n   \n       public   void   onNumberClick  (  View   view  ) {\n           Button   button   =   (Button) view;\n           String   currentText   =   editTextResult.  getText  ().  toString  ();\n   \n           if   (isOperatorClicked) {\n               currentText   =   \"\"  ;\n               isOperatorClicked   =   false  ;\n           }\n   \n           editTextResult.  setText  (currentText   +   button.  getText  ().  toString  ());\n       }\n   \n       public   void   onOperatorClick  (  View   view  ) {\n           Button   button   =   (Button) view;\n           currentOperator   =   button.  getText  ().  toString  ();\n           firstValue   =   Double.  parseDouble  (editTextResult.  getText  ().  toString  ());\n           isOperatorClicked   =   true  ;\n       }\n   \n       public   void   onEqualClick  (  View   view  ) {\n           double   secondValue   =   Double.  parseDouble  (editTextResult.  getText  ().  toString  ());\n           double   result   =   0  ;\n   \n           switch   (currentOperator) {\n               case   \"+\"  :\n                   result   =   firstValue   +   secondValue;\n                   break  ;\n               case   \"-\"  :\n                   result   =   firstValue   -   secondValue;\n                   break  ;\n               case   \"*\"  :\n                   result   =   firstValue   *   secondValue;\n                   break  ;\n               case   \"/\"  :\n                   if   (secondValue   !=   0  ) {\n                       result   =   firstValue   /   secondValue;\n                   }   else   {\n                       editTextResult.  setText  (  \"Error\"  );\n                       return  ;\n                   }\n                   break  ;\n           }\n   \n           editTextResult.  setText  (String.  valueOf  (result));\n       }\n   }\n   Висновок  Цей проєкт демонструє основи створення функціонального калькулятора. Його можна покращити, використовуючи архітектурні підходи (MVVM) або додати більш складні операції.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":227,"path":228,"dir":192,"title":229,"description":230,"keywords":231,"body":232},"content:1.android:2.lesson2:5.toast.md","/android/lesson2/toast","Спливаючі вікна. Toast","Для створення простих повідомлень в Android використовується клас Toast. Фактично Toast представляє спливаюче вікно з деяким текстом, яке відображається протягом деякого часу.",[],"  Спливаючі вікна. Toast  Для створення простих повідомлень в Android використовується клас   Toast . Фактично   Toast  представляє спливаюче вікно з деяким текстом, яке відображається протягом деякого часу.  Об'єкт   Toast  не можна створити в коді розмітки xml, наприклад, у файл   activity_main.xml . Toast можна використовувати тільки в коді java.  Так, визначимо у файлі розмітки   activity_main.xml  кнопку:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"  >\n    \n       \u003C  Button\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Click\"\n           android:onClick  =  \"onClick\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  У кнопки встановлено обробник натискання - метод   onClick . Визначимо його в коді   MainActivity :     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.Toast  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n    \n           setContentView  (R.layout.activity_main);\n       }\n    \n       public    void   onClick  (  View   view  ){\n           Toast   toast   =   Toast.  makeText  (  this  ,   \"Hello Android!\"  ,Toast.LENGTH_LONG);\n           toast.  show  ();\n       }\n   }\n  В обробнику відображається спливаюче вікно. Для його створення застосовується метод   Toast.makeText() , до якого передається три параметри: поточний контекст (поточний об'єкт   activity ), текст, що відображається, і час відпрацювання вікна.  Як час показу вікна ми можемо використовувати цілочисельне значення - кількість мілісекунд або вбудовані константи   Toast.LENGTH_LONG  (3500 мілісекунд) і   Toast.LENGTH_SHORT  (2000 мілісекунд).  Для самого відображення вікна викликається метод   show() :\n  \nЗа замовчуванням вікно відображається внизу інтерфейсу з центруванням по центру. Але ми можемо кастомізувати позиціонування вікна за допомогою методів   setGravity()  і   setMargin() . Так, змінимо метод   onClick :     public    void   onClick  (  View   view) {\n       Toast   toast   =   Toast.  makeText  (  this  ,   \"Hello Android!\"  , Toast.LENGTH_LONG);\n       toast.  setGravity  (Gravity.TOP,   0  ,  160  );     // import android.view.Gravity;\n       toast.  show  ();\n   }\n  Перший параметр методу   setGravity  вказує, в якій частині контейнера треба позиціонувати   Toast , другий і третій параметр встановлюють відступи від цієї позиції по горизонталі і вертикалі відповідно:\n  \nМетод   setMargin()  приймає два параметри: відступ від лівої межі контейнера у відсотках від ширини контейнера і відступ від верхньої межі у відсотках від довжини контейнера.    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":234,"path":235,"dir":192,"title":236,"description":237,"keywords":238,"body":240},"content:1.android:2.lesson2:6.snackbar.md","/android/lesson2/snackbar","Snackbar","Елемент Snackbar до певної міри схожий на Toast: він також дає змогу виводити спливаючі повідомлення, але тепер повідомлення розтягуються по ширині екрана.",[239],"Прикріплення обробника події","  Snackbar  Елемент   Snackbar  до певної міри схожий на   Toast : він також дає змогу виводити спливаючі повідомлення, але тепер повідомлення розтягуються по ширині екрана.  Для застосування   Snackbar  додамо у файл   activity_main.xml  визначення кнопки, після натискання на яку з'являтиметься   Snackbar :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"  >\n    \n       \u003C  Button\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Click\"\n           android:onClick  =  \"onClick\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Тут визначено кнопку, після натискання на яку буде відображатися повідомлення.  І також змінимо клас   MainActivity :     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n    \n   import   com.google.android.material.snackbar.Snackbar  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n    \n       public    void   onClick  (  View   view  ){\n           Snackbar.  make  (view,   \"Hello Android\"  , Snackbar.LENGTH_LONG)\n                   .  show  ();\n       }\n   }\n   Snackbar  створюється за допомогою методу   make() , у який передаються три параметри:    Об'єкт   View , до якого прикріплюється спливаюче повідомлення.   Саме повідомлення  у вигляді рядка.   Параметр , який вказує, скільки часу буде відображатися повідомлення.  Останній параметр може приймати числове значення (кількість мілісекунд) або одну з трьох констант:    Snackbar.LENGTH_INDEFINITE  — відображення протягом невизначеного періоду часу.   Snackbar.LENGTH_LONG  — тривале відображення.   Snackbar.LENGTH_SHORT  — нетривале відображення.  Після створення   Snackbar  відображається за допомогою методу   show .\n  \nПри цьому, на відміну від   Toast , ми не можемо вплинути на позицію повідомлення, воно відображається внизу екрана і займає всю нижню частину.  Прикріплення обробника події   Snackbar  дає змогу додати віджету дію, щоб користувач міг якось прореагувати на повідомлення. Наприклад, змінимо код   MainActivity  таким чином:     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.Toast  ;\n    \n   import   com.google.android.material.snackbar.Snackbar  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n    \n       public    void   onClick  (  View   view  ){\n           Snackbar   snackbar   =   Snackbar.  make  (view,   \"Hello Android\"  , Snackbar.LENGTH_LONG);\n            \n           snackbar.  setAction  (  \"Next...\"  ,   new   View.  OnClickListener   (){\n               @  Override\n               public   void   onClick  (  View   v) {\n                   Toast   toast   =   Toast.  makeText  (  getApplicationContext  (),   \"Next clicked!\"  ,Toast.LENGTH_LONG);\n                   toast.  show  ();\n               }\n           });\n           snackbar.  show  ();\n       }\n   }\n  Для додавання дії у   Snackbar  використовується метод   setAction() .    Перший параметр  представляє текст кнопки у повідомленні, на яку може натиснути користувач (у цьому випадку це   \"Next...\" ).   Другий параметр  представляє реалізацію інтерфейсу   View.OnClickListener  (того самого, який використовується для обробки натискання кнопки).  У методі   onClick()  виконуються дії, які викликаються при натисканні на кнопку у повідомленні. У цьому прикладі для простоти відображається спливаюче повідомлення у вигляді об'єкта   Toast .    Налаштування візуального вигляду  Ряд методів   Snackbar  дозволяє налаштувати зовнішній вигляд:     setTextColor() : налаштовує колір тексту.    setBackgroundTint() : налаштовує колір фону.    setActionTextColor() : налаштовує колір тексту кнопки у спливаючому повідомленні.     snackbar.  setTextColor  (  0XFF81C784  );\n   snackbar.  setBackgroundTint  (  0XFF555555  );\n   snackbar.  setActionTextColor  (  0XFF0277BD  );\n      html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":242,"path":243,"dir":192,"title":244,"description":245,"keywords":246,"body":248},"content:1.android:2.lesson2:7.checkbox.md","/android/lesson2/checkbox","Checkbox","Елементи Checkbox являють собою прапорці, які можуть перебувати в поміченому і не поміченому стані. Прапорці дають змогу робити множинний вибір із кількох значень. Отже, визначимо у файлі розмітки activity_main.xml елемент CheckBox:",[247],"OnCheckedChangeListener","  Checkbox  Елементи   Checkbox  являють собою прапорці, які можуть перебувати в поміченому і не поміченому стані. Прапорці дають змогу робити множинний вибір із кількох значень. Отже, визначимо у файлі розмітки   activity_main.xml  елемент   CheckBox :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"  >\n    \n       \u003C  TextView   android:id  =  \"@+id/selection\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"26sp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  />\n    \n       \u003C  CheckBox   android:id  =  \"@+id/enabled\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Включить\"\n           android:textSize  =  \"26sp\"\n    \n           android:onClick  =  \"onCheckboxClicked\"\n    \n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/selection\"  />\n    \n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Атрибут   android:onClick , як і у випадку з простими кнопками, дає змогу задати обробник натискання на прапорець. Визначимо обробник натискання в коді   MainActivity :     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.CheckBox  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n    \n       public   void   onCheckboxClicked  (  View   view  ) {\n           // Отримуємо прапорець\n           CheckBox   checkBox   =   (CheckBox) view;\n           TextView   selection   =   findViewById  (R.id.selection);\n           // Отримуємо, чи відмічений цей прапорець\n           if  (checkBox.  isChecked  ()) {\n               selection.  setText  (  \"Включено\"  );\n               checkBox.  setText  (  \"Выключить\"  );\n           }\n           else   {\n               selection.  setText  (  \"Выключено\"  );\n               checkBox.  setText  (  \"Включить\"  );\n           }\n       }\n   }\n  Як параметр в обробник натискання   onCheckboxClicked  передається натиснутий прапорець. Обробник спрацьовує при кожному натисканні на   checkBox . Тобто і коли ми встановлюємо прапорець, і коли ми знімемо позначку. За допомогою методу   isChecked()  можна дізнатися, чи виділений прапорець - у цьому разі метод повертає   true .   \nПодібним чином можна використовувати кілька прапорців:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"  >\n    \n       \u003C  TextView   android:id  =  \"@+id/selection\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"26sp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  />\n    \n       \u003C  CheckBox   android:id  =  \"@+id/java\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Java\"\n           android:textSize  =  \"26sp\"\n    \n           android:onClick  =  \"onCheckboxClicked\"\n    \n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/selection\"  />\n    \n       \u003C  CheckBox   android:id  =  \"@+id/kotlin\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Kotlin\"\n           android:textSize  =  \"26sp\"\n    \n           android:onClick  =  \"onCheckboxClicked\"\n    \n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/java\"  />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  На кожен прапорець можна повісити свій обробник натискання. А можна зробити один, як у цьому випадку. У цьому випадку ми можемо обробити кілька прапорців у коді java за допомогою конструкції   switch...case     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.CheckBox  ;\n   import   android.widget.TextView  ;\n   import   android.widget.Toast  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n    \n       public   void   onCheckboxClicked  (  View   view  ) {\n           // Отримуємо прапорець\n           CheckBox   checkBox   =   (CheckBox) view;\n           // Отримуємо, чи відмічений цей прапорець\n           boolean   checked   =   checkBox.  isChecked  ();\n    \n           TextView   selection   =   findViewById  (R.id.selection);\n    \n            // Дивимося, який саме з прапорців відзначений\n           switch  (view.  getId  ()) {\n               case   R.id.java  :\n                   if   (checked)\n                       Toast.  makeText  (  this  ,   \"Вы выбрали Java \"  ,Toast.LENGTH_LONG).  show  ();\n                   break  ;\n               case   R.id.kotlin  :\n                   if   (checked)\n                       Toast.  makeText  (  this  ,   \"Вы выбрали Kotlin\"  ,Toast.LENGTH_LONG).  show  ();\n                   break  ;\n               default:\n                   selection.  setText  (  \"\"  );\n           }\n       }\n   }\n  За допомогою конструкції   switch...case  можна отримати   id  натиснутого прапорця і виконати відповідні дії.\n   Щоправда, якщо нам просто треба взяти текст з обраного прапорця, то необов'язково в цьому разі використовувати конструкцію   switch , адже ми можемо скоротити весь код таким чином:     public   void   onCheckboxClicked  (  View   view) {\n       // Отримуємо прапорець\n       CheckBox   language   =   (CheckBox) view;\n       // Отримуємо, чи відмічений цей прапорець\n       TextView   selection   =   findViewById  (R.id.selection);\n       if  (language.  isChecked  ())\n           selection.  setText  (language.  getText  ());\n   }\n  Однак у цьому випадку залишається проблема: у текстовому полі відображається тільки один виділений елемент. Змінимо код   MainActivity , щоб відображати обидва виділені елементи:     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.CheckBox  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n    \n       public   void   onCheckboxClicked  (  View   view  ) {\n    \n           // Отримуємо прапорці\n           CheckBox   java   =   findViewById  (R.id.java);\n           CheckBox   kotlin   =   findViewById  (R.id.kotlin);\n           String   selectedItems   =   \"\"  ;\n           if  (java.  isChecked  ())\n               selectedItems   +=  java.  getText  ()   +   \" \"  ;\n           if  (kotlin.  isChecked  ())\n               selectedItems   +=  kotlin.  getText  ();\n    \n           TextView   selection   =   findViewById  (R.id.selection);\n           selection.  setText  (selectedItems);\n       }\n   }\n    OnCheckedChangeListener  Застосування слухача   OnCheckedChangeListener  представляє альтернативний спосіб відстеження зміни прапорця. Цей слухач спрацьовує, коли ми встановлюємо або прибираємо позначку на прапорці. Наприклад, визначимо наступний   checkbox :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"  >\n    \n       \u003C  TextView   android:id  =  \"@+id/selection\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"26sp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  />\n    \n       \u003C  CheckBox   android:id  =  \"@+id/enabled\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Включить\"\n           android:textSize  =  \"26sp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/selection\"  />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  У коді   MainActivity  підключимо обробник зміни стану:     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n   import   android.widget.CheckBox  ;\n   import   android.widget.CompoundButton  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           TextView   selection   =   findViewById  (R.id.selection);\n           CheckBox   enableBox   =   findViewById  (R.id.enabled);\n    \n           enableBox.  setOnCheckedChangeListener  (  new   CompoundButton.  OnCheckedChangeListener  () {\n               public   void   onCheckedChanged  (  CompoundButton   buttonView,   boolean   isChecked) {\n    \n                   if  (isChecked) {\n                       selection.  setText  (  \"Включено\"  );\n                       buttonView.  setText  (  \"Выключить\"  );\n                   }\n                   else   {\n                       selection.  setText  (  \"Выключено\"  );\n                       buttonView.  setText  (  \"Включить\"  );\n                   }\n               }\n           });\n       }\n   }\n  Слухач   OnCheckedChangeListener  визначений у базовому класі   CompoundButton  і містить один метод —   onCheckedChanged .    Перший параметр  цього методу,   buttonView , — це сам змінений прапорець   CheckBox .   Другий параметр ,   isChecked , вказує, чи встановлено прапорець.  При зміні стану прапорця буде виводитися у спливаючому вікні відповідне повідомлення.      html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":250,"path":251,"dir":192,"title":252,"description":253,"keywords":254,"body":255},"content:1.android:2.lesson2:8.toggle-button.md","/android/lesson2/toggle-button","ToggleButton","Елемент ToggleButton, подібно до CheckBox, може перебувати у двох станах: відміченому та невідміченому. Для кожного стану можна окремо встановити свій текст.",[],"  ToggleButton  Елемент   ToggleButton , подібно до   CheckBox , може перебувати у двох станах: відміченому та невідміченому. Для кожного стану можна окремо встановити свій текст.  Наприклад, визначимо наступний елемент   ToggleButton :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"  >\n    \n       \u003C  ToggleButton\n           android:id  =  \"@+id/toggle\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:textOn  =  \"Включено\"\n           android:textOff  =  \"Выключено\"\n           android:onClick  =  \"onToggleClicked\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Атрибути   android:textOn  та   android:textOff  задають текст кнопки в відміченому та не відміченому стані відповідно. Так само, як і для інших кнопок, можна обробити натискання на елемент за допомогою події   onClick .  В цьому випадку визначимо в класі   Activity  обробник події:     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.Toast  ;\n   import   android.widget.ToggleButton  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n       public   void   onToggleClicked  (  View   view  ) {\n    \n           // включена ли кнопка\n           boolean   on   =   ((ToggleButton) view).  isChecked  ();\n           if   (on) {\n               // действия если включена\n               Toast.  makeText  (  this  ,   \"Свет включен\"  , Toast.LENGTH_LONG).  show  ();\n           }   else   {\n               // действия, если выключена\n               Toast.  makeText  (  this  ,   \"Свет выключен!\"  , Toast.LENGTH_LONG).  show  ();\n           }\n       }\n   }\n    Створення елемента   ToggleButton  у коді java:     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   androidx.constraintlayout.widget.ConstraintLayout  ;\n    \n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.Toast  ;\n   import   android.widget.ToggleButton  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           //setContentView(R.layout.activity_main);\n           ConstraintLayout   layout   =   new   ConstraintLayout  (  this  );\n           ConstraintLayout  .  LayoutParams   layoutParams   =   new   ConstraintLayout  .  LayoutParams\n                   (ConstraintLayout.LayoutParams.WRAP_CONTENT, ConstraintLayout.LayoutParams.WRAP_CONTENT);\n           ToggleButton   toggleButton   =   new   ToggleButton  (  this  );\n           toggleButton.  setTextOff  (  \"Выключено\"  );\n           toggleButton.  setTextOn  (  \"Включено\"  );\n           toggleButton.  setText  (  \"Выключено\"  );\n           toggleButton.  setOnClickListener  (  new   View.  OnClickListener  () {\n               @  Override\n               public   void   onClick  (  View   view) {\n                   boolean   on   =   ((ToggleButton) view).  isChecked  ();\n    \n                   if   (on) {\n                       Toast.  makeText  (  getApplicationContext  (),   \"Свет включен\"  , Toast.LENGTH_LONG).  show  ();\n                   }   else   {\n                       Toast.  makeText  (  getApplicationContext  (),   \"Свет выключен!\"  , Toast.LENGTH_LONG).  show  ();\n                   }\n               }\n           });\n           layoutParams.leftToLeft   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           layoutParams.topToTop   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           layout.  addView  (toggleButton);\n           setContentView  (layout);\n       }\n   }\n    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":257,"path":258,"dir":192,"title":259,"description":260,"keywords":261,"body":262},"content:1.android:2.lesson2:9.radio-button.md","/android/lesson2/radio-button","RaddioButton","Схожу функціональність з прапорцями надають перемикачі, які представлені класом RadioButton. Але на відміну від прапорців, одночасно в групі перемикачів можна вибрати тільки один перемикач.",[247],"  RaddioButton  Схожу функціональність з прапорцями надають перемикачі, які представлені класом   RadioButton . Але на відміну від прапорців, одночасно в групі перемикачів можна вибрати тільки один перемикач.  Щоб створити список перемикачів для вибору, спочатку треба створити об'єкт   RadioGroup , який включатиме в себе всі перемикачі:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"  >\n    \n      \u003C  TextView   android:id  =  \"@+id/selection\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"26sp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  />\n    \n       \u003C  RadioGroup\n           android:id  =  \"@+id/radios\"\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"wrap_content\"\n           android:orientation  =  \"vertical\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/selection\"\n           >\n    \n           \u003C  RadioButton   android:id  =  \"@+id/java\"\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"Java\"   />\n           \u003C  RadioButton   android:id  =  \"@+id/kotlin\"\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"Kotlin\"   />\n       \u003C/  RadioGroup  >\n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Оскільки клас   RadioGroup  є похідним від   LinearLayout , ми також можемо задати вертикальну або горизонтальну орієнтацію списку. При цьому в нього можна включити не тільки самі перемикачі, а й інші об'єкти, наприклад, кнопку або   TextView .  У класі   MainActivity  визначимо обробку вибору перемикачів:     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.RadioButton  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n       TextView   selection;\n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           selection   =   findViewById  (R.id.selection);\n           // устанавливаем обработчики для кнопок\n           findViewById  (R.id.java).  setOnClickListener  ((view)  ->  onRadioButtonClicked  (view));\n           // устанавливаем обработчики для кнопок\n           findViewById  (R.id.kotlin).  setOnClickListener  ((view)  ->  onRadioButtonClicked  (view));\n       }\n       public   void   onRadioButtonClicked  (  View   view  ) {\n           RadioButton   radio   =   (RadioButton) view;\n           // если переключатель отмечен\n           boolean   checked   =   radio.  isChecked  ();\n           // получаем текст нажатой радиокнопки\n           String   text   =   radio.  getText  ().  toString  ();\n           // Получаем нажатый переключатель\n           switch  (text) {\n               case   \"Java\"  :\n                   if   (checked) selection.  setText  (  \"Выбрана Java\"  );\n                   break  ;\n               case   \"Kotlin\"  :\n                   if   (checked) selection.  setText  (  \"Выбран Kotlin\"  );\n                   break  ;\n           }\n       }\n   }\n    OnCheckedChangeListener  Окрім обробки натискання на кожен окремий перемикач, ми можемо в цілому повісити на весь   RadioGroup  з його перемикачами слухача   OnCheckedChangeListener  і обробляти натискання в ньому. Для цього заберемо з розмітки у елемента   RadioGroup  визначення   id :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"  >\n    \n      \u003C  TextView   android:id  =  \"@+id/selection\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"26sp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  />\n    \n       \u003C  RadioGroup\n           android:id  =  \"@+id/radios\"\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"wrap_content\"\n           android:orientation  =  \"vertical\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/selection\"  >\n           \u003C  RadioButton   android:id  =  \"@+id/java\"\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"Java\"   />\n           \u003C  RadioButton   android:id  =  \"@+id/kotlin\"\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"Kotlin\"   />\n       \u003C/  RadioGroup  >\n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Далі в коді   MainActivity  повісимо на об'єкт   RadioGroup  слухач   OnCheckedChangeListener :     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n   import   android.widget.RadioButton  ;\n   import   android.widget.RadioGroup  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n       TextView   selection;\n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           selection   =   findViewById  (R.id.selection);\n           // отримуємо об'єкт RadioGroup\n           RadioGroup   radios   =   findViewById  (R.id.radios);\n           // обробка перемикання стану перемикача\n           radios.  setOnCheckedChangeListener  ((radiogroup, id)  ->   {\n    \n               // отримує обрану кнопку\n               RadioButton   radio   =   findViewById  (id);\n               switch   (radio.  getText  ().  toString  ()) {\n                   case   \"Java\"  :\n                       selection.  setText  (  \"Выбрана Java\"  );\n                       break  ;\n                   case   \"Kotlin\"  :\n                       selection.  setText  (  \"Выбран Kotlin\"  );\n                       break  ;\n                   default:\n                       break  ;\n               }\n           });\n       }\n   }\n  Слухач   RadioGroup.OnCheckedChangeListener  визначає метод   onCheckedChanged() , в який передається об'єкт   RadioGroup  та   id  виділеного перемикача. Далі ми також можемо отримати за допомогою   id  вибрану радіокнопку і виконати певну обробку.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":264,"path":265,"dir":192,"title":266,"description":267,"keywords":268,"body":269},"content:1.android:2.lesson2:10.date-picker.md","/android/lesson2/date-picker","DatePicker","DatePicker представляє елемент для вибору дати. Серед його атрибутів можна відзначити наступні:",[],"  DatePicker   DatePicker  представляє елемент для вибору дати. Серед його атрибутів можна відзначити наступні:    android:calendarTextColor : колір тексту календаря   android:calendarViewShown : вказує, чи буде відображатися вигляд календаря   android:datePickerMode : встановлює режим вибору дати   android:dayOfWeekBackground : встановлює фоновий колір панелі вибору дня тижня   android:endYear : встановлює останній відображений рік   android:firstDayOfWeek : встановлює перший день тижня   android:headerBackground : встановлює фоновий колір для панелі вибраної дати   android:maxDate : встановлює максимальну відображену дату у форматі mm/dd/yyyy   android:minDate : встановлює мінімальну відображену дату у форматі mm/dd/yyyy   android:spinnersShown : вказує, чи буде відображатися спінер в віджеті   android:startYear : встановлює початково відображуваний рік   android:yearListSelectorColor : встановлює колір для поля вибору року  Серед методів   DatePicker  можна відзначити наступні:    int getDayOfMonth() : повертає номер вибраного дня   int getMonth() : повертає номер вибраного місяця (від 0 до 11)   int getYear() : повертає номер вибраного року   void init(int year, int monthOfYear, int dayOfMonth, DatePicker.OnDateChangedListener onDateChangedListener) : встановлює початкову дату. Останній параметр встановлює слухача зміни вибраної дати   void setOnDateChangedListener(DatePicker.OnDateChangedListener onDateChangedListener) : встановлює слухача зміни вибраної дати   void setFirstDayOfWeek(int firstDayOfWeek) : встановлює перший день тижня   void updateDate(int year, int month, int dayOfMonth) : програмно оновлює вибрану дату  Нехай у   activity_main.xml  визначений елемент   DatePicker :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"  >\n    \n       \u003C  TextView   android:id  =  \"@+id/dateTextView\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"26sp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n       \u003C  DatePicker   android:id  =  \"@+id/datePicker\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/dateTextView\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Застосуємо деякі методи   DatePicker  для управління його поведінкою:     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n   import   android.widget.DatePicker  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           TextView   dateTextView   =   findViewById  (R.id.dateTextView);\n           DatePicker   datePicker   =   this  .  findViewById  (R.id.datePicker);\n    \n           // Місяць починаючи з нуля. Для відображення додаємо 1.\n           datePicker.  gradlet  (  2020  ,   02  ,   01  ,   new   DatePicker.  OnDateChangedListener  () {\n               @  Override\n               public   void   onDateChanged  (  DatePicker   view,   int   year,   int   monthOfYear,   int   dayOfMonth) {\n    \n                   // Відлік місяців починається з нуля. Для відображення додаємо 1.\n                   dateTextView.  setText  (  \"Дата: \"   +   view.  getDayOfMonth  ()   +   \"/\"   +\n                           (view.  getMonth  ()   +   1  )   +   \"/\"   +   view.  getYear  ());\n                            \n                   // альтернативний запис\n                   // dateTextView.setText(\"Дата: \" + dayOfMonth + \"/\" + (monthOfYear + 1) + \"/\" + year);\n               }\n           });\n       }\n   }\n  Використовуючи метод   datePicker.gradlet(); , встановлюємо дату за замовчуванням — 1 березня 2020 року, оскільки відлік місяців починається з нуля. Крім того, за допомогою останнього параметра — об'єкта   DatePicker.OnDateChangedListener , встановлюється обробка вибору дати.  Кожного разу, коли користувач буде вибирати дату, викликатиметься метод   onDateChanged()  об'єкта   DatePicker.OnDateChangedListener . Цей метод приймає чотири параметри:    view : елемент   DatePicker ;   year : вибраний рік;   monthOfYear : вибраний місяць;   dayOfMonth : вибраний день.  Далі ми можемо отримати вибрані день, місяць і рік. Причому можна використовувати як параметри методу   onDateChanged , так і методи самого   DatePicker .  Початковий стан перед вибором — встановлена дата 1 березня 2020 року.\n  \nВибір довільної дати (20 травня 2020 року):\n    DatePicker  за замовчуванням відображається в режимі календаря, але ми можемо використовувати додати інший режим -   спіннер  за допомогою атрибута   android:datePickerMode :     \u003C  DatePicker   android:id  =  \"@+id/datePicker\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:datePickerMode  =  \"spinner\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/dateTextView\"   />\n   \nУ цьому випадку спіннер відображається зліва від календаря. Якщо ми зовсім не хочемо відображати календаря, то можна встановити атрибут   android:calendarViewShown=\"false\"     \u003C  DatePicker   android:id  =  \"@+id/datePicker\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:datePickerMode  =  \"spinner\"\n           android:calendarViewShown  =  \"false\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/dateTextView\"   />\n      html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":271,"path":272,"dir":192,"title":273,"description":274,"keywords":275,"body":280},"content:1.android:2.lesson2:11.time-picker.md","/android/lesson2/time-picker","TimePicker","TimePicker представляє віджет для вибору часу, який може відображати час або в 24-годинному, або в 12-годинному форматі.",[276,277,278,279],"Атрибути TimePicker:","Основні методи TimePicker:","Визначення TimePicker у activity_main.xml:","Додавання слухача змін у TimePicker","  TimePicker  TimePicker представляє віджет для вибору часу, який може відображати час або в 24-годинному, або в 12-годинному форматі.  Атрибути TimePicker:    timePickerMode : дозволяє встановити режим відображення і може приймати значення:\n    clock  — відображення у вигляді годинника;   spinner  — відображення у вигляді спіннера.  Основні методи TimePicker:    int getHour() : повертає годину (в 24-годинному форматі).   int getMinute() : повертає хвилини.   boolean is24HourView() : повертає   true , якщо використовується 24-годинний формат.   void setHour(int hour) : встановлює годину для   TimePicker .   void setIs24HourView(Boolean is24HourView) : встановлює 24-годинний формат.   void setMinute(int minute) : встановлює хвилини.   void setOnTimeChangedListener(TimePicker.OnTimeChangedListener onTimeChangedListener) : встановлює слухач зміни часу у   TimePicker  у вигляді об'єкта   TimePicker.OnTimeChangedListener .  Визначення TimePicker у   activity_main.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"  >\n    \n       \u003C  TextView   android:id  =  \"@+id/timeTextView\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"26sp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n       \u003C  TimePicker   android:id  =  \"@+id/timePicker\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n    \n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/timeTextView\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Застосуємо деякі методи   TimePicker  для управління його поведінкою:     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n   import   android.widget.TextView  ;\n   import   android.widget.TimePicker  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           TextView   timeTextView   =   findViewById  (R.id.timeTextView);\n           TimePicker   timePicker   =   findViewById  (R.id.timePicker);\n    \n           timePicker.  setOnTimeChangedListener  (  new   TimePicker.  OnTimeChangedListener  () {\n               @  Override\n               public   void   onTimeChanged  (  TimePicker   view,   int   hourOfDay,   int   minute) {\n    \n                   timeTextView.  setText  (  \"Время: \"   +   hourOfDay   +   \":\"   +   minute);\n                   // або так\n                   // timeTextView.setText(\"Время: \" + view.getHour() + \":\" + view.getMinute());\n               }\n            });\n       }\n   }\n  Додавання слухача змін у TimePicker  Для додавання слухача змін у   TimePicker  використовується метод   setOnTimeChangedListener() , до якого передається об'єкт   TimePicker.OnTimeChangedListener . Він має єдиний метод —   onTimeChanged() , який викликається щоразу при зміні часу в   TimePicker .  Цей метод приймає три параметри:    TimePicker  — сам елемент часу,   hourOfDay  — вибрані години,   minute  — вибрані хвилини.  У цьому випадку обране значення часу передається в   TextView .\n  \nЗа замовчуванням   TimePicker  відображається в режимі   \"clock\"  або   годинник . Застосуємо режим   \"spinner\" :     \u003C  TimePicker   android:id  =  \"@+id/timePicker\"\n       android:layout_width  =  \"wrap_content\"\n       android:layout_height  =  \"wrap_content\"\n       android:timePickerMode  =  \"spinner\"\n       app:layout_constraintLeft_toLeftOf  =  \"parent\"\n       app:layout_constraintTop_toBottomOf  =  \"@+id/timeTextView\"   />\n    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":282,"path":283,"dir":192,"title":284,"description":285,"keywords":286,"body":287},"content:1.android:2.lesson2:12.seekbar.md","/android/lesson2/seekbar","Ползунок SeekBar","Елемент SeekBar виконує роль повзунка, тобто шкалу поділок, на якій ми можемо змінювати поточну позначку.",[],"  Ползунок SeekBar  Елемент   SeekBar  виконує роль повзунка, тобто шкалу поділок, на якій ми можемо змінювати поточну позначку.  Серед його атрибутів можна відзначити такі:     android:max : встановлює максимальне значення.    android:min : встановлює мінімальне значення.    android:progress : встановлює поточне значення, яке знаходиться в діапазоні між мінімальним і максимальним.  Серед методів SeekBar можна виділити наступні:     void setProgress(int progress) : встановлює поточне значення ползунка.    void setMin(int min) : встановлює мінімальне значення.    void setMax(int max) : встановлює максимальне значення.    void incrementProgressBy(int diff) : збільшує поточне значення на   diff .    int getMax() : повертає максимальне значення.    int getMin() : повертає мінімальне значення.    int getProgress() : повертає поточне значення.    void setOnSeekBarChangeListener(SeekBar.OnSeekBarChangeListener l) : встановлює слухача зміни значення в   SeekBar .  Визначимо   SeekBar  у розмітці   layout :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"  >\n    \n       \u003C  SeekBar\n           android:id  =  \"@+id/seekBar\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:progress  =  \"20\"\n           android:max  =  \"50\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Атрибут   android:progress  задає число 20 в якості поточного значення повзунка, а атрибут   android:max  — максимально можливе значення — число 50. В результаті ми отримаємо наступний елемент:\n   Тепер використовуємо метод   setOnSeekBarChangeListener() , який дозволяє встановити обробники подій зміни значення повзунка. Так, визначимо в файлі   layout  наступний код:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"  >\n    \n       \u003C  TextView   android:id  =  \"@+id/seekBarValue\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"26sp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n       \u003C  SeekBar\n           android:id  =  \"@+id/seekBar\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:progress  =  \"20\"\n           android:max  =  \"50\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/seekBarValue\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Тут визначено елемент   TextView , який виводитиме поточне значення повзунка під час його зміни.\nІ змінимо код   MainActivity :     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n   import   android.widget.SeekBar  ;\n   import   android.widget.TextView  ;\n   import   android.widget.TimePicker  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           SeekBar   seekBar   =   findViewById  (R.id.seekBar);\n           TextView   textView   =   findViewById  (R.id.seekBarValue);\n           seekBar.  setOnSeekBarChangeListener  (  new   SeekBar.  OnSeekBarChangeListener  () {\n               @  Override\n               public   void   onProgressChanged  (  SeekBar   seekBar,   int   progress,   boolean   fromUser) {\n    \n                   textView.  setText  (String.  valueOf  (progress));\n               }\n    \n               @  Override\n               public   void   onStartTrackingTouch  (  SeekBar   seekBar) {\n    \n               }\n    \n               @  Override\n               public   void   onStopTrackingTouch  (  SeekBar   seekBar) {\n    \n               }\n           });\n       }\n   }\n  У методі   setOnSeekBarChangeListener()  передається об'єкт   SeekBar.OnSeekBarChangeListener , який дозволяє встановити три методи-обробники:     onProgressChanged : викликається під час переміщення повзунка по шкалі. Переданий у метод параметр   progress  дозволяє отримати нове значення повзунка, яке в цьому випадку передається у   TextView  для відображення на екрані.    onStartTrackingTouch : викликається на початку переміщення повзунка по шкалі.    onStopTrackingTouch : викликається після завершення переміщення повзунка по шкалі.    Також ми можемо отримати поточне значення повзунка, використавши метод   getProgress() :     public   void   onProgressChanged  (  SeekBar   seekBar,   int   progress,   boolean   fromUser) {\n    \n       textView.  setText  (String.  valueOf  (seekBar.  getProgress  ()));\n   }\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":289,"path":290,"dir":192,"title":291,"description":292,"keywords":293,"body":295},"content:1.android:2.lesson2:13.resources.md","/android/lesson2/resources","Робота з ресурсами","Ресурс в застосунку Android представляє собою файл, наприклад, файл розмітки інтерфейсу або деяке значення, наприклад, простий рядок. Тобто ресурси можуть бути файлами розмітки, окремими рядками, звуковими файлами, файлами зображень тощо. Усі ресурси знаходяться в проєкті в каталозі res. Для різних типів ресурсів, визначених у проєкті, у каталозі res створюються підкаталоги. Підтримувані підкаталоги:",[294],"Використання ресурсів","  Робота з ресурсами  Ресурс в застосунку Android представляє собою файл, наприклад, файл розмітки інтерфейсу або деяке значення, наприклад, простий рядок. Тобто ресурси можуть бути файлами розмітки, окремими рядками, звуковими файлами, файлами зображень тощо. Усі ресурси знаходяться в проєкті в каталозі   res . Для різних типів ресурсів, визначених у проєкті, у каталозі   res  створюються підкаталоги. Підтримувані підкаталоги:    animator/ : XML-файли, які визначають анімацію властивостей.   anim/ : XML-файли, які визначають tween-анімацію.   color/ : XML-файли, які визначають список кольорів.   drawable/ : Графічні файли (  .png ,   .jpg ,   .gif ).   mipmap/ : Графічні файли, які використовуються для іконок застосунку під різні роздільні здатності екранів.   layout/ : XML-файли, які визначають інтерфейс користувача застосунку.   menu/ : XML-файли, які визначають меню застосунку.   raw/ : Різні файли, які зберігаються у вихідному вигляді.   values/ : XML-файли, які містять різні значення, що використовуються у застосунку, наприклад, ресурси рядків.   xml/ : Довільні XML-файли.   font/ : Файли із визначеннями шрифтів з розширеннями   .ttf ,   .otf  або   .ttc , або XML-файли, які містять елемент   \u003Cfont-family> .  Загалом ми можемо визначити такі типи ресурсів:      Ресурс   Каталог проекту   Файл   Елемент у файлі     Рядки   /res/values/   strings.xml   \u003Cstring>    Plurals   /res/values/   strings.xml   \u003Cplurals>    Масиви рядків   /res/values/   strings.xml  або   arrays.xml   \u003Cstring-array>    Логічні значення Boolean   /res/values/   bools.xml   \u003Cbool>    Кольори   /res/values/   colors.xml   \u003Ccolor>    Список кольорів   /res/color/  Довільна назва   \u003Cselector>    Розміри (Dimensions)   /res/values/   dimens.xml   \u003Cdimen>    Ідентифікатори ID   /res/values/   ids.xml   \u003Citem>    Цілі числа   /res/values/   integers.xml   \u003Cinteger>    Масив цілих чисел   /res/values/   integers.xml   \u003Cinteger-array>    Графічні файли   /res/drawable/  Файли з розширенням jpg або png  -    Tween-анімація   /res/anim/  XML-файл з довільною назвою   \u003Cset> ,   \u003Calpha> ,   \u003Crotate> ,   \u003Cscale> ,   \u003Ctranslate>    Покадрова анімація   /res/drawable/  XML-файл з довільною назвою   \u003Canimation-list>    Анімація властивостей   /res/animator/  XML-файл з довільною назвою   \u003Cset> ,   \u003CobjectAnimator> ,   \u003CvalueAnimator>    Меню   /res/menu/  XML-файл з довільною назвою   \u003Cmenu>    XML-файли   /res/xml/  XML-файл з довільною назвою  -    Бінарні та текстові ресурси   /res/raw/  Мультимедійні файли (mp3, mp4), текстові або інші файли  -    Розмітка графічного інтерфейсу   /res/layout/  XML-файл з довільною назвою  -    Стилі та теми   /res/values/   styles.xml ,   themes.xml   \u003Cstyle>  Наприклад, якщо ми візьмемо стандартний проєкт   Android Studio , який створюється за замовчуванням, то в ньому можна побачити наявність декількох папок для різних ресурсів у каталозі   res :\n   За замовчуванням у проєкті створюються каталоги не для всіх типів ресурсів, які можуть використовуватися в   Android . Проте, за потреби можна додати до папки   res  потрібний каталог, а в нього помістити необхідний ресурс.   Під час компіляції проєкту інформація про всі ресурси додається до спеціального файлу   R.jar , який потім використовується для роботи з ресурсами.  Використання ресурсів  Існує два способи доступу до ресурсів: у файлі вихідного коду та у файлі   xml .   Посилання на ресурси у коді  Тип ресурсу в такому записі посилається на одне із просторів (вкладених класів), визначених у файлі   R.java , які мають відповідні їм типи у   xml :    R.drawable  (відповідає типу   drawable  у   xml )   R.id  (  id )   R.layout  (  layout )   R.string  (  string )   R.attr  (  attr )   R.plural  (  plurals )   R.array  (  string-array )   Наприклад, для встановлення ресурсу   activity_main.xml  як графічного інтерфейсу в коді   MainActivity  у методі   onCreate()  використовується такий рядок:     setContentView  (R.layout.activity_main);\n  Через вираз   R.layout.activity_main  відбувається посилання на ресурс   activity_main.xml , де   layout  — тип ресурсу, а   activity_main  — ім'я ресурсу.   Посилання на інші ресурси  Аналогічно можна отримати доступ до інших ресурсів. Наприклад, у файлі   res/values/strings.xml  визначений ресурс   app_name :     \u003C  resources  >\n       \u003C  string   name  =  \"app_name\"  >ViewApp\u003C/  string  >\n   \u003C/  resources  >\n  Цей ресурс посилається на рядок. Щоб отримати доступ до цього ресурсу у коді Java, можна використовувати вираз   R.string.app_name .  Доступ у файлі xml  Часто виникає необхідність посилатися на ресурс у файлі   xml , наприклад, у файлі, який визначає візуальний інтерфейс, наприклад, у   activity_main.xml . Посилання на ресурси в   xml  файлах мають наступну формалізовану форму:   @[ім'я_пакета:]тип_ресурсу/ім'я_ресурсу    ім'я_пакета  — це ім'я пакета, в якому знаходиться ресурс (вказувати необов'язково, якщо ресурс знаходиться в тому ж пакеті).   тип_ресурсу  — це підклас, визначений у класі   R  для типу ресурсу.   ім'я_ресурсу  — ім'я файлу ресурсу без розширення або значення атрибута   android:name  в XML-елементі (для простих значень).   Наприклад, ми хочемо вивести в елемент   TextView  рядок, який визначений як ресурс у файлі   strings.xml :     \u003C  TextView\n       android:id  =  \"@+id/textView\"\n       android:layout_width  =  \"wrap_content\"\n       android:layout_height  =  \"wrap_content\"\n       android:text  =  \"@string/app_name\"   />\n  В цьому випадку властивість   text  отримає значення рядкового ресурсу   app_name .   Метод getResources  Для отримання ресурсів у класі   Activity  ми можемо використовувати метод   getResources() , який повертає об'єкт   android.content.res.Resources . Але щоб отримати сам ресурс, нам потрібно у отриманого об'єкта   Resources  викликати один із методів. Декілька з його методів:    getString() : повертає рядок з файлу   strings.xml  за числовим ідентифікатором.   getDimension() : повертає числове значення — ресурс   dimen .   getDrawable() : повертає графічний файл у вигляді об'єкта   Drawable .   getBoolean() : повертає значення   boolean .   getColor() : повертає визначення кольору.   getColorStateList() : повертає об'єкт   ColorStateList  — набір кольорів.   getFont() : повертає визначення шрифта у вигляді об'єкта   Typeface .   getFloat() : повертає значення   float .   getLayout() : повертає об'єкт   XmlResourceParser , пов'язаний з файлом   layout .  Це лише деякі методи. Але всі вони як параметр приймають ідентифікатор ресурсу, який потрібно отримати. Коротко розглянемо їх застосування. Візьмемо той самий файл   res/values/strings.xml  як джерело ресурсів, який у моєму випадку виглядає так:     \u003C  resources  >\n       \u003C  string   name  =  \"app_name\"  >ViewApp\u003C/  string  >\n   \u003C/  resources  >\n  І змінимо код   MainActivity :     package   com.example.viewapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   \n   import   android.os.Bundle  ;\n   import   android.widget.TextView  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           //setContentView(R.layout.activity_main);\n           // отримання ресурсів з файлу values/strings.xml\n           String   app_name   =   getResources  ().  getString  (R.string.app_name);\n   \n           TextView   textView   =   new   TextView  (  this  );\n           textView.  setTextSize  (  30  );\n           textView.  setText  (app_name);\n   \n           setContentView  (textView);\n       }\n   }\n  Тут, використовуючи метод   getResources() , ми отримуємо всі ресурси і потім використовуємо їх для встановлення значень властивостей графічних елементів. При запуску додатку ми побачимо застосування отриманих ресурсів.    Подібним чином ми можемо програмно отримувати й інші ресурси та використовувати їх у додатку. Однак варто зауважити, що в даному випадку нам не потрібно використовувати метод   getResources()  і взагалі виконувати якісь певні дії для отримання ресурсу, оскільки метод   setText()  класу   TextView  підтримує пряме встановлення тексту по ідентифікатору ресурсу:     textView.  setText  (R.string.app_name);\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":297,"path":298,"dir":192,"title":299,"description":300,"keywords":301,"body":304},"content:1.android:2.lesson2:14.string-resources.md","/android/lesson2/string-resources","Ресурси рядків","Ресурси рядків — один з важливих компонентів додатка. Ми використовуємо їх для виведення назви додатка, різного тексту, наприклад, тексту кнопок тощо.",[302,303],"Ресурси Plurals","string array","  Ресурси рядків  Ресурси рядків — один з важливих компонентів додатка. Ми використовуємо їх для виведення назви додатка, різного тексту, наприклад, тексту кнопок тощо.  XML-файли, що представляють собою ресурси рядків, знаходяться в проєкті в папці   res/values . За замовчуванням ресурси рядків знаходяться в файлі   strings.xml , який може виглядати наступним чином:     \u003C  resources  >\n       \u003C  string   name  =  \"app_name\"  >ViewApp\u003C/  string  >\n   \u003C/  resources  >\n    У найпростіший спосіб цей файл визначає один ресурс   \"app_name\" , який встановлює назву додатка, яку ми бачимо в заголовку додатка на екрані пристрою. Але, звісно, ми можемо визначити будь-які рядкові ресурси. Кожен окремий ресурс визначається за допомогою елемента   string , а його атрибут   name  містить назву ресурсу.  Потім в додатку в файлах коду ми можемо звертатися до цих ресурсів:     R.string.app_name\n  Наприклад, у коді Java:     String   application_name   =   getResources  ().  getString  (R.string.app_name);\n  Або в xml-файлі:     @string/app_name\n  Наприклад, змінімо файл   res/values/strings.xml  наступним чином:     \u003C  resources  >\n       \u003C  string   name  =  \"app_name\"  >ViewApp\u003C/  string  >\n       \u003C  string   name  =  \"message\"  >Hello Android!\u003C/  string  >\n   \u003C/  resources  >\n  Тут додано ресурс   message  зі значенням   \"Hello Android!\" .  Тепер використовуємо ресурс у файлі   activity_main.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n   \n       \u003C  TextView\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"@string/message\"\n           android:textSize  =  \"30sp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n   \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  За допомогою виразу   @string/message  передаємо атрибуту   android:text  значення з ресурсу.    Аналогічно ми могли б використовувати ресурс у коді   Activity :     package   com.example.viewapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   \n   import   android.os.Bundle  ;\n   import   android.widget.TextView  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n   \n           // отримуємо елемент textView\n           TextView   textView   =   findViewById  (R.id.textView);\n           // переустанавливаем у нього текст\n           textView.  setText  (R.string.message);\n       }\n   }\n  Якщо нам взагалі потрібно отримати ресурс у коді Java (не обов'язково для встановлення тексту в   TextView ), то в цьому випадку можна використовувати метод   getResources().getString(ідентифікатор_ресурсу) :     String   message   =   getResources  ().  getString  (R.string.message);\n  Хоча за замовчуванням для ресурсів рядків використовується файл   strings.xml , розробники можуть додавати додаткові файли ресурсів у каталог проекту   res/values . При цьому достатньо дотримуватися структури файлу: він повинен мати кореневий вузол   \u003Cresources>  та один або кілька елементів   \u003Cstring> .  Так, натискаємо на папку   res/values  правою кнопкою миші та в з'явившомуся списку вибираємо пункт   New -> Value Resource File :    Причому слід зазначити, що цей тип файлів буде характерний для будь-якого типу ресурсів, який додається в папку   res/values .  Після цього нам буде запропоновано визначити для файлу ім'я:\n   Назвемо, наприклад,   headers  (назва файлу довільна), а для всіх інших полів залишимо значення за замовчуванням. І в папку   res/values  буде додано новий файл   headers.xml . Визначимо в ньому пару ресурсів:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  resources  >\n       \u003C  string   name  =  \"welcome\"  >Добро пожаловать\u003C/  string  >\n       \u003C  string   name  =  \"click_button\"  >Нажмите на кнопку\u003C/  string  >\n   \u003C/  resources  >\n  І після цього ми зможемо використовувати визначені тут ресурси в коді   Activity  або в файлі   layout .  Форматування рядків\nAndroid дозволяє застосовувати форматування до ресурсів рядків. Наприклад, змінимо файл   strings.xml :     \u003C  resources  >\n       \u003C  string   name  =  \"app_name\"  >ViewApp\u003C/  string  >\n       \u003C  string   name  =  \"message\"  >Привіт, Android!\u003C/  string  >\n       \u003C  string   name  =  \"welcome_message\"  >Добро пожаловать %1$s! Уже %2$d : %3$d\u003C/  string  >\n   \u003C/  resources  >\n  Третій ресурс —   welcome_message  представляє рядок з форматуванням. Так, вона містить такі символи як   %1$s ,   %2$d  і   %3$d . Що вони означають?    %1$s  вказує, що це перший аргумент, а символ \"s\" означає, що цей аргумент є рядком.   %2$d  представляє другий аргумент, а символ \"d\" в кінці вказує, що це буде ціле число.  Аналогічно,   %3$d  вказує, що це третій аргумент, який також є цілим числом.  Отримуємо ресурс в коді Java:     package   com.example.viewapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   \n   import   android.content.res.Resources  ;\n   import   android.os.Bundle  ;\n   import   android.widget.TextView  ;\n   \n   import   java.util.Calendar  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           //setContentView(R.layout.activity_main);\n   \n           String   userName   =   \"Євген\"  ;\n           Calendar   calendar   =   Calendar.  getInstance  ();\n           int   hour   =   calendar.  get  (Calendar.HOUR_OF_DAY);\n           int   minute   =   calendar.  get  (Calendar.MINUTE);\n   \n           String   text   =   getString  (R.string.welcome_message, userName, hour, minute);\n           TextView   textView   =   new   TextView  (  this  );\n           textView.  setText  (text);\n           textView.  setTextSize  (  28  );\n           setContentView  (textView);\n       }\n   }\n  Метод   getString(R.string.welcome_message, userName, hour, minute)  отримує ресурс   welcome_message  і як наступні параметри передає його аргументам значення. Для першого аргументу-рядка використовується змінна   userName , а для другого і третього аргументів передаються поточні години і хвилини, отримані за допомогою класу   Calendar .    Ресурси Plurals   Plurals  (множинні ресурси) — це ще один тип наборів рядків, які призначені для опису кількості елементів. Це необхідно, наприклад, коли існує зміна закінчення іменника в залежності від числівника, з яким він вживається: 1 квітка, 2 квітки, 5 квіток. Для таких випадків і використовуються ресурси   plurals .  Розглянемо приклад. Додамо в папку   res/values  новий ресурс. Назвемо його   flowers :     \u003C  resources  >\n       \u003C  plurals   name  =  \"flowers\"  >\n           \u003C  item   quantity  =  \"one\"  >1 квітка\u003C/  item  >\n           \u003C  item   quantity  =  \"few\"  >2-4 квітки\u003C/  item  >\n           \u003C  item   quantity  =  \"many\"  >5 і більше квіток\u003C/  item  >\n       \u003C/  plurals  >\n   \u003C/  resources  >\n  В цьому прикладі ми визначили ресурс   flowers , який містить різні форми слова \"квітка\" в залежності від кількості.    quantity=\"one\"  — для числа 1.   quantity=\"few\"  — для чисел 2, 3 і 4.   quantity=\"many\"  — для чисел 5 і більше.  Тепер ми можемо використовувати цей ресурс у коді або в XML.    Змінимо його вміст наступним чином:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  resources  >\n       \u003C  plurals   name  =  \"flowers\"  >\n           \u003C  item   quantity  =  \"one\"  >%d квітка\u003C/  item  >\n           \u003C  item   quantity  =  \"few\"  >%d квітки\u003C/  item  >\n           \u003C  item   quantity  =  \"many\"  >%d квіток\u003C/  item  >\n       \u003C/  plurals  >\n   \u003C/  resources  >\n  Для визначення ресурсу використовується елемент   \u003Cplurals> , для якого є атрибут   name , що отримує значення, яке буде використовуватися для посилання на цей ресурс.  Самі набори рядків вводяться дочірніми елементами   \u003Citem> . Цей елемент має атрибут   quantity , який визначає, коли буде використовуватися відповідний рядок. Атрибут може мати наступні значення:    zero : рядок для кількості, рівної 0.   one : рядок для кількості, рівної 1 (для української мови — для всіх кількостей, що закінчуються на 1, крім 11).   two : рядок для кількості, рівної 2.   few : рядок для невеликої кількості.   many : рядок для великих кількостей.   other : всі інші випадки.  Зазначимо, що багато чого залежить від конкретної мови, і система автоматично визначає, яке значення брати для того чи іншого числа.  Використання цього ресурсу можливе тільки в коді Java. Тому змінюємо код   MainActivity :     package   com.example.viewapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   \n   import   android.os.Bundle  ;\n   import   android.widget.TextView  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           //setContentView(R.layout.activity_main);\n           String   rose   =   getResources  ().  getQuantityString  (R.plurals.flowers,   21  ,   21  );\n   \n           TextView   textView   =   new   TextView  (  this  );\n           textView.  setText  (rose);\n           textView.  setTextSize  (  26  );\n           setContentView  (textView);\n       }\n   }\n  За допомогою методу   getQuantityString  ми отримуємо значення ресурсу. Першим параметром передаємо ідентифікатор ресурсу. Другим параметром йде значення, для якого потрібно знайти відповідний рядок. Третій параметр представляє значення, яке буде вставлене на місце плейсхолдера   %d . Тобто ми отримуємо рядок для числа   21 .    string array  Ще одним видом строкових ресурсів є   string-array  або масив рядків. Наприклад, додамо в папку   res/values  новий файл, який назвемо   languages.xml :\n   Нехай він містить наступний код:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  resources  >\n       \u003C  string-array   name  =  \"languages\"  >\n           \u003C  item  >Java\u003C/  item  >\n           \u003C  item  >Kotlin\u003C/  item  >\n           \u003C  item  >Dart\u003C/  item  >\n       \u003C/  string-array  >\n   \u003C/  resources  >\n  Ресурс визначається за допомогою елемента   \u003Cstring-array> . Насправді він визначає набір рядків. Кожен окремий рядок задається за допомогою елемента   \u003Citem> .  У файлі   MainActivity.java  визначимо код для отримання значень з цього ресурсу:     package   com.example.viewapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   \n   import   android.content.res.Resources  ;\n   import   android.os.Bundle  ;\n   import   android.widget.TextView  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           //setContentView(R.layout.activity_main);\n           Resources   res   =   getResources  ();\n           String  [] languages   =   res.  getStringArray  (R.array.languages);\n           String   allLangs   =   \"\"  ;\n           for   (  String   lang  :   languages) {\n               allLangs   +=   lang   +   \" \"  ;\n           }\n           TextView   textView   =   new   TextView  (  this  );\n           textView.  setText  (allLangs);\n           textView.  setTextSize  (  28  );\n           setContentView  (textView);\n       }\n   }\n  За допомогою методу   getStringArray  отримуємо ресурс у вигляді масиву рядків, а потім за допомогою циклу складаємо з масиву один рядок і передаємо його в   TextView .    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":306,"path":307,"dir":192,"title":308,"description":309,"keywords":310,"body":311},"content:1.android:2.lesson2:15.dimension-resources.md","/android/lesson2/dimension-resources","Ресурси dimension","Визначення розмірів має відбуватися в папці res/values у файлі з будь-яким довільним іменем. Загальний синтаксис визначення ресурсу наступний:",[],"  Ресурси dimension  Визначення розмірів має відбуватися в папці   res/values  у файлі з будь-яким довільним іменем. Загальний синтаксис визначення ресурсу наступний:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  resources  >\n       \u003C  dimen   name  =  \"ім’я_ресурсу\"  >використовуваний_розмір\u003C/  dimen  >\n   \u003C/  resources  >\n  Як і інші ресурси, ресурс   dimension  визначається в кореневому елементі   \u003Cresources> . Тег   \u003Cdimen>  позначає ресурс і в якості значення приймає певний розмір у одній з прийнятих одиниць вимірювання (  dp ,   sp ,   pt ,   px ,   mm ,   in ).  Тепер додамо в Android Studio до папки   res/values  новий елемент   Values Resources File , який називатимемо   dimens.xml .    Визначимо в ньому наступний вміст:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  resources  >\n       \u003C  dimen   name  =  \"horizontal_margin\"  >64dp\u003C/  dimen  >\n       \u003C  dimen   name  =  \"vertical_margin\"  >32dp\u003C/  dimen  >\n       \u003C  dimen   name  =  \"text_size\"  >32sp\u003C/  dimen  >\n   \u003C/  resources  >\n  Тут визначено два ресурси для відступів   horizontal_margin  і   vertical_margin , які зберігають відповідно значення   64dp  і   32dp , а також ресурс   text_size , який зберігає висоту шрифту —   32sp . Імена ресурсів можуть бути довільними.  Тепер використовуємо ресурс у файлі   activity_main.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Hello Android\"\n           android:background  =  \"#eaeaea\"\n            \n           android:layout_marginTop  =  \"@dimen/vertical_margin\"\n           android:layout_marginLeft  =  \"@dimen/horizontal_margin\"\n           android:textSize  =  \"@dimen/text_size\"\n            \n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Ресурси   dimension  використовуються для таких атрибутів візуальних елементів, які в якості значення потребують числового значення. Наприклад, атрибути   android:layout_height  або   android:textSize . Для отримання ресурсу в xml після   @dimen/  вказується ім’я ресурсу.    Для отримання ресурсів у коді Java використовується метод   getDimension()  класу   Resources . Наприклад, визначимо в коді Java аналогічний візуальний інтерфейс:     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   androidx.constraintlayout.widget.ConstraintLayout  ;\n    \n   import   android.content.res.Resources  ;\n   import   android.os.Bundle  ;\n   import   android.util.TypedValue  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           //setContentView(R.layout.activity_main);\n           // отримуємо ресурси\n           Resources   resources   =   getResources  ();\n           float   textSize   =   resources.  getDimension  (R.dimen.text_size);\n           int   hMargin   =   (  int  )resources.  getDimension  (R.dimen.horizontal_margin);\n           int   vMargin   =   (  int  )resources.  getDimension  (R.dimen.vertical_margin);\n    \n           ConstraintLayout   constraintLayout   =   new   ConstraintLayout  (  this  );\n    \n           ConstraintLayout  .  LayoutParams   layoutParams   =   new   ConstraintLayout  .  LayoutParams\n                   (ConstraintLayout.LayoutParams.WRAP_CONTENT , ConstraintLayout.LayoutParams.WRAP_CONTENT);\n           layoutParams.leftToLeft   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           layoutParams.topToTop   =   ConstraintLayout.LayoutParams.PARENT_ID;\n    \n           TextView   textView   =   new   TextView  (  this  );\n           textView.  setText  (  \"Hello Android\"  );\n           textView.  setBackgroundColor  (  0XFFEAEAEA  );\n           // встановлюємо розмір шрифта за ресурсом\n           textView.  setTextSize  (TypedValue.COMPLEX_UNIT_PX, textSize);\n           // встановлюємо відступи відповідно до ресурсів\n           layoutParams.  setMargins  (hMargin, vMargin, hMargin, vMargin);\n    \n           textView.  setLayoutParams  (layoutParams);\n           constraintLayout.  addView  (textView);\n    \n           setContentView  (constraintLayout);\n       }\n   }\n  При програмному отриманні ресурсів   dimen  за допомогою методу   getDimension()  слід враховувати, що він повертає значення у фізичних пікселях, навіть якщо у файлі ресурсів ми визначили значення в інших одиницях виміру (  32sp ,   64dp ). У більшості випадків це не викликає труднощів, оскільки більшість методів у Java приймають саме пікселі, а не   dp  чи інші одиниці, як наприклад, метод   setMargins() , який встановлює відступи.  Однак метод   setTextSize()  приймає саме   sp , тому з додатковим параметром необхідно вказати, що в даному випадку маються на увазі фізичні пікселі, а не   sp :     textView.  setTextSize  (TypedValue.COMPLEX_UNIT_PX, textSize);\n  Або, як варіант, за допомогою класу   TypedValue  можна програмно перевести фізичні пікселі в sp або іншу одиницю виміру.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":313,"path":314,"dir":192,"title":315,"description":316,"keywords":317,"body":318},"content:1.android:2.lesson2:16.color-resources.md","/android/lesson2/color-resources","Ресурси Color і встановлення кольору","У додатку Android також можна визначати ресурси кольорів (Color). Вони повинні зберігатися у файлі за шляхом res/values і, як і ресурси рядків, обгорнуті в тег \u003Cresources>. Так, за замовчуванням при створенні найпростішого проекту в папку res/values додається файл colors.xml:",[],"  Ресурси Color і встановлення кольору  У додатку Android також можна визначати ресурси кольорів (Color). Вони повинні зберігатися у файлі за шляхом   res/values  і, як і ресурси рядків, обгорнуті в тег   \u003Cresources> . Так, за замовчуванням при створенні найпростішого проекту в папку   res/values  додається файл   colors.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  resources  >\n       \u003C  color   name  =  \"purple_200\"  >#FFBB86FC\u003C/  color  >\n       \u003C  color   name  =  \"purple_500\"  >#FF6200EE\u003C/  color  >\n       \u003C  color   name  =  \"purple_700\"  >#FF3700B3\u003C/  color  >\n       \u003C  color   name  =  \"teal_200\"  >#FF03DAC5\u003C/  color  >\n       \u003C  color   name  =  \"teal_700\"  >#FF018786\u003C/  color  >\n       \u003C  color   name  =  \"black\"  >#FF000000\u003C/  color  >\n       \u003C  color   name  =  \"white\"  >#FFFFFFFF\u003C/  color  >\n   \u003C/  resources  >\n  Колір визначається за допомогою елемента   \u003Ccolor> . Його атрибут   name  встановлює назву кольору, яка буде використовуватися в додатку, а шестнадцяткове число — значення кольору.  Для задання кольорових ресурсів можна використовувати наступні формати:    #RGB  (  #F00  — 12-бітне значення)   #ARGB  (  #8F00  — 12-бітне значення з додаванням альфа-каналу)   #RRGGBB  (  #FF00FF  — 24-бітне значення)   #AARRGGBB  (  #80FF00FF  — 24-бітне значення з додаванням альфа-каналу)  Щоб не змінювати і не псувати цей файл, визначимо свій новий файл ресурсів і для цього додамо в папку   res/values  новий файл ресурсів, який назвемо   my_colors.xml .\n  \nЗмінимо файл   my_colors.xml , додавши в нього пару кольорів:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  resources  >\n       \u003C  color   name  =  \"textViewBackColor\"  >#A0EAE1\u003C/  color  >\n       \u003C  color   name  =  \"textViewFontColor\"  >#00695C\u003C/  color  >\n   \u003C/  resources  >\n  Застосуємо ці кольори в файлі   activity_main.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Hello Android\"\n            \n           android:background  =  \"@color/textViewBackColor\"\n           android:textColor  =  \"@color/textViewFontColor\"\n            \n           android:textSize  =  \"32sp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  За допомогою атрибута   android:textColor  встановлюється колір тексту в   TextView , а атрибут   android:background  встановлює фон   TextView . Як значення вони використовують колір, наприклад, у тому ж шестнадцятковому форматі. Для отримання самого кольору після   @color/  вказується ім'я ресурсу.    Також можна використовувати кольорові ресурси в коді   MainActivity :     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   androidx.constraintlayout.widget.ConstraintLayout  ;\n    \n   import   android.content.res.Resources  ;\n   import   android.os.Bundle  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           //setContentView(R.layout.activity_main);\n           // отримуємо ресурси\n           Resources   resources   =   getResources  ();\n           int   textColor   =   resources.  getColor  (R.color.textViewFontColor,    null  );\n           int   backgroundColor   =   resources.  getColor  (R.color.textViewBackColor,    null  );\n    \n           ConstraintLayout   constraintLayout   =   new   ConstraintLayout  (  this  );\n    \n           ConstraintLayout  .  LayoutParams   layoutParams   =   new   ConstraintLayout  .  LayoutParams\n                   (ConstraintLayout.LayoutParams.WRAP_CONTENT , ConstraintLayout.LayoutParams.WRAP_CONTENT);\n           layoutParams.leftToLeft   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           layoutParams.topToTop   =   ConstraintLayout.LayoutParams.PARENT_ID;\n    \n           TextView   textView   =   new   TextView  (  this  );\n           textView.  setText  (  \"Hello Android\"  );\n           textView.  setTextSize  (  32  );\n            \n           // використовуємо ресурси кольору\n           textView.  setTextColor  (textColor);\n           textView.  setBackgroundColor  (backgroundColor);\n    \n           textView.  setLayoutParams  (layoutParams);\n           constraintLayout.  addView  (textView);\n    \n           setContentView  (constraintLayout);\n       }\n   }\n  Для отримання кольору з ресурсів використовується метод   resources.getColor() , який приймає два параметри. Перший параметр — ідентифікатор ресурсу, колір якого потрібно отримати. Другий параметр — це тема. Оскільки в даному випадку тема не важлива, для цього параметра передається значення   null .  Слід врахувати, що метод   resources.getColor()  з двома параметрами, який використано вище, доступний, якщо мінімальна версія Android не нижча за Android 6.0 (або Android 23). Однак, якщо мінімальна версія Android нижча, можна використовувати застарілу версію з одним параметром:     int   textColor   =   resources.  getColor  (R.color.textViewFontColor);\n   // замість\n   // int textColor = resources.getColor(R.color.textViewFontColor, null);\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":320,"path":321,"dir":192,"title":322,"description":323,"keywords":324,"body":333},"content:1.android:2.lesson2:17.activity.md","/android/lesson2/activity","Activity і життєвий цикл програми","Ключовим компонентом для створення візуального інтерфейсу в додатку Android є activity (активність). Часто activity асоціюється з окремим екраном або вікном додатку, а перемикання між вікнами відбувається при переміщенні від однієї activity до іншої. Додаток може мати одну або кілька activity. Наприклад, при створенні проекту з порожньою Activity у проект за замовчуванням додається один клас Activity — MainActivity, з якого і починається робота додатку:",[325,326,327,328,329,330,331,332],"Життєвий цикл додатку","onCreate()","onStart()","onResume()","onPause()","onStop()","onDestroy()","Управління життєвим циклом","  Activity і життєвий цикл програми  Ключовим компонентом для створення візуального інтерфейсу в додатку Android є   activity  (активність). Часто activity асоціюється з окремим екраном або вікном додатку, а перемикання між вікнами відбувається при переміщенні від однієї activity до іншої. Додаток може мати одну або кілька activity. Наприклад, при створенні проекту з порожньою Activity у проект за замовчуванням додається один клас Activity —   MainActivity , з якого і починається робота додатку:     public   class   MainActivity   extends   AppCompatActivity   {\n    \n       // вміст класу\n   }\n  Усі об'єкти activity є об'єктами класу   android.app.Activity , який містить базову функціональність для всіх activity. У додатку з попередньої теми ми безпосередньо не працювали з цим класом, а   MainActivity  наслідувалася від класу   AppCompatActivity . Однак сам клас   AppCompatActivity , хоч і не безпосередньо, наслідується від базового класу   Activity .  Життєвий цикл додатку  Усі додатки Android мають строго визначений життєвий цикл. При запуску користувачем додатку система надає цьому додатку високий пріоритет. Кожен додаток запускається у вигляді окремого процесу, що дозволяє системі надавати одному процесу більш високий пріоритет порівняно з іншими. Завдяки цьому, наприклад, при роботі з одними додатками Android дозволяє не блокувати вхідні дзвінки. Після припинення роботи з додатком, система звільняє всі пов'язані ресурси, переводить додаток в розряд низькоприоритетних і закриває його.  Усі об'єкти activity, які є в додатку, керуються системою у вигляді стеку activity, який називається   back stack . При запуску нової activity вона поміщається поверх стеку і виводиться на екран пристрою, поки не з'явиться нова activity. Коли поточна activity завершує свою роботу (наприклад, користувач виходить із додатку), то вона видаляється зі стеку, і відновлюється робота тієї activity, яка раніше була другою у стеку.  Після запуску   activity  проходить через низку подій, які обробляються системою, і для обробки яких існує ряд зворотних викликів:     protected   void   onCreate  (  Bundle   saveInstanceState);\n   protected   void   onStart  ();\n   protected   void   onRestart  ();\n   protected   void   onResume  ();\n   protected   void   onPause  ();\n   protected   void   onStop  ();\n   protected   void   onDestroy  ();\n  Схематично взаємозв'язок між всіма цими зворотними викликами можна уявити наступним чином:     onCreate()   onCreate  — перший метод, з якого починається виконання activity. У цьому методі activity переходить у стан   Created . Цей метод обов'язково має бути визначений у класі activity. У ньому відбувається початкова налаштування activity, включаючи створення об'єктів візуального інтерфейсу.  Метод отримує об'єкт   Bundle , який містить попередній стан activity, якщо він був збережений. Якщо activity створюється заново, об'єкт   Bundle  має значення   null . Якщо ж activity була раніше створена, але знаходилася в призупиненому стані, то   Bundle  містить зв'язану з activity інформацію.  Після того, як метод   onCreate()  завершує виконання, activity переходить у стан   Started , і система викликає метод   onStart() .    onStart()  У методі   onStart()  здійснюється підготовка до виведення activity на екран пристрою. Як правило, цей метод не потребує переозначення, а всю роботу виконує вбудований код. Після завершення роботи методу activity відображається на екрані, викликається метод   onResume , і activity переходить у стан   Resumed .    onResume()  При виклику методу   onResume  activity переходить у стан   Resumed  і відображається на екрані пристрою. Користувач може взаємодіяти з нею. Activity залишається в цьому стані, поки не втратить фокус, наприклад, через перемикання на іншу activity або вимкнення екрану пристрою.    onPause()  Якщо користувач вирішить перейти до іншої activity, система викликає метод   onPause , і activity переходить у стан   Paused . У цьому методі можна звільнити використовувані ресурси, призупинити процеси (наприклад, відтворення аудіо, анімацій), зупинити роботу камери (якщо вона використовується) тощо, щоб зменшити навантаження на систему.  Однак слід пам'ятати, що в цьому стані activity все ще залишається видимою на екрані, і на виконання цього методу виділяється дуже мало часу. Тому не варто тут зберігати які-небудь дані, особливо якщо це вимагає звернення до мережі (наприклад, відправка даних через інтернет) або бази даних — ці дії краще виконувати в методі   onStop() .  Після виконання цього методу activity стає невидимою, не відображається на екрані, але залишається активною. Якщо користувач вирішить повернутися до цієї activity, система знову викликає метод   onResume , і activity знову з'являється на екрані.   Примітка:  У випадку, якщо система вирішить завершити роботу невидимих activity, вона може викликати метод   onStop() , особливо якщо система потребує звільнення пам'яті.    onStop()  У методі   onStop()  activity переходить у стан   Stopped . У цьому стані activity повністю невидима. Тут слід звільняти ресурси, які не потрібні користувачу, коли він не взаємодіє з activity. Також можна зберігати дані (наприклад, у базу даних).  Activity залишається в пам'яті пристрою, і зберігається стан усіх елементів інтерфейсу. Наприклад, якщо в текстове поле   EditText  був введений текст, то після відновлення роботи activity в стані   Resumed  цей текст залишатиметься.  Якщо після виклику методу   onStop()  користувач вирішить повернутися до попередньої activity, система викликає метод   onRestart . Якщо ж activity завершила свою роботу, наприклад, через закриття програми, викликається метод   onDestroy() .    onDestroy()  Метод   onDestroy()  викликається при завершенні роботи activity. Це відбувається або тому, що система вирішує вбити activity через конфігураційні причини (наприклад, при зміні орієнтації екрану або при багатозадачності), або при виклику методу   finish() .   Важливо: при зміні орієнтації екрану система завершує activity і створює її заново, викликаючи метод   onCreate() .  Загалом перехід між станами   activity  можна виразити такою схемою:\n   Якщо ми працюємо з   Activity , а потім переключаємося на інший додаток або натискаємо кнопку   Home , то для   Activity  викликається наступна послідовність методів:   onPause -> onStop . Activity потрапляє в стан   Stopped . Якщо користувач вирішить повернутися до   Activity , викликається наступна послідовність методів:   onRestart -> onStart -> onResume .  Інша ситуація: якщо користувач натискає кнопку   Back  (Назад), викликається така послідовність:   onPause -> onStop -> onDestroy . В результаті   Activity  знищується. Якщо ми захочемо повернутися до   Activity  через диспетчер задач або заново відкривши додаток,   activity  буде пересоздана через методи:   onCreate -> onStart -> onResume .  Управління життєвим циклом  Ми можемо керувати цими подіями життєвого циклу, перевизначивши відповідні методи. Для цього візьмемо з попереднього розділу клас   MainActivity  і змінимо його наступним чином:     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.util.Log  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       private   final   static   String   TAG   =   \"MainActivity\"  ;\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n           Log.  d  (TAG,   \"onCreate\"  );\n       }\n       \n       @  Override\n       protected   void   onDestroy  (){\n           super  .  onDestroy  ();\n           Log.  d  (TAG,   \"onDestroy\"  );\n       }\n       \n       @  Override\n       protected   void   onStop  (){\n           super  .  onStop  ();\n           Log.  d  (TAG,   \"onStop\"  );\n       }\n       \n       @  Override\n       protected   void   onStart  (){\n           super  .  onStart  ();\n           Log.  d  (TAG,   \"onStart\"  );\n       }\n       \n       @  Override\n       protected   void   onPause  (){\n           super  .  onPause  ();\n           Log.  d  (TAG,   \"onPause\"  );\n       }\n       \n       @  Override\n       protected   void   onResume  (){\n           super  .  onResume  ();\n           Log.  d  (TAG,   \"onResume\"  );\n       }\n    \n       @  Override\n       protected   void   onRestart  (){\n           super  .  onRestart  ();\n           Log.  d  (TAG,   \"onRestart\"  );\n       }\n   }\n  Для логування подій тут використовується клас   android.util.Log .  У цьому випадку обробляються всі ключові методи життєвого циклу. Вся обробка зводиться до виклику методу   Log.d() , в який передається   TAG  — випадкове рядкове значення і рядок, який виводиться в консолі   Logcat  в нижній частині   Android Studio , виконуючи роль відладкової інформації. Якщо ця консоль за замовчуванням прихована, ми можемо перейти до неї через пункт меню   View -> Tool Windows -> Logcat .  І під час запуску програми ми зможемо побачити у вікні   Logcat  налагоджувальну інформацію, яка визначається в методах життєвого циклу   activity :    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":335,"path":336,"dir":192,"title":337,"description":338,"keywords":339,"body":346},"content:1.android:2.lesson2:18.manifest.md","/android/lesson2/manifest","Файл маніфесту AndroidManifest.xml","Кожен додаток містить файл манифеста AndroidManifest.xml. Цей файл визначає важливу інформацію про додаток — назву, версію, іконки, які дозволи використовує додаток, реєструє всі використовувані класи **activity**, сервіси тощо. Цей файл можна знайти в проекті в папці manifests:",[340,341,342,343,344,345],"Вкладені елементи activity","Визначення версії","Встановлення версії SDK","Встановлення дозволів","Підтримка різних роздільних здатностей екранів","Заборона на зміну орієнтації","  Файл маніфесту AndroidManifest.xml  Кожен додаток містить файл манифеста   AndroidManifest.xml . Цей файл визначає важливу інформацію про додаток —   назву ,   версію ,   іконки ,   які дозволи використовує додаток ,   реєструє всі використовувані класи **activity** ,   сервіси  тощо. Цей файл можна знайти в проекті в папці   manifests :    Файл манифеста може виглядати так:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  manifest   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       package  =  \"com.example.viewapp\"  >\n    \n       \u003C  application\n           android:allowBackup  =  \"true\"\n           android:icon  =  \"@mipmap/ic_launcher\"\n           android:label  =  \"@string/app_name\"\n           android:roundIcon  =  \"@mipmap/ic_launcher_round\"\n           android:supportsRtl  =  \"true\"\n           android:theme  =  \"@style/Theme.ViewApp\"  >\n           \u003C  activity   android:name  =  \".MainActivity\"  >\n               \u003C  intent-filter  >\n                   \u003C  action   android:name  =  \"android.intent.action.MAIN\"   />\n    \n                   \u003C  category   android:name  =  \"android.intent.category.LAUNCHER\"   />\n               \u003C/  intent-filter  >\n           \u003C/  activity  >\n       \u003C/  application  >\n    \n   \u003C/  manifest  >\n  Елементом кореневого рівня є вузол   manifest . В даному випадку тільки визначається пакет додатка -   package=\"com.example.viewapp\" . Це визначення файлу манифеста за замовчуванням. В кожному конкретному випадку пакет додатка може відрізнятися, решта вмісту при створенні проекту з порожньою   activity  буде аналогічним.  Більшість налаштувань рівня додатка визначається елементом   application . Ряд налаштувань задаються за допомогою атрибутів. За замовчуванням застосовуються наступні атрибути:    android:allowBackup  вказує, чи буде для додатка створюватися резервна копія. Значення   android:allowBackup=\"true\"  дозволяє створення резервної копії.   android:icon  встановлює іконку додатка. При значенні   android:icon=\"@mipmap/ic_launcher\"  іконка додатка береться з каталогу   res/mipmap .   android:roundIcon  встановлює круглу іконку додатка. Також береться з каталогу   res/mipmap .   android:label  задає назву додатка, яке буде відображатися на мобільному пристрої в списку додатків і в заголовку. В даному випадку воно зберігається в рядкових ресурсах -   android:label=\"@string/app_name\" .   android:supportsRtl  вказує, чи можуть використовуватися різні   RTL  API - спеціальні API для роботи з правосторонньою орієнтацією тексту (наприклад, для таких мов як арабська чи фарсі).   android:theme  встановлює тему додатка. Детальніше теми будуть розглянуті далі, а поки достатньо знати, що тема визначає загальний стиль додатка. Значення   \"@style/Theme.ViewApp\"  бере тему   \"Theme.ViewApp\"  з каталогу   res/values/themes .  Вкладені елементи activity  Вкладені елементи   activity  визначають всі використовувані в додатку   activity . У даному випадку видно, що в додатку є тільки одна   activity  —   MainActivity .     \u003C  activity   android:name  =  \".MainActivity\"  >\n       \u003C  intent-filter  >\n           \u003C  action   android:name  =  \"android.intent.action.MAIN\"   />\n    \n           \u003C  category   android:name  =  \"android.intent.category.LAUNCHER\"   />\n       \u003C/  intent-filter  >\n   \u003C/  activity  >\n  Елемент   intent-filter  у   MainActivity  вказує, як ця   activity  буде використовуватися. Зокрема, за допомогою вузла   action    android:name=\"android.intent.action.MAIN\" , що означає, що ця   activity  буде вхідною точкою в додаток і не повинна отримувати жодні дані ззовні.  Елемент   category    android:name=\"android.intent.category.LAUNCHER\"  вказує, що   MainActivity  буде представляти стартовий екран, який відображається при запуску додатка.  Файл манифеста може містити безліч елементів, які мають різні атрибути. Усі можливі елементи та їх атрибути можна знайти в документації. Тут же розглянемо деякі приклади використання.  Визначення версії  За допомогою атрибутів елемента   manifest  можна визначити версію додатку та його коду:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  manifest   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       package  =  \"com.example.viewapp\"\n       android:versionName  =  \"1.0\"\n       android:versionCode  =  \"1\"  >\n        \n   \u003C!-- інше вміст-->\n    \n   \u003C/  manifest  >\n  Атрибут   android:versionName  вказує на номер версії, який буде відображатися користувачу і на який будуть орієнтуватися користувачі при роботі з додатком.  Тоді як атрибут   android:versionCode  представляє номер версії для внутрішнього використання. Цей номер тільки визначає, що одна версія додатку є новішою за іншу з меншим номером версії. Цей номер не відображається користувачам.  При бажанні ми також можемо визначити версію в ресурсах, а тут посилатись на ресурс.  Встановлення версії SDK  Для керування версією Android SDK в файлі манифеста визначається елемент    . Він може використовувати наступні атрибути:    minSdkVersion : мінімально підтримувана версія SDK.   targetSdkVersion : оптимальна версія.   maxSdkVersion : максимальна версія.  Версія визначається номером API, наприклад, Jelly Beans 4.1 має версію 16, а Android 11 має версію 30:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  manifest   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       package  =  \"com.example.viewapp\"\n       android:versionName  =  \"1.0\"\n       android:versionCode  =  \"1\"  >\n       \u003C  uses-sdk   android:minSdkVersion  =  \"22\"   android:targetSdkVersion  =  \"30\"   />\n   \u003C!-- інше вміст-->\n    \n   \u003C/  manifest  >\n  Встановлення дозволів  Іноді додатку потрібні дозволи для доступу до певних ресурсів, наприклад, до   списку контактів ,   камери  тощо. Щоб додаток міг працювати з цими ресурсами, в файлі манифеста необхідно встановити відповідні дозволи. Для встановлення дозволів використовується елемент    :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  manifest   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       package  =  \"com.example.viewapp\"  >\n       \u003C  uses-permission   android:name  =  \"android.permission.READ_CONTACTS\"   />\n       \u003C  uses-permission   android:name  =  \"android.permission.CAMERA\"   android:maxSdkVersion  =  \"30\"   />\n   \u003C!-- інше вміст-->\n    \n   \u003C/  manifest  >\n  Атрибут   android:name  визначає назву дозволу: в даному випадку на читання списку контактів і використання камери. Опційно можна встановити максимальну версію SDK через атрибут   android:maxSdkVersion , який приймає номер API.  Підтримка різних роздільних здатностей екранів  Світ пристроїв Android дуже сильно фрагментований, тут зустрічаються як гаджети з маленьким екраном, так і великі широкоформатні телевізори. І бувають випадки, коли потрібно обмежити використання додатку для певних роздільних здатностей екранів. Для цього в файлі манифеста визначається елемент    :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  manifest   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       package  =  \"com.example.viewapp\"  >\n        \n       \u003C  supports-screens\n           android:largeScreens  =  \"true\"\n           android:normalScreens  =  \"true\"\n           android:smallScreens  =  \"false\"\n           android:xlargeScreens  =  \"true\"   />\n   \u003C!-- інше вміст-->\n    \n   \u003C/  manifest  >\n  Цей елемент має чотири атрибути:    android:largeScreens  - екрани з діагоналлю від 4.5 до 10\"   android:normalScreens  - екрани з діагоналлю від 3 до 4.5\"   android:smallScreens  - екрани з діагоналлю менше 3\"   android:xlargeScreens  - екрани з діагоналлю більше 10\"  Якщо атрибут має значення   true , то додаток підтримуватиме відповідний розмір екрану.  Заборона на зміну орієнтації  Додаток, залежно від положення пристрою, може знаходитися в альбомній або портретній орієнтації. Не завжди це зручно. Ми можемо зробити так, щоб додаток, незалежно від повороту пристрою, використовував лише одну орієнтацію. Для цього в файлі манифеста для потрібної   activity  потрібно встановити атрибут   android:screenOrientation . Наприклад, заборонимо альбомну орієнтацію:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  manifest   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       package  =  \"com.example.viewapp\"\n       android:versionName  =  \"1.0\"\n       android:versionCode  =  \"1\"   >\n    \n       \u003C  application\n           android:allowBackup  =  \"true\"\n           android:icon  =  \"@mipmap/ic_launcher\"\n           android:label  =  \"@string/app_name\"\n           android:roundIcon  =  \"@mipmap/ic_launcher_round\"\n           android:supportsRtl  =  \"true\"\n           android:theme  =  \"@style/Theme.ViewApp\"  >\n           \u003C  activity   android:name  =  \".MainActivity\"\n               android:screenOrientation  =  \"portrait\"  >\n                \n               \u003C  intent-filter  >\n                   \u003C  action   android:name  =  \"android.intent.action.MAIN\"   />\n    \n                   \u003C  category   android:name  =  \"android.intent.category.LAUNCHER\"   />\n               \u003C/  intent-filter  >\n           \u003C/  activity  >\n       \u003C/  application  >\n   \u003C/  manifest  >\n  Значення   android:screenOrientation=\"portrait\"  вказує, що ця   activity  буде знаходитися лише в портретній орієнтації. Якщо ж потрібно встановити лише альбомну орієнтацію, тоді використовується значення   android:screenOrientation=\"landscape\" .  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":348,"path":349,"dir":192,"title":350,"description":351,"keywords":352,"body":354},"content:1.android:2.lesson2:19.intent.md","/android/lesson2/intent","Вступ до Intent. Запуск Activity","Для взаємодії між різними об'єктами activity ключовим класом є android.content.Intent. Він представляє собою задачу, яку потрібно виконати додатку.",[353],"Запуск SecondActivity з MainActivity","  Вступ до Intent. Запуск Activity  Для взаємодії між різними об'єктами   activity  ключовим класом є   android.content.Intent . Він представляє собою задачу, яку потрібно виконати додатку.  Для роботи з   Intent  додамо новий клас   Activity . Для цього натискаємо правою кнопкою миші на папку, в якій знаходиться клас   MainActivity , і потім у контекстному меню вибираємо   New -> Activity -> Empty Views Activity :    Новий клас   Activity  назвемо   SecondActivity , а всі інші налаштування залишимо за замовчуванням:\n   І після цього в проєкт буде додано нову   Activity  -   SecondActivity :\n   Після цього в файлі манифеста   AndroidManifest.xml  ми зможемо знайти наступні рядки:     \u003C  activity\n       android:name  =  \".SecondActivity\"\n       android:exported  =  \"false\"   />\n   \u003C  activity\n       android:name  =  \".MainActivity\"\n       android:exported  =  \"true\"  >\n       \u003C  intent-filter  >\n           \u003C  action   android:name  =  \"android.intent.action.MAIN\"   />\n    \n           \u003C  category   android:name  =  \"android.intent.category.LAUNCHER\"   />\n       \u003C/  intent-filter  >\n   \u003C/  activity  >\n  Усі використані класи   activity  повинні бути описані в файлі   AndroidManifest.xml  за допомогою елемента   \u003Cactivity> . Кожен такий елемент містить як мінімум один атрибут   android:name , який встановлює ім'я класу   activity .  Однак по суті   activity  — це стандартні класи Java, які наслідуються від класу   Activity  або його нащадків. Тому замість вбудованих шаблонів в Android Studio ми можемо додавати звичайні класи, а потім їх наслідувати від класу   Activity . Однак у цьому випадку потрібно буде вручну додавати в файл манифеста дані про   activity .  Причому для   MainActivity  в елементі   intent-filter  визначено   інтент-фільтр . У ньому елемент   action  зі значенням   \"android.intent.action.MAIN\"  представляє головну точку входу в додаток. Тобто   MainActivity  залишається основною і запускається додатком за замовчуванням.  Для   SecondActivity  просто вказано, що вона є в проекті, і жодних   intent-фільтрів  для неї не задано.  Запуск SecondActivity з MainActivity  Щоб з   MainActivity  запустити   SecondActivity , потрібно викликати метод   startActivity() :     Intent   intent   =   new   Intent  (  this  , SecondActivity.class);\n   startActivity  (intent);\n  Як параметр у метод   startActivity  передається об'єкт   Intent . Для його створення в конструкторі   Intent  приймає два параметри: контекст виконання (в даному випадку це поточний об'єкт   MainActivity ) і клас, який використовується об'єктом   Intent  і представляє передавані в задачу дані (фактично клас   activity , яку ми будемо запускати).  Визначення кнопки для переходу в інтерфейсі  Тепер розглянемо реалізацію переходу від однієї   Activity  до іншої. Для цього в файлі   activity_main.xml  (тобто в інтерфейсі для   MainActivity ) визначимо кнопку:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n   \n       \u003C  Button\n           android:id  =  \"@+id/navButton\"\n           android:textSize  =  \"20sp\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Перейти до SecondActivity\"\n           android:onClick  =  \"onClick\"\n           \n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  />\n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Обробник натискання в   MainActivity  Тепер визначимо для кнопки в класі   MainActivity  обробник натискання, за яким буде здійснюватися перехід до нової   Activity :     package   com.example.viewapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.content.Intent  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n   \n       public   void   onClick  (  View   view  ) {\n           Intent   intent   =   new   Intent  (  this  , SecondActivity.class);\n           startActivity  (intent);\n       }\n   }\n  В обробнику натискання буде запускатися   SecondActivity .  Код   SecondActivity  Далі змінюємо код   SecondActivity :     package   com.example.viewapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.widget.TextView  ;\n   \n   public   class   SecondActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           //setContentView(R.layout.activity_second);\n           TextView   textView   =   new   TextView  (  this  );\n           textView.  setTextSize  (  20  );\n           textView.  setPadding  (  16  ,   16  ,   16  ,   16  );\n           textView.  setText  (  \"SecondActivity\"  );\n           setContentView  (textView);\n       }\n   }\n  Запустимо додаток і перейдемо від однієї   Activity  до іншої:\n   html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":356,"path":357,"dir":192,"title":358,"description":359,"keywords":360,"body":363},"content:1.android:2.lesson2:20.data-transfer.md","/android/lesson2/data-transfer","Передача даних між Activity. Серіалізація","Для передачі даних між двома Activity використовується об'єкт Intent. Через його метод putExtra() можна додати ключ і пов'язане з ним значення.",[361,362],"Отримання даних в SecondActivity","Передача складних об'єктів","  Передача даних між Activity. Серіалізація  Для передачі даних між двома   Activity  використовується об'єкт   Intent . Через його метод   putExtra()  можна додати ключ і пов'язане з ним значення.  Наприклад, передача з поточної   Activity  в   SecondActivity  рядка   \"Hello World\"  з ключем   \"hello\" :     // створення об'єкта Intent для запуску SecondActivity\n   Intent   intent   =   new   Intent  (  this  , SecondActivity.class);\n   // передача об'єкта з ключем \"hello\" та значенням \"Hello World\"\n   intent.  putExtra  (  \"hello\"  ,   \"Hello World\"  );\n   // запуск SecondActivity\n   startActivity  (intent);\n  Для передачі даних застосовується метод   putExtra() , який дозволяє передавати дані простих типів:   String ,   int ,   float ,   double ,   long ,   short ,   byte ,   char , масиви цих типів, або об'єкти інтерфейсу   Serializable .  Отримання даних в   SecondActivity  Щоб отримати відправлені дані під час завантаження   SecondActivity , можна скористатися методом   get() , в який передається ключ об'єкта:     Bundle   arguments   =   getIntent  ().  getExtras  ();\n   String   name   =   arguments.  get  (  \"hello\"  ).  toString  ();      // Hello World\n  Залежно від типу відправлених даних, при їх отриманні можна використовувати ряд методів об'єкта   Bundle . Всі вони як параметр приймають ключ об'єкта. Основні з них:    get() : універсальний метод, який повертає значення типу   Object . Відповідно, для отриманого значення необхідно виконати перетворення до потрібного типу.   getString() : повертає об'єкт типу   String .   getInt() : повертає значення типу   int .   getByte() : повертає значення типу   byte .   getChar() : повертає значення типу   char .   getShort() : повертає значення типу   short .   getLong() : повертає значення типу   long .   getFloat() : повертає значення типу   float .   getDouble() : повертає значення типу   double .   getBoolean() : повертає значення типу   boolean .   getCharArray() : повертає масив об'єктів типу   char .   getIntArray() : повертає масив об'єктів типу   int .   getFloatArray() : повертає масив об'єктів типу   float .   getSerializable() : повертає об'єкт інтерфейсу   Serializable .  Нехай у нашому проекті будуть визначені дві   Activity :   MainActivity  і   SecondActivity .  У   SecondActivity  визначимо отримання даних:     package   com.example.viewapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   \n   import   android.os.Bundle  ;\n   import   android.widget.TextView  ;\n   \n   public   class   SecondActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n            \n           TextView   textView   =   new   TextView  (  this  );\n           textView.  setTextSize  (  26  );\n           textView.  setPadding  (  16  ,   16  ,   16  ,   16  );\n   \n           Bundle   arguments   =   getIntent  ().  getExtras  ();\n   \n           if  (arguments   !=   null  ) {\n               String   name   =   arguments.  get  (  \"name\"  ).  toString  ();\n               String   company   =   arguments.  getString  (  \"company\"  );\n               int   age   =   arguments.  getInt  (  \"age\"  );\n               textView.  setText  (  \"Name: \"   +   name   +   \"  \\n  Company: \"   +   company   +\n                       \"  \\n  Age: \"   +   age);\n           }\n   \n           setContentView  (textView);\n       }\n   }\n  У цьому прикладі в   SecondActivity  ми отримуємо всі дані з об'єкта   Bundle  та виводимо їх у текстове поле   TextView . Передбачається, що в цю   Activity  будуть передані три елементи: дві строки з ключами   name  і   company , а також число з ключем   age .  Тепер визначимо передачу даних у   SecondActivity . Наприклад, для   MainActivity  у файлі   activity_main.xml  створимо інтерфейс з полями для введення даних:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n   \n       \u003C  TextView\n           android:id  =  \"@+id/nameLabel\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"20dp\"\n           android:text  =  \"Name:\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  />\n   \n       \u003C  EditText\n           android:id  =  \"@+id/name\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"40dp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/nameLabel\"  />\n   \n       \u003C  TextView\n           android:id  =  \"@+id/companyLabel\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"20dp\"\n           android:text  =  \"Company:\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/name\"  />\n   \n       \u003C  EditText\n           android:id  =  \"@+id/company\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"40dp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/companyLabel\"   />\n   \n       \u003C  TextView\n           android:id  =  \"@+id/ageLabel\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"20dp\"\n           android:text  =  \"Age:\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/company\"  />\n   \n       \u003C  EditText\n           android:id  =  \"@+id/age\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"40dp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/ageLabel\"  />\n   \n       \u003C  Button\n           android:id  =  \"@+id/btn\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:onClick  =  \"onClick\"\n           android:text  =  \"Save\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/age\"  />\n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Тут визначено три текстові поля для введення даних і кнопка для відправки.  Тепер, коли користувач заповнить поля у   MainActivity , ми можемо передати введені дані у   SecondActivity , використовуючи   Intent . Для цього в обробнику кнопки у   MainActivity  додаємо код:     public   void   onClick  (  View   view) {\n       EditText   nameEditText   =   findViewById  (R.id.name);\n       EditText   companyEditText   =   findViewById  (R.id.company);\n       EditText   ageEditText   =   findViewById  (R.id.age);\n   \n       String   name   =   nameEditText.  getText  ().  toString  ();\n       String   company   =   companyEditText.  getText  ().  toString  ();\n       int   age   =   Integer.  parseInt  (ageEditText.  getText  ().  toString  ());\n   \n       Intent   intent   =   new   Intent  (  this  , SecondActivity.class);\n       intent.  putExtra  (  \"name\"  , name);\n       intent.  putExtra  (  \"company\"  , company);\n       intent.  putExtra  (  \"age\"  , age);\n   \n       startActivity  (intent);\n   }\n  Тепер при натисканні на кнопку дані з   MainActivity  будуть передані у   SecondActivity .  У класі   MainActivity  визначаємо наступне вміст:     package   com.example.viewapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   \n   import   android.content.Intent  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.EditText  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n   \n       public   void   onClick  (  View   v  ) {\n   \n           EditText   nameText   =   findViewById  (R.id.name);\n           EditText   companyText   =   findViewById  (R.id.company);\n           EditText   ageText   =   findViewById  (R.id.age);\n   \n           String   name   =   nameText.  getText  ().  toString  ();\n           String   company   =   companyText.  getText  ().  toString  ();\n           int   age   =   Integer.  parseInt  (ageText.  getText  ().  toString  ());\n   \n           Intent   intent   =   new   Intent  (  this  , SecondActivity.class);\n           intent.  putExtra  (  \"name\"  , name);\n           intent.  putExtra  (  \"company\"  , company);\n           intent.  putExtra  (  \"age\"  , age);\n           startActivity  (intent);\n       }\n   }\n  В обробнику натискання кнопки ми отримуємо введені в текстові поля   EditText  дані та передаємо їх в об'єкт   Intent  за допомогою методу   putExtra() . Потім запускаємо   SecondActivity .  У підсумку, при натисканні на кнопку, буде запущена   SecondActivity , яка отримає деякі введені дані з текстових полів.    Передача складних об'єктів  У наведеному вище прикладі передавались прості дані — числа, рядки. Але також ми можемо передавати більш складні дані. Для цього використовується механізм серіалізації. Для цього натискаємо правою кнопкою миші на папку пакета, де знаходяться класи   MainActivity  та   SecondActivity , і в контекстному меню вибираємо   New -> Java Class :    Назвемо новий клас   User  - нехай він представлятиме користувача.    Передача складних об'єктів  Нехай клас   User  має наступний код:     package   com.example.viewapp  ;\n   \n   import   java.io.Serializable  ;\n   \n   public   class   User   implements   Serializable   {\n   \n       private   String   name;\n       private   String   company;\n       private   int   age;\n   \n       public   User  (  String   name  ,   String   company  ,   int   age  ){\n           this  .name   =   name;\n           this  .company   =   company;\n           this  .age   =   age;\n       }\n   \n       public   String   getName  () {\n           return   name;\n       }\n   \n       public   void   setName  (  String   name  ) {\n           this  .name   =   name;\n       }\n   \n       public   String   getCompany  () {\n           return   company;\n       }\n   \n       public   void   setCompany  (  String   company  ) {\n           this  .company   =   company;\n       }\n   \n       public   int   getAge  () {\n           return   age;\n       }\n   \n       public   void   setAge  (  int   age  ) {\n           this  .age   =   age;\n       }\n   }\n  Зверніть увагу, що цей клас реалізує інтерфейс   Serializable . Тепер змінюємо код   MainActivity :     package   com.example.viewapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   \n   import   android.content.Intent  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.EditText  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n   \n       public   void   onClick  (  View   v  ) {\n   \n           EditText   nameText   =   findViewById  (R.id.name);\n           EditText   companyText   =   findViewById  (R.id.company);\n           EditText   ageText   =   findViewById  (R.id.age);\n   \n           String   name   =   nameText.  getText  ().  toString  ();\n           String   company   =   companyText.  getText  ().  toString  ();\n           int   age   =   Integer.  parseInt  (ageText.  getText  ().  toString  ());\n   \n           User   user   =   new   User  (name, company, age);\n   \n           Intent   intent   =   new   Intent  (  this  , SecondActivity.class);\n           intent.  putExtra  (User.class.  getSimpleName  (), user);\n           startActivity  (intent);\n       }\n   }\n  Тепер замість трьох окремих даних передається один об'єкт   User . У якості ключа використовується результат методу   User.class.getSimpleName() , який фактично повертає назву класу.  І змінюємо клас   SecondActivity :     package   com.example.viewapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   \n   import   android.os.Bundle  ;\n   import   android.widget.TextView  ;\n   \n   public   class   SecondActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           //setContentView(R.layout.activity_second);\n           TextView   textView   =   new   TextView  (  this  );\n           textView.  setTextSize  (  26  );\n           textView.  setPadding  (  16  ,   16  ,   16  ,   16  );\n   \n           Bundle   arguments   =   getIntent  ().  getExtras  ();\n   \n           User   user;\n           if  (arguments   !=   null  ){\n               user   =   (User) arguments.  getSerializable  (User.class.  getSimpleName  ());\n   \n               textView.  setText  (  \"Name: \"   +   user.  getName  ()   +   \"  \\n  Company: \"   +   user.  getCompany  ()   +\n                       \"  \\n  Age: \"   +   String.  valueOf  (user.  getAge  ()));\n           }\n           setContentView  (textView);\n       }\n   }\n  Для отримання даних застосовується метод   getSerializable() , оскільки клас   User  реалізує інтерфейс   Serializable . Таким чином, ми можемо передавати один об'єкт замість набору окремих даних.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":365,"path":366,"dir":192,"title":367,"description":368,"keywords":369,"body":373},"content:1.android:2.lesson2:21.parcelable.md","/android/lesson2/parcelable","Parcelable","Можливість серіалізації об'єктів надається безпосередньо інфраструктурою мови Java. Однак Android також надає інтерфейс Parcelable, який по суті також дозволяє серіалізувати об'єкти, як і Serializable, але є більш оптимізованим для Android. Такі об'єкти Parcelable також можна передавати між двома Activity або використовувати іншими способами.",[370,371,372],"Отримання об'єкта Parcelable в Android","XML для MainActivity","Передача даних в SecondActivity","  Parcelable  Можливість серіалізації об'єктів надається безпосередньо інфраструктурою мови Java. Однак Android також надає інтерфейс   Parcelable , який по суті також дозволяє серіалізувати об'єкти, як і   Serializable , але є більш оптимізованим для Android. Такі об'єкти   Parcelable  також можна передавати між двома   Activity  або використовувати іншими способами.  Наприклад, у попередній темі дані передавалися між   Activity  у вигляді об'єктів   User , які використовували серіалізацію. Тепер нехай клас   User  застосовує інтерфейс   Parcelable :     package   com.example.viewapp  ;\n   \n   import   android.os.Parcel  ;\n   import   android.os.Parcelable  ;\n   \n   public   class   User   implements   Parcelable   {\n   \n       private   String   name;\n       private   String   company;\n       private   int   age;\n   \n       public   static   final   Creator  \u003C  User  > CREATOR   =   new   Creator  \u003C  User  >() {\n           @  Override\n           public   User   createFromParcel  (  Parcel   source  ) {\n               String   name   =   source.  readString  ();\n               String   company   =   source.  readString  ();\n               int   age   =   source.  readInt  ();\n               return   new   User  (name, company, age);\n           }\n   \n           @  Override\n           public   User  []   newArray  (  int   size  ) {\n               return   new   User  [size];\n           }\n       };\n   \n       public   User  (  String   name  ,   String   company  ,   int   age  ){\n           this  .name   =   name;\n           this  .company   =   company;\n           this  .age   =   age;\n       }\n   \n       public   String   getName  () {\n           return   name;\n       }\n   \n       public   void   setName  (  String   name  ) {\n           this  .name   =   name;\n       }\n   \n       public   String   getCompany  () {\n           return   company;\n       }\n   \n       public   void   setCompany  (  String   company  ) {\n           this  .company   =   company;\n       }\n   \n       public   int   getAge  () {\n           return   age;\n       }\n   \n       public   void   setAge  (  int   age  ) {\n           this  .age   =   age;\n       }\n   \n       @  Override\n       public   int   describeContents  () {\n           return   0  ;\n       }\n   \n       @  Override\n       public   void   writeToParcel  (  Parcel   dest  ,   int   flags  ) {\n           dest.  writeString  (name);\n           dest.  writeString  (company);\n           dest.  writeInt  (age);\n       }\n   }\n  Інтерфейс   android.os.Parcelable  передбачає реалізацію двох методів:   describeContents()  та   writeToParcel() . Перший метод описує вміст і повертає певне числове значення. Другий метод записує в об'єкт   Parcel  вміст об'єкта   User .  Для запису даних об'єкта в   Parcel  використовується ряд методів, кожен з яких призначений для певного типу даних. Основні методи:    writeString()  — записує рядок.   writeInt()  — записує ціле число.   writeFloat()  — записує число з плаваючою комою (тип float).   writeDouble()  — записує число з плаваючою комою подвійної точності (тип double).   writeByte()  — записує байт.   writeLong()  — записує довге ціле число.   writeIntArray()  — записує масив цілих чисел.   writeValue()  — записує об'єкт типу   Object .   writeParcelable()  — записує об'єкт типу   Parcelable .  Крім того, об'єкт   Parcelable  повинен містити статичне поле   CREATOR , яке представляє об'єкт   Creator  . Цей об'єкт реалізує два методи. Вони необхідні для створення раніше серіалізованих даних вихідних об'єктів типу   User .   Метод   newArray()  створює масив об'єктів   User .  Метод   createFromParcel()  створює з   Parcel  новий об'єкт типу   User . Тобто цей метод є протилежним за дією методу   writeToParcel .  Для отримання даних з   Parcel  застосовуються методи типу   readString() ,   readInt() ,   readParcelable()  та інші — для читання певних типів даних.  Важливо зазначити, що дані в методі   createFromParcel()  зчитуються з об'єкта   Parcel  саме в тому порядку, в якому вони додаються в цей об'єкт у методі   writeToParcel() .  Отримання об'єкта Parcelable в Android  У   SecondActivity , яка є наступним екраном, ми отримаємо об'єкт   User :     package   com.example.viewapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.widget.TextView  ;\n   \n   public   class   SecondActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n            \n           TextView   textView   =   new   TextView  (  this  );\n           textView.  setTextSize  (  26  );\n           textView.  setPadding  (  16  ,   16  ,   16  ,   16  );\n   \n           // Отримуємо додаткові дані з Intent\n           Bundle   arguments   =   getIntent  ().  getExtras  ();\n   \n           User   user;\n           if  (arguments   !=   null  ){\n               // Читаємо об'єкт User із Parcel\n               user   =   arguments.  getParcelable  (User.class.  getSimpleName  ());\n   \n               // Виводимо інформацію про користувача\n               textView.  setText  (  \"Name: \"   +   user.  getName  ()   +   \"  \\n  Company: \"   +   user.  getCompany  ()   +\n                       \"  \\n  Age: \"   +   String.  valueOf  (user.  getAge  ()));\n           }\n           setContentView  (textView);\n       }\n   }\n  Ключові моменти:   Для отримання об'єкта   Parcelable , переданого між   Activity , використовуємо метод   getParcelable() . Для цього не потрібно проводити приведення типів, оскільки   Parcelable  вже визначає тип даних.  Якщо у   Bundle  є додаткові дані (це перевіряється через   arguments != null ), ми витягуємо об'єкт   User  за допомогою   arguments.getParcelable() , передаючи   User.class.getSimpleName()  як ключ.  Далі ми виводимо значення полів об'єкта   User  у   TextView .   XML для   MainActivity  У файлі   activity_main.xml  визначаємо простий інтерфейс для введення даних користувача:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  TextView\n           android:id  =  \"@+id/nameLabel\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"20dp\"\n           android:text  =  \"Name:\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  />\n       \u003C  EditText\n           android:id  =  \"@+id/name\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"40dp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/nameLabel\"  />\n       \u003C  TextView\n           android:id  =  \"@+id/companyLabel\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"20dp\"\n           android:text  =  \"Company:\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/name\"  />\n       \u003C  EditText\n           android:id  =  \"@+id/company\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"40dp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/companyLabel\"   />\n       \u003C  TextView\n           android:id  =  \"@+id/ageLabel\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"20dp\"\n           android:text  =  \"Age:\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/company\"  />\n       \u003C  EditText\n           android:id  =  \"@+id/age\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"40dp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/ageLabel\"  />\n       \u003C  Button\n           android:id  =  \"@+id/btn\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:onClick  =  \"onClick\"\n           android:text  =  \"Save\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/age\"  />\n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  У цьому XML визначено кілька   TextView  та   EditText  для введення імені, компанії та віку, а також кнопку для збереження даних.   Передача даних в   SecondActivity  У   MainActivity  ми реалізуємо передачу даних у   SecondActivity :     package   com.example.viewapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.content.Intent  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.EditText  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n   \n       public   void   onClick  (  View   v  ) {\n           // Отримуємо введені дані\n           EditText   nameText   =   findViewById  (R.id.name);\n           EditText   companyText   =   findViewById  (R.id.company);\n           EditText   ageText   =   findViewById  (R.id.age);\n   \n           String   name   =   nameText.  getText  ().  toString  ();\n           String   company   =   companyText.  getText  ().  toString  ();\n           int   age   =   Integer.  parseInt  (ageText.  getText  ().  toString  ());\n   \n           // Створюємо об'єкт User\n           User   user   =   new   User  (name, company, age);\n   \n           // Створюємо Intent для передачі даних у SecondActivity\n           Intent   intent   =   new   Intent  (  this  , SecondActivity.class);\n           intent.  putExtra  (User.class.  getSimpleName  (), user);   // Передаємо об'єкт User\n   \n           // Запускаємо SecondActivity\n           startActivity  (intent);\n       }\n   }\n  Опис:   Ми отримуємо значення з   EditText  за допомогою   findViewById .  Створюємо об'єкт   User  з введених даних.  Використовуємо   Intent  для передачі об'єкта   User  в   SecondActivity  за допомогою методу   putExtra() .  У   SecondActivity  об'єкт отримується через   getParcelable()  і виводиться на екран.  Це базова реалізація передачі даних між   Activity  за допомогою   Parcelable .    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":375,"path":376,"dir":192,"title":377,"description":378,"keywords":379,"body":383},"content:1.android:2.lesson2:22.result-from-activity.md","/android/lesson2/result-from-activity","Отримання результату з Activity","В попередній темі було розглянуто, як викликати нову Activity і передавати їй деякі дані. Але ми можемо не тільки передавати дані запускаємому activity, а й очікувати від неї певного результату роботи.",[380,381,382],"Реєстрація функції для отримання результату","Запуск activity для отримання результату","Практичне застосування Activity Result API","  Отримання результату з Activity  В попередній темі було розглянуто, як викликати нову   Activity  і передавати їй деякі дані. Але ми можемо не тільки передавати дані запускаємому activity, а й очікувати від неї певного результату роботи.  Наприклад, нехай у нас в проекті буде дві activity:   MainActivity  і   SecondActivity . А для кожної activity є свій файл інтерфейсу:   activity_main.xml  і   activity_second.xml  відповідно.    У минулій темі ми викликали нову activity за допомогою методу   startActivity() . Для отримання ж результату роботи активності, що запускається, необхідно використовувати   Activity Result API .   Activity Result API  надає компоненти для реєстрації, запуску та обробки результату іншої Activity. Однією з переваг застосування Activity Result API є те, що він відв'язує результат Activity від самої Activity. Це дає змогу отримати й обробити результат, навіть якщо Activity, яка повертає результат, через обмеження пам'яті або з інших причин завершила свою роботу. Коротенько розглянемо основні моменти застосування Activity Result API.  Реєстрація функції для отримання результату  Для реєстрації функції, яка буде обробляти результат, Activity Result API надає метод   registerForActivityResult() . Цей метод приймає як параметри об'єкти   ActivityResultContract  і   ActivityResultCallback  та повертає об'єкт   ActivityResultLauncher , який використовується для запуску іншої activity.     ActivityResultLauncher  \u003C  I  >   registerForActivityResult   (\n                   ActivityResultContract  \u003C  I, O  >   contract, \n                   ActivityResultCallback  \u003C  O  >   callback)\n   ActivityResultContract  визначає контракт: які дані типу будуть подаватися на вхід і який тип буде представляти результат.   ActivityResultCallback  є інтерфейсом з єдиним методом   onActivityResult() , який визначає обробку отриманого результату. Коли друга activity завершить роботу і поверне результат, цей метод буде викликаний. Результат передається в метод як параметр. При цьому тип параметра повинен відповідати типу результату, визначеному в   ActivityResultContract . Наприклад:     ActivityResultLauncher  \u003C  Intent  > mStartForResult   =   registerForActivityResult  (\n       new   ActivityResultContracts.  StartActivityForResult  (),\n       new   ActivityResultCallback  \u003C  ActivityResult  >() {\n           @  Override\n           public   void   onActivityResult  (  ActivityResult   result  ) {\n               // обробка result\n           }\n       });\n  Клас   ActivityResultContracts  надає ряд вбудованих типів контрактів. Наприклад, в наведеному коді використовується вбудований тип   ActivityResultContracts.StartActivityForResult , який на вхід приймає об'єкт   Intent , а тип результату — це тип   ActivityResult .  Запуск activity для отримання результату  Метод   registerForActivityResult()  реєструє функцію-колбек і повертає об'єкт   ActivityResultLauncher . За допомогою цього об'єкта ми можемо запустити activity. Для цього у об'єкта   ActivityResultLauncher  викликається метод   launch() :     mStartForResult.  launch  (intent);\n  В метод   launch()  передається об'єкт того типу, який визначений в об'єкті   ActivityResultContracts  як вхідний.  Практичне застосування Activity Result API  Отже, визначимо в файлі   activity_main.xml  наступний інтерфейс:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n   \n       \u003C  TextView\n           android:id  =  \"@+id/textView\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Укажіть вік\"\n           android:textSize  =  \"22sp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  />\n       \n       \u003C  EditText\n           android:id  =  \"@+id/age\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/textView\"  />\n       \n       \u003C  Button\n           android:id  =  \"@+id/button\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:onClick  =  \"onClick\"\n           android:text  =  \"Відправити\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/age\"  />\n   \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Для введення даних тут визначено елемент   EditText , а для відправки — кнопка.  Тепер визначимо в класі   MainActivity  запуск другої activity:     package   com.example.viewapp  ;\n   \n   import   androidx.activity.result.ActivityResult  ;\n   import   androidx.activity.result.ActivityResultCallback  ;\n   import   androidx.activity.result.ActivityResultLauncher  ;\n   import   androidx.activity.result.contract.ActivityResultContracts  ;\n   import   androidx.appcompat.app.AppCompatActivity  ;\n   \n   import   android.app.Activity  ;\n   import   android.content.Intent  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.EditText  ;\n   import   android.widget.TextView  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       static   final   String   AGE_KEY   =   \"AGE\"  ;\n       static   final   String   ACCESS_MESSAGE   =   \"ACCESS_MESSAGE\"  ;\n   \n       ActivityResultLauncher  \u003C  Intent  > mStartForResult   =   registerForActivityResult  (  new   ActivityResultContracts.  StartActivityForResult  (),\n               new   ActivityResultCallback  \u003C  ActivityResult  >() {\n                   @  Override\n                   public   void   onActivityResult  (  ActivityResult   result  ) {\n   \n                       TextView   textView   =   findViewById  (R.id.textView);\n                       if  (result.  getResultCode  ()   ==   Activity.RESULT_OK){\n                           Intent   intent   =   result.  getData  ();\n                           String   accessMessage   =   intent.  getStringExtra  (ACCESS_MESSAGE);\n                           textView.  setText  (accessMessage);\n                       }\n                       else  {\n                           textView.  setText  (  \"Помилка доступу\"  );\n                       }\n                   }\n               });\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n   \n       public   void   onClick  (  View   view  ) {\n           // отримуємо введений вік\n           EditText   ageBox   =   findViewById  (R.id.age);\n           String   age   =   ageBox.  getText  ().  toString  ();\n   \n           Intent   intent   =   new   Intent  (  this  , SecondActivity.class);\n           intent.  putExtra  (AGE_KEY, age);\n   \n           mStartForResult.  launch  (intent);\n       }\n   }\n  Коротко розглянемо основні моменти цього коду. По-перше, ми визначаємо об'єкт   ActivityResultLauncher , за допомогою якого будемо запускати другу activity та передавати їй дані:     ActivityResultLauncher  \u003C  Intent  > mStartForResult   =   registerForActivityResult  (  new   ActivityResultContracts.  StartActivityForResult  (),\n           new   ActivityResultCallback  \u003C  ActivityResult  >() {\n               @  Override\n               public   void   onActivityResult  (  ActivityResult   result  ) {\n   \n                   TextView   textView   =   findViewById  (R.id.textView);\n                   if  (result.  getResultCode  ()   ==   Activity.RESULT_OK){\n                       Intent   intent   =   result.  getData  ();\n                       String   accessMessage   =   intent.  getStringExtra  (ACCESS_MESSAGE);\n                       textView.  setText  (accessMessage);\n                   }\n                   else  {\n                       textView.  setText  (  \"Помилка доступу\"  );\n                   }\n               }\n           });\n  Об'єкт   ActivityResultLauncher  типізується типом   Intent , оскільки об'єкт цього типу буде передаватися в метод   launch()  при запуску другої activity.  Тип контракту визначається типом   ActivityResultContracts.StartActivityForResult , який і визначає тип   Intent  як вхідний тип і тип   ActivityResult  як тип результату.  Другий аргумент методу   registerForActivityResult()  — об'єкт   ActivityResultCallback  типізується типом результату — типом   ActivityResult  і визначає функцію-колбек   onActivityResult() , яка отримує результат і обробляє його. У цьому випадку обробка полягає в тому, що ми виводимо в текстове поле відповідь від другої activity.  При обробці ми перевіряємо отриманий код результату:     if   (result.  getResultCode  ()   ==   Activity.RESULT_OK)\n  Як результат, зазвичай використовуються вбудовані константи   Activity.RESULT_OK  і   Activity.RESULT_CANCELED . Згідно з умовами,   Activity.RESULT_OK  означає, що activity успішно обробила запит, а   Activity.RESULT_CANCELED  — що activity відмовилася обробляти запит.  За допомогою методу   getData()  результату отримуємо передані з другої activity дані у вигляді об'єкта   Intent :     Intent   intent   =   result.  getData  ();\n  Далі витягуємо з   Intent  рядок, яка має ключ   ACCESS_MESSAGE , і виводимо її в текстове поле.  Таким чином, ми визначили об'єкт   ActivityResultLauncher . Далі в обробнику натискання   onClick  за допомогою цього об'єкта запускаємо другу activity —   SecondActivity :     public   void   onClick  (  View   view) {\n       // отримуємо введений вік\n       EditText   ageBox   =   findViewById  (R.id.age);\n       String   age   =   ageBox.  getText  ().  toString  ();\n    \n       Intent   intent   =   new   Intent  (  this  , SecondActivity.class);\n       intent.  putExtra  (AGE_KEY, age);\n    \n       mStartForResult.  launch  (intent);\n   }\n  В обробнику натискання кнопки   onClick()  отримуємо введений в текстове поле вік, додаємо його в об'єкт   Intent  з ключем   AGE_KEY  і запускаємо   SecondActivity  за допомогою методу   launch() .  Тепер перейдемо до   SecondActivity  і визначимо в файлі   activity_second.xml  набір кнопок:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"   >\n       \u003C  TextView\n           android:id  =  \"@+id/ageView\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"26sp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  />\n    \n       \u003C  Button\n           android:id  =  \"@+id/button1\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Відкрити доступ\"\n           android:onClick  =  \"onButton1Click\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/ageView\"  />\n    \n       \u003C  Button\n           android:id  =  \"@+id/button2\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Відхилити доступ\"\n           android:onClick  =  \"onButton2Click\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/button1\"  />\n    \n       \u003C  Button\n           android:id  =  \"@+id/button3\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Невірний вік\"\n           android:onClick  =  \"onButton3Click\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/button2\"   />\n    \n       \u003C  Button\n           android:id  =  \"@+id/cancel\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Скасувати\"\n           android:onClick  =  \"onCancelClick\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/button3\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  А в класі   SecondActivity  визначимо обробники для цих кнопок:     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.content.Intent  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.TextView  ;\n    \n   public   class   SecondActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_second);\n           Bundle   extras   =   getIntent  ().  getExtras  ();\n           if   (extras   !=   null  ) {\n               TextView   ageView   =   findViewById  (R.id.ageView);\n               String   age   =   extras.  getString  (MainActivity.AGE_KEY);\n               ageView.  setText  (  \"Вік: \"   +    age);\n           }\n       }\n       public   void   onCancelClick  (  View   v  ) {\n           setResult  (RESULT_CANCELED);\n           finish  ();\n       }\n       public   void   onButton1Click  (  View   v  ) {\n           sendMessage  (  \"Доступ дозволено\"  );\n       }\n       public   void   onButton2Click  (  View   v  ) {\n           sendMessage  (  \"Доступ заборонено\"  );\n       }\n       public   void   onButton3Click  (  View   v  ) {\n           sendMessage  (  \"Невірний вік\"  );\n       }\n       private   void   sendMessage  (  String   message  ){\n    \n           Intent   data   =   new   Intent  ();\n           data.  putExtra  (MainActivity.ACCESS_MESSAGE, message);\n           setResult  (RESULT_OK, data);\n           finish  ();\n       }\n   }\n  Три кнопки викликають метод   sendMessage() , в який передають відправлене повідомлення. Це і буде те повідомлення, яке отримає   MainActivity  в методі   onActivityResult .  Для повернення результату необхідно викликати метод   setResult() , в який передаються два параметри:   числовий код результату  відправлені дані  Після виклику методу   setResult()  потрібно викликати метод   finish , який знищить поточну activity.  Одна кнопка викликає обробник   onCancelClick() , в якому передається в   setResult  тільки код результату —   RESULT_CANCELED .  Отже, умовно кажучи, ми отримуємо в   SecondActivity  введений в   MainActivity  вік і за допомогою натискання певної кнопки повертаємо певний результат у вигляді повідомлення.  Залежно від натиснутої кнопки на   SecondActivity  ми будемо отримувати різні результати в   MainActivity :    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":385,"path":386,"dir":192,"title":387,"description":388,"keywords":389,"body":391},"content:1.android:2.lesson2:23-interaction.md","/android/lesson2/23-interaction","Взаємодія між Activity","У попередніх темах ми розглянули життєвий цикл Activity та запуск нових Activity за допомогою об'єкта Intent. Тепер розглянемо деякі особливості взаємодії між Activity в одному додатку. Припустимо, у нас є три Activity: MainActivity, SecondActivity та ThirdActivity.",[390],"Керування стеком activity","  Взаємодія між Activity  У попередніх темах ми розглянули життєвий цикл   Activity  та запуск нових   Activity  за допомогою об'єкта   Intent . Тепер розглянемо деякі особливості взаємодії між   Activity  в одному додатку. Припустимо, у нас є три   Activity :   MainActivity ,   SecondActivity  та   ThirdActivity .    За допомогою   Intent , наприклад, по натисканню кнопки   MainActivity  запускає   SecondActivity :     Intent   intent   =   new   Intent  (  this  , SecondActivity.class);\n   startActivity  (intent);\n  На   SecondActivity  також є кнопка, яка запускає   ThirdActivity :     Intent   intent   =   new   Intent  (  this  , ThirdActivity.class);\n   startActivity  (intent);\n  На   ThirdActivity  також є кнопка, яка повертається до першої   Activity  —   MainActivity :     Intent   intent   =   new   Intent  (  this  , MainActivity.class);\n   startActivity  (intent);\n    Якщо ми послідовно запустимо всі activity: з головної   MainActivity  запустимо   SecondActivity , з   SecondActivity  —   ThirdActivity , то в результаті у нас складе наступний стек activity:     ThirdActivity\n   SecondActivity\n   MainActivity\n  Якщо після цього з   ThirdActivity  ми захочемо звернутися до   MainActivity , то метод   startActivity()  запустить новий об'єкт   MainActivity  (а не повернеться до вже існуючого), і стек буде виглядати наступним чином:     MainActivity\n   ThirdActivity\n   SecondActivity\n   MainActivity\n  Тобто у нас буде дві незалежні копії   MainActivity . Таке положення небажано, якщо ми просто хочемо перейти до існуючої. І цей момент треба враховувати.  Якщо ми натиснемо кнопку   Back  (Назад), то поточна activity, яка знаходиться на вершині стека, буде видалена зі стека, і попередня activity виявиться на вершині стека і відновить свою роботу. І таким чином за допомогою кнопки   Back  (Назад) ми зможемо перейти до попередньої activity в стеці. Наприклад, у випадку вище, якщо ми натиснемо на кнопку Назад, то   MainActivity  на вершині стека завершить свою роботу, і на екрані почне відображатися   ThirdActivity .     ThirdActivity\n   SecondActivity\n   MainActivity\n  Однак іноді виникає необхідність керувати переходами між activity. Наприклад, у даному випадку нам небажано при натисканні на кнопку в   ThirdActivity  запускати нову копію   MainActivity  замість того, щоб просто перейти до   MainActivity , яка була запущена першою і знаходиться в самому низу стека. Розглянемо, які можливості надає нам Android.  Керування стеком activity  Для керування стеком з activity Android пропонує використовувати флаги — константи, визначені в класі   Intent . Використання певного флага дозволить змінити положення activity в стеці певним чином.  Наприклад, розглянемо попереднє завдання, коли після натискання на кнопку в   ThirdActivity  запускається новий екземпляр   MainActivity . Але ми хочемо не запускати новий екземпляр, а перейти до вже існуючого.     MainActivity\n   ThirdActivity\n   SecondActivity\n   MainActivity\n  Щоб вийти з цієї ситуації, ми можемо використати флаг   Intent.FLAG_ACTIVITY_REORDER_TO_FRONT :     Intent   intent   =   new   Intent  (  this  , MainActivity.class);\n   intent.  addFlags  (Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n   startActivity  (intent);\n  Флаг   Intent.FLAG_ACTIVITY_REORDER_TO_FRONT  переміщає   activity , до якої здійснюється перехід, на вершину стека, якщо вона вже є в стеці. І в цьому випадку після переходу з   ThirdActivity  до   MainActivity  стек буде виглядати наступним чином:     MainActivity\n   ThirdActivity\n   SecondActivity\n  Якщо ж нам просто треба перейти з   ThirdActivity  до   MainActivity , як якби ми повернулися назад за допомогою кнопки   Back , ми можемо використовувати флаги   Intent.FLAG_ACTIVITY_CLEAR_TOP  та   Intent.FLAG_ACTIVITY_SINGLE_TOP :     Intent   intent   =   new   Intent  (  this  , MainActivity.class);\n   intent.  addFlags  (Intent.FLAG_ACTIVITY_CLEAR_TOP   |   Intent.FLAG_ACTIVITY_SINGLE_TOP);\n   startActivity  (intent);\n  Флаг   Intent.FLAG_ACTIVITY_CLEAR_TOP  очищає всі   activity , крім тієї, яка запускається (якщо вона вже є в стеці). А флаг   Intent.FLAG_ACTIVITY_SINGLE_TOP  вказує, що якщо на вершині стека вже є   activity , яку потрібно запустити, то вона НЕ буде запущена знову (вона може існувати в стеці тільки в єдиному екземплярі).  У цьому випадку після переходу з   ThirdActivity  до   MainActivity  стек буде повністю очищений, і в ньому залишиться тільки одна   MainActivity .  Ще один флаг —   Intent.FLAG_ACTIVITY_NO_HISTORY  дозволить не зберігати в стеці запущену   activity . Наприклад, при запуску   SecondActivity  ми не хочемо її зберігати в стеці:     Intent   intent   =   new   Intent  (  this  , SecondActivity.class);\n   intent.  addFlags  (Intent.FLAG_ACTIVITY_NO_HISTORY);\n   startActivity  (intent);\n  У цьому випадку при переході по ланцюгу   MainActivity -> SecondActivity -> ThirdActivity  стек виглядатиме наступним чином:     MainActivity\n   ThirdActivity\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":393,"path":394,"dir":395,"title":396,"description":397,"keywords":398,"body":402},"content:1.android:3.lesson3:1.image-resources.md","/android/lesson3/image-resources","lesson3","Ресурси зображень","Одним із найбільш поширених джерел ресурсів є файли зображень. Android підтримує такі формати файлів: .png (бажаний), .jpg (допустимий), .gif (не рекомендований). Для графічних файлів у проєкті за замовчуванням створена папка res/drawable. За замовчуванням вона вже містить кілька файлів — пару файлів іконок:",[399,400,401],"Приклад:","Обробка ресурсу перед використанням","Опис","  Ресурси зображень  Одним із найбільш поширених джерел ресурсів є файли зображень. Android підтримує такі формати файлів:   .png  (бажаний),   .jpg  (допустимий),   .gif  (не рекомендований). Для графічних файлів у проєкті за замовчуванням створена папка   res/drawable . За замовчуванням вона вже містить кілька файлів — пару файлів іконок:    Під час додавання графічних файлів у цю папку для кожного з них Android створює ресурс   Drawable . Після цього ми можемо звернутися до ресурсу таким чином у коді Java:     R.drawable.імя_файла\n  Або у коді XML:     @[ім'я_пакета:]drawable/ім'я_файлу\n  Наприклад, додамо до проєкту в папку   res/drawable  якийсь файл зображення. Для цього скопіюємо на жорсткому диску будь-який файл із розширенням   .png  або   .jpg  і вставимо його в папку   res/drawable . (Для копіювання в проєкт використовується простий Copy-Paste).  Далі нам буде запропоновано вибрати папку —   drawable  або   drawable-24 . Для додавання звичайних файлів зображень оберемо   drawable .    Варто врахувати: файл зображення буде додаватися до застосунку, тим самим збільшуючи його розмір. Крім того, великі зображення негативно впливають на продуктивність. Тому краще використовувати невеликі та оптимізовані (стиснені) графічні файли.  Однак, також варто зазначити, що всі файли зображень, які додаються в цю папку, можуть автоматично оптимізуватися за допомогою утиліти   aapt  під час побудови проєкту. Це дозволяє зменшити розмір файлу без втрати якості.  Під час копіювання файлу буде запропоновано встановити для нього нове ім’я.\n   Можна змінити назву файлу, а можна залишити так як є. У моєму випадку файл називається   dubi2.png . І потім натиснемо на кнопку   Refactor . І після цього в папку   drawable  буде додано обраний нами файл зображення.\n   Для роботи із зображеннями в Android можна використовувати різні елементи, але безпосередньо для виведення зображень призначений   ImageView . Тому змінимо файл   activity_main.xml  таким чином:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  ImageView\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:src  =  \"@drawable/dubi2\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  />\n        \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  У даному випадку для відображення файлу в   ImageView  у елемента встановлюється атрибут   android:src . У його значенні вказується ім’я графічного ресурсу, яке збігається з ім’ям файлу без розширення.  Після цього можна побачити використання зображення:   У режимі   Preview  або дизайнері в Android Studio.  При запуску застосунку.     \u003C  ImageView\n       android:layout_width  =  \"wrap_content\"\n       android:layout_height  =  \"wrap_content\"\n       android:src  =  \"@drawable/назва_файлу\"   />\n    Якщо б ми створювали   ImageView  у коді Java і застосовували ресурс через код, то activity могла б виглядати так:  Приклад:     package   com.example.viewapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   androidx.constraintlayout.widget.ConstraintLayout  ;\n   import   android.os.Bundle  ;\n   import   android.widget.ImageView  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           // setContentView(R.layout.activity_main);\n   \n           ConstraintLayout   constraintLayout   =   new   ConstraintLayout  (  this  );\n           ImageView   imageView   =   new   ImageView  (  this  );\n           // застосовуємо ресурс\n           imageView.  setImageResource  (R.drawable.dubi2);\n   \n           ConstraintLayout  .  LayoutParams   layoutParams   =   new   ConstraintLayout.  LayoutParams  (\n               ConstraintLayout.LayoutParams.WRAP_CONTENT,\n               ConstraintLayout.LayoutParams.WRAP_CONTENT\n           );\n           layoutParams.leftToLeft   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           layoutParams.topToTop   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           imageView.  setLayoutParams  (layoutParams);\n           constraintLayout.  addView  (imageView);\n   \n           setContentView  (constraintLayout);\n       }\n   }\n  У даному випадку ресурс   drawable  передається безпосередньо у метод   imageView.setImageResource() , і таким чином встановлюється зображення. Результат буде той самий:     imageView.  setImageResource  (R.drawable.dubi2);\n  Обробка ресурсу перед використанням  Можливо, буде необхідність обробити ресурс перед його використанням або застосувати його в інших сценаріях. У такому разі можна отримати ресурс як об'єкт   Drawable  і потім використовувати його:     package   com.example.viewapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   androidx.constraintlayout.widget.ConstraintLayout  ;\n   import   androidx.core.content.res.ResourcesCompat  ;\n   \n   import   android.content.res.Resources  ;\n   import   android.graphics.drawable.Drawable  ;\n   import   android.os.Bundle  ;\n   import   android.widget.ImageView  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           // setContentView(R.layout.activity_main);\n           \n           ConstraintLayout   constraintLayout   =   new   ConstraintLayout  (  this  );\n           ImageView   imageView   =   new   ImageView  (  this  );\n           Resources   res   =   getResources  ();\n           Drawable   drawable   =   ResourcesCompat.  getDrawable  (res, R.drawable.dubi2,   null  );\n           // застосовуємо ресурс\n           imageView.  setImageDrawable  (drawable);\n   \n           ConstraintLayout  .  LayoutParams   layoutParams   =   new   ConstraintLayout.  LayoutParams  (\n               ConstraintLayout.LayoutParams.WRAP_CONTENT,\n               ConstraintLayout.LayoutParams.WRAP_CONTENT\n           );\n           layoutParams.leftToLeft   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           layoutParams.topToTop   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           imageView.  setLayoutParams  (layoutParams);\n           constraintLayout.  addView  (imageView);\n   \n           setContentView  (constraintLayout);\n       }\n   }\n  Опис  Для отримання ресурсу використовується метод   ResourcesCompat.getDrawable() , в який передаються:   Об'єкт   Resources .  Ідентифікатор ресурсу.  Тема (може бути   null , якщо тема не потрібна).\nУ цьому випадку тема для нас не важлива, тому передаємо значення   null . Ресурс повертається у вигляді об'єкта   Drawable :     Drawable   drawable   =   ResourcesCompat.  getDrawable  (res, R.drawable.dubi2,   null  );\n  Потім, наприклад, можна передати цей ресурс об'єкту   ImageView  через його метод   setImageDrawable() :     imageView.  setImageDrawable  (drawable);\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":404,"path":405,"dir":395,"title":406,"description":407,"keywords":408,"body":412},"content:1.android:3.lesson3:2.image-view.md","/android/lesson3/image-view","ImageView","У попередній темі було розглянуто, як виводити зображення за допомогою елемента ImageView. Тепер розглянемо деякі додаткові аспекти роботи з цим елементом.",[409,410,411],"Основні атрибути елемента ImageView:","Інші корисні атрибути:","Основні методи класу ImageView:","  ImageView  У попередній темі було розглянуто, як виводити зображення за допомогою елемента   ImageView . Тепер розглянемо деякі додаткові аспекти роботи з цим елементом.  Основні атрибути елемента   ImageView :     android:cropToPadding : при значенні   true  зображення обрізається відповідно до встановлених відступів.    android:scaleType : встановлює, як зображення буде масштабуватися відносно меж елемента   ImageView .  Для задання параметрів масштабування використовується одне із значень перерахування:     CENTER : зображення центроване без масштабування.    CENTER_CROP : зображення центроване та масштабується зі збереженням пропорцій. Якщо частина зображення не поміщається, вона обрізається.    CENTER_INSIDE : зображення центроване та масштабується зі збереженням пропорцій, але не перевищує розміри елемента   ImageView .    FIT_CENTER : зображення масштабується та центроване.    FIT_START : зображення масштабується та розташовується на початку елемента (вгорі для портретної орієнтації, зліва для альбомної).    FIT_END : зображення масштабується та розташовується в кінці елемента (внизу для портретної орієнтації, справа для альбомної).    FIT_XY : зображення масштабується без збереження пропорцій, заповнюючи весь простір   ImageView .    MATRIX : зображення масштабується з використанням матриці зображення.  Інші корисні атрибути:     android:src : ресурс зображення.    android:alpha : встановлює прозорість (значення від   0.0  - повністю прозоре, до   1.0  - повністю видиме).    android:tint : колір, який накладається на зображення.    android:tintMode : режим, який застосовується для накладення кольору на зображення.  Основні методи класу   ImageView :     Drawable getDrawable() : повертає ресурс   Drawable , який пов'язаний з цим   ImageView  (або   null , якщо ресурс не встановлено).    ImageView.ScaleType getScaleType() : повертає значення   ImageView.ScaleType , яке вказує, як зображення масштабується.    void setImageDrawable(Drawable drawable) : встановлює ресурс зображення за допомогою об'єкта   Drawable .    void setImageResource(int resId) : встановлює ресурс зображення за ідентифікатором ресурсу.    void setImageURI(Uri uri) : встановлює ресурс зображення за URI-адресою.    void setScaleType(ImageView.ScaleType scaleType) : задає спосіб масштабування зображення.    void setImageAlpha(int alpha) : задає прозорість зображення (значення від   0.0  до   1.0 ).  Наприклад, установка значення   FIT_XY  для атрибуту   android:scaleType  у файлі   activity_main.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n   \n       \u003C  ImageView\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:src  =  \"@drawable/dubi2\"\n           android:scaleType  =  \"fitXY\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  />\n   \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  В результаті зображення буде розтягнуто по вертикалі та горизонталі:   \nДля порівняння аналогічний приклад з   android:scaleType=\"center\" :\n  \nАналогічний приклад у коді java:     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   androidx.constraintlayout.widget.ConstraintLayout  ;\n   import   android.os.Bundle  ;\n   import   android.widget.ImageView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           //setContentView(R.layout.activity_main);\n    \n           ConstraintLayout   constraintLayout   =   new   ConstraintLayout  (  this  );\n           ImageView   imageView   =   new   ImageView  (  this  );\n           imageView.  setImageResource  (R.drawable.dubi2);\n           // задаєм масштабування\n           imageView.  setScaleType  (ImageView.ScaleType.FIT_XY);\n    \n           ConstraintLayout  .  LayoutParams   layoutParams   =   new   ConstraintLayout  .  LayoutParams\n                   (ConstraintLayout.LayoutParams.WRAP_CONTENT , ConstraintLayout.LayoutParams.WRAP_CONTENT);\n           layoutParams.leftToLeft   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           layoutParams.topToTop   =   ConstraintLayout.LayoutParams.PARENT_ID;\n           imageView.  setLayoutParams  (layoutParams);\n           constraintLayout.  addView  (imageView);\n    \n           setContentView  (constraintLayout);\n       }\n   }\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":414,"path":415,"dir":395,"title":416,"description":417,"keywords":418,"body":419},"content:1.android:3.lesson3:3.assets.md","/android/lesson3/assets","Зображення з папки assets","У попередніх темах зображення в проєкті розміщувалися в папці res/drawables як ресурси та виводилися в елементі ImageView. Однак зображення необов'язково повинні бути розміщені саме в цій папці. Файли також можуть знаходитися в папці assets. Розглянемо, як працювати з такими файлами зображень.",[],"  Зображення з папки assets  У попередніх темах зображення в проєкті розміщувалися в папці   res/drawables  як ресурси та виводилися в елементі   ImageView . Однак зображення необов'язково повинні бути розміщені саме в цій папці. Файли також можуть знаходитися в папці   assets . Розглянемо, як працювати з такими файлами зображень.  Спочатку додамо в проєкт папку   assets . Для цього в Android Studio натискаємо на каталог   app  і в появившомуся контекстному меню вибираємо   New -> Directory :\n  \nПотім у віконці, що з'явилося, виберемо пункт   src\\main\\assets  і натиснемо на   Enter  для її додавання в проєкт:\n  \nДодамо в цю папку якесь зображення:\n  \nНехай у файлі   activity_main.xml  буде визначено елемент   ImageView :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  ImageView\n           android:id  =  \"@+id/image\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           android:layout_margin  =  \"16dp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Завантажимо зображення з папки assets в елемент   ImageView  у   MainActivity :     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.graphics.drawable.Drawable  ;\n   import   android.os.Bundle  ;\n   import   android.widget.ImageView  ;\n    \n   import   java.io.IOException  ;\n   import   java.io.InputStream  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           ImageView   imageView   =   findViewById  (R.id.image) ;\n           String   filename   =   \"dubi2.png\"  ;\n           try  (  InputStream   inputStream   =   getApplicationContext  ().  getAssets  ().  open  (filename)){\n               Drawable   drawable   =   Drawable.  createFromStream  (inputStream,   null  );\n               imageView.  setImageDrawable  (drawable);\n               imageView.  setScaleType  (ImageView.ScaleType.FIT_XY);\n           }\n           catch   (  IOException   e  ){\n               e.  printStackTrace  ();\n           }\n       }\n   }\n  Для завантаження файлу необхідно отримати потік   InputStream  за допомогою виразу:     getApplicationContext  ().  getAssets  ().  open  (filename);\n  Виклик:     Drawable.  createFromStream  (inputStream,   null  )\n  формує об'єкт   Drawable  з вхідного потоку.  Метод:     imageView.  setImageDrawable  (d)\n  завантажує   Drawable  в   ImageView .    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":421,"path":422,"dir":395,"title":423,"description":424,"keywords":425,"body":427},"content:1.android:3.lesson3:4.list-view-array-adapter.md","/android/lesson3/list-view-array-adapter","ListView і ArrayAdapter","Android представляє широку палітру елементів, які представляють списки. Усі вони є спадкоємцями класу android.widget.AdapterView. Це такі віджети як ListView, GridView, Spinner. Вони можуть виступати контейнерами для інших елементів керування.",[426],"Пояснення конструктора ArrayAdapter:","  ListView і ArrayAdapter  Android представляє широку палітру елементів, які представляють   списки . Усі вони є спадкоємцями класу   android.widget.AdapterView . Це такі віджети як   ListView ,   GridView ,   Spinner . Вони можуть виступати контейнерами для інших елементів керування.    При роботі зі списками ми маємо справу з трьома компонентами:    Візуальний елемент  або віджет, який на екрані представляє список, наприклад:    ListView   GridView  Ці віджети відображають дані.   Джерело даних  — масив, об'єкт   ArrayList , база даних тощо, в якому зберігаються самі відображувані дані.   Адаптер  — спеціальний компонент, який пов'язує джерело даних з віджетом списку.  Одним із найпростіших і поширених елементів списку є   віджет   ListView . Розглянемо зв'язок елемента   ListView  з джерелом даних за допомогою одного з таких адаптерів — класу   ArrayAdapter .   ArrayAdapter  — це найпростіший адаптер, який пов'язує масив даних з набором елементів   TextView , з яких, наприклад, може складатися   ListView .  Тобто в даному випадку джерелом даних виступає масив об'єктів.   ArrayAdapter  викликає у кожного об'єкта метод   toString()  для приведення до рядкового вигляду і отриману строку встановлює в елемент   TextView .  Подивимося на приклад. Отже, розмітка додатку може виглядати так:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n        \n       \u003C  ListView\n           android:id  =  \"@+id/countriesList\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  >\n       \u003C/  ListView  >\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Тут також визначений елемент   ListView , який буде відображати список об'єктів. Тепер перейдемо до коду   activity  і зв'яжемо   ListView  через   ArrayAdapter  з деякими даними:     package   com.example.listapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.widget.ArrayAdapter  ;\n   import   android.widget.ListView  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       // Набір даних, які зв'яжемо зі списком\n       String  [] countries   =   {   \"Бразилія\"  ,   \"Аргентина\"  ,   \"Колумбія\"  ,   \"Чилі\"  ,   \"Уругвай\"  };\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n   \n           // Отримуємо елемент ListView\n           ListView   countriesList   =   findViewById  (R.id.countriesList);\n   \n           // Створюємо адаптер\n           ArrayAdapter  \u003C  String  > adapter   =   new   ArrayAdapter  (  this  ,\n                   android.R.layout.simple_list_item_1, countries);\n   \n           // Встановлюємо адаптер для списку\n           countriesList.  setAdapter  (adapter);\n       }\n   }\n  Тут спочатку отримуємо за id елемент   ListView  і потім створюємо для нього адаптер.  Пояснення конструктора   ArrayAdapter :    this : поточний об'єкт   activity .   android.R.layout.simple_list_item_1 : файл розмітки списку, який фреймворк надає за замовчуванням. Він знаходиться в папці Android SDK за шляхом   platforms/[android-номер_версії]/data/res/layout . Якщо нас не влаштовує стандартна розмітка списку, ми можемо створити свою і потім у коді змінити id на id потрібної нам розмітки.   countries : масив даних. Тут не обов'язково вказувати саме масив, це може бути список   ArrayList\u003CT> .  В кінці необхідно встановити для   ListView  адаптер за допомогою методу   setAdapter() .\nУ підсумку ми отримаємо таке відображення:    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":429,"path":430,"dir":395,"title":431,"description":432,"keywords":433,"body":434},"content:1.android:3.lesson3:5.string-array-list-view-resource.md","/android/lesson3/string-array-list-view-resource","Ресурс string-array і ListView","У попередній темі було розглянуто, як виводити масив рядків за допомогою ArrayAdapter в ListView. При цьому масив рядків визначався програмно в коді Java. Однак такий масив рядків значно зручніше було б зберігати в XML-файлі як ресурс.",[],"  Ресурс string-array і ListView  У попередній темі було розглянуто, як виводити масив рядків за допомогою   ArrayAdapter  в   ListView . При цьому масив рядків визначався програмно в коді Java. Однак такий масив рядків значно зручніше було б зберігати в XML-файлі як ресурс.  Ресурси масивів рядків представляють елемент типу   string-array . Вони можуть знаходитися в каталозі   res/values  в XML-файлі з будь-яким ім'ям.  Оголошення масивів рядків має наступний синтаксис:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  resources  >\n       \u003C  string-array   name  =  \"ім'я_масиву_рядків\"  >\n           \u003C  item  >елемент\u003C/  item  >\n       \u003C/  string-array  >\n   \u003C/  resources  >\n  Масив рядків задається за допомогою елемента   \u003Cstring-array> , атрибут   name  якого може мати будь-яке значення, по якому потім будуть звертатися до цього масиву. Усі елементи масиву представляють набір значень   \u003Citem> .  Наприклад, додамо до папки   res/values  новий файл. Для цього натискаємо правою кнопкою миші на цей каталог і в з'явившемся меню вибираємо пункт   New -> Value Resource file :\n   У вікні, що з'явилося, назвемо файл як   countries :\n   Після додавання файлу в папку   res/values , змінемо його вміст наступним чином:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  resources  >\n       \u003C  string-array   name  =  \"countries\"  >\n           \u003C  item  >Бразилія\u003C/  item  >\n           \u003C  item  >Аргентина\u003C/  item  >\n           \u003C  item  >Колумбія\u003C/  item  >\n           \u003C  item  >Чилі\u003C/  item  >\n           \u003C  item  >Уругвай\u003C/  item  >\n       \u003C/  string-array  >\n   \u003C/  resources  >\n  У файлі розмітки   activity_main.xml  залишається визначення елемента   ListView :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n        \n       \u003C  ListView\n           android:id  =  \"@+id/countriesList\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  >\n       \u003C/  ListView  >\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Тепер зв'яжемо ресурс і   ListView  в коді   MainActivity :     package   com.example.listapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n   import   android.widget.ArrayAdapter  ;\n   import   android.widget.ListView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           // отримуємо елемент ListView\n           ListView   countriesList   =   findViewById  (R.id.countriesList);\n    \n           // отримуємо ресурс\n           String  [] countries   =   getResources  ().  getStringArray  (R.array.countries);\n    \n           // створюємо адаптер\n           ArrayAdapter  \u003C  String  > adapter   =   new   ArrayAdapter  (  this  ,\n                   android.R.layout.simple_list_item_1, countries);\n    \n           // встановлюємо для списку адаптер\n           countriesList.  setAdapter  (adapter);\n       }\n   }\n  Для отримання ресурсу в коді Java застосовується вираз   R.array.назва_ресурсу .  Нам не обов'язково додавати список рядків в   ListView  програмно. У цього елемента є атрибут   entries , який може приймати ресурс   string-array :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n        \n       \u003C  ListView\n           android:id  =  \"@+id/countriesList\"\n            \n           android:entries  =  \"@array/countries\"\n            \n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  >\n       \u003C/  ListView  >\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  В цьому випадку код   MainActivity  ми можемо скоротити до стандартного:     package   com.example.listapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n   }\n  А результат буде той самий:\n   html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":436,"path":437,"dir":395,"title":438,"description":439,"keywords":440,"body":442},"content:1.android:3.lesson3:6.select-item.md","/android/lesson3/select-item","Вибір елемента в ListView","У попередніх темах ми розглядали, як завантажувати дані в ListView, зв'язувати його з джерелом даних. Але крім простого виведення списку елементів, ListView дозволяє вибирати елемент і обробляти його вибір. Розглянемо, як це зробити. Ось розмітка в файлі activity_main.xml:",[441],"Множинний вибір у списку","  Вибір елемента в ListView  У попередніх темах ми розглядали, як завантажувати дані в   ListView , зв'язувати його з джерелом даних. Але крім простого виведення списку елементів,   ListView  дозволяє вибирати елемент і обробляти його вибір. Розглянемо, як це зробити. Ось розмітка в файлі   activity_main.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  TextView\n           android:id  =  \"@+id/selection\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"22sp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n       \n       \u003C  ListView\n           android:id  =  \"@+id/countriesList\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/selection\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"  >\n       \u003C/  ListView  >\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Тепер зв'яжемо список   ListView  з джерелом даних і додамо слухача для обробки натискання на елемент списку:     package   com.example.listapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.AdapterView  ;\n   import   android.widget.ArrayAdapter  ;\n   import   android.widget.ListView  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       String  [] countries   =   {   \"Бразилія\"  ,   \"Аргентина\"  ,   \"Колумбія\"  ,   \"Чилі\"  ,   \"Уругвай\"  };\n       \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           // отримуємо елемент TextView\n           TextView   selection   =   findViewById  (R.id.selection);\n           // отримуємо елемент ListView\n           ListView   countriesList   =   findViewById  (R.id.countriesList);\n           // створюємо адаптер\n           ArrayAdapter  \u003C  String  > adapter   =   new   ArrayAdapter  (  this  ,\n                   android.R.layout.simple_list_item_1, countries);\n           // встановлюємо для списку адаптер\n           countriesList.  setAdapter  (adapter);\n           // додаємо слухача для списку\n           countriesList.  setOnItemClickListener  (  new   AdapterView.  OnItemClickListener  (){\n               @  Override\n               public   void   onItemClick  (  AdapterView  \u003C?>   parent,   View   v,   int   position,   long   id)\n               {\n                   // за позицією отримуємо вибраний елемент\n                   String   selectedItem   =   countries[position];\n                   // встановлюємо текст елемента TextView\n                   selection.  setText  (selectedItem);\n               }\n           });\n       }\n   }\n  Отже, метод   setAdapter  зв'язує елемент   ListView  з визначеним адаптером. Далі, для обробки вибору елемента списку, встановлюється слухач   OnItemClickListener . Цей слухач має один метод   onItemClick , через параметри якого ми можемо отримати вибраний елемент і супутні дані. Так, він приймає наступні параметри:    parent : натиснутий елемент   AdapterView  (в ролі якого в даному випадку виступає наш елемент   ListView )   view : натиснутий віджет всередині   AdapterView   position : індекс натискання віджету всередині   AdapterView   id : ідентифікатор рядка натиснутого елемента  Використовуючи ці параметри, ми можемо різними способами отримати вибраний елемент.  Наприклад, у цьому випадку, отримуючи індекс натиснутого віджету, який відповідає індексу елемента в масиві рядків, ми можемо встановити відповідний елемент у масиві рядків і таким чином отримати його текст:     countriesList.  setOnItemClickListener  (  new   AdapterView.  OnItemClickListener  (){\n       @  Override\n       public   void   onItemClick  (  AdapterView  \u003C?>   parent,   View   v,   int   position,   long   id)\n       {\n           // за позицією отримуємо вибраний елемент\n           String   selectedItem   =   countries[position];\n           // встановлення тексту елемента TextView\n           selection.  setText  (selectedItem);\n       }\n   });\n   \nТакож ми можемо отримати виділений елемент з AdapterView, який передається як перший параметр -   AdapterView\u003C?> parent . У цьому випадку ми знаємо, що кожен елемент у AdapterView фактично представляє рядок або об'єкт   String , тому в цьому випадку можна отримати виділений елемент таким чином:     countriesList.  setOnItemClickListener  (  new   AdapterView.  OnItemClickListener  (){\n       @  Override\n       public   void   onItemClick  (  AdapterView  \u003C?>   parent,   View   v,   int   position,   long   id)\n       {\n           // отримуємо вибраний елемент\n           String   selectedItem   =   (String)parent.  getItemAtPosition  (position);\n           // встановлення тексту елемента TextView\n           selection.  setText  (selectedItem);\n       }\n   });\n  Метод   getItemAtPosition  повертає виділений елемент за індексом. Це може бути корисно, якщо ми використовуємо як джерело даних не масив рядків, створений у коді Java, а, наприклад, ресурс   \u003Cstring-array> , заданий у файлі xml.  По-третє, ми можемо використати виділений елемент, який передається як другий параметр -   View v . У цьому випадку адаптер використовує в якості типу розмітки ресурс -   android.R.layout.simple_list_item_1 , а це означає, що виділений елемент є елементом   TextView , в якому виводиться цей текст. Тому в цьому випадку ми також могли б отримати виділений елемент так:     countriesList.  setOnItemClickListener  (  new   AdapterView.  OnItemClickListener  (){\n       @  Override\n       public   void   onItemClick  (  AdapterView  \u003C?>   parent,   View   v,   int   position,   long   id)\n       {\n           // отримуємо вибраний елемент\n           TextView   textView   =   (TextView) v;\n           String   selectedItem   =   (String)textView.  getText  ();\n           // встановлення тексту елемента TextView\n           selection.  setText  (selectedItem);\n           // або так\n           // selection.setText(textView.getText());\n       }\n   });\n  Множинний вибір у списку  Іноді потрібно вибрати не один елемент, як за замовчуванням, а кілька. Для цього, по-перше, у розмітці списку треба встановити атрибут   android:choiceMode=\"multipleChoice\" :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n   \n       \u003C  TextView\n           android:id  =  \"@+id/selection\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"22sp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n           \n       \u003C  ListView\n           android:id  =  \"@+id/countriesList\"\n           android:choiceMode  =  \"multipleChoice\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/selection\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"  >\n       \u003C/  ListView  >\n   \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Тепер визначимо в коді   MainActivity  обробку вибору елементів списку:     package   com.example.listapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.util.SparseBooleanArray  ;\n   import   android.view.View  ;\n   import   android.widget.AdapterView  ;\n   import   android.widget.ArrayAdapter  ;\n   import   android.widget.ListView  ;\n   import   android.widget.TextView  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       String  [] countries   =   {   \"Бразилія\"  ,   \"Аргентина\"  ,   \"Колумбія\"  ,   \"Чилі\"  ,   \"Уругвай\"  };\n       \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n   \n           // отримуємо елемент TextView\n           TextView   selection   =   findViewById  (R.id.selection);\n           // отримуємо елемент ListView\n           ListView   countriesList   =   findViewById  (R.id.countriesList);\n           // створюємо адаптер\n           ArrayAdapter  \u003C  String  > adapter   =   new   ArrayAdapter  (  this  ,\n                   android.R.layout.simple_list_item_multiple_choice, countries);\n           // встановлюємо для списку адаптер\n           countriesList.  setAdapter  (adapter);\n           // додаємо для списку слухач\n           countriesList.  setOnItemClickListener  (  new   AdapterView.  OnItemClickListener  (){\n               @  Override\n               public   void   onItemClick  (  AdapterView  \u003C?>   parent,   View   v,   int   position,   long   id)\n               {\n                   SparseBooleanArray   selected   =   countriesList.  getCheckedItemPositions  ();\n   \n                   String   selectedItems   =   \"\"  ;\n                   for   (  int   i   =   0  ; i   \u003C   countries.length; i  ++  ) {\n                       if   (selected.  get  (i))\n                           selectedItems   +=   countries[i]   +   \",\"  ;\n                   }\n                   // встановлення тексту елемента TextView\n                   selection.  setText  (  \"Вибрано: \"   +   selectedItems);\n               }\n           });\n       }\n   }\n  Ресурс   android.R.layout.simple_list_item_multiple_choice  представляє стандартну розмітку, надану фреймвокем, для створення списку з множинним вибором.  При виборі елементів ми отримуємо всі вибрані позиції в об'єкті   SparseBooleanArray , потім проходимо по всьому масиву, і якщо позиція елемента в масиві є в   SparseBooleanArray , тобто вона відмічена, то додаємо відмічений елемент у рядок.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":444,"path":445,"dir":395,"title":446,"description":447,"keywords":448,"body":449},"content:1.android:3.lesson3:7.add-remove-item.md","/android/lesson3/add-remove-item","Додавання та видалення в ArrayAdapter і ListView","Після прив'язки ListView до джерела даних через адаптер, ми можемо працювати з даними — додавати, видаляти, змінювати тільки через адаптер. ListView слугує лише для відображення даних.",[96],"  Додавання та видалення в ArrayAdapter і ListView  Після прив'язки   ListView  до джерела даних через адаптер, ми можемо працювати з даними — додавати, видаляти, змінювати тільки через адаптер.   ListView  слугує лише для відображення даних.  Для керування даними ми можемо використовувати методи адаптера або безпосередньо джерело даних. Наприклад, клас   ArrayAdapter  надає наступні методи для керування даними:    void add(T object) : додає елемент   object  в кінець масиву   void addAll(T... items) : додає всі елементи   items  в кінець масиву   void addAll(Collection\u003C? extends T> collection) : додає колекцію елементів   collection  в кінець масиву   void clear() : видаляє всі елементи зі списку   void insert(T object, int index) : додає елемент   object  в масив по індексу   index   void remove(T object) : видаляє елемент   object  з масиву  Однак, після застосування вищезазначених методів, зміни стосуватимуться лише масиву, який є джерелом даних. Щоб синхронізувати зміни з елементом   ListView , потрібно викликати у адаптера метод   notifyDataSetChanged() .  Приклад  Припустимо, у файлі   activity_main.xml  визначені наступні елементи:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n           \n       \u003C  EditText\n           android:id  =  \"@+id/userName\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           app:layout_constraintHorizontal_weight  =  \"4\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toLeftOf  =  \"@+id/add\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n           \n       \u003C  Button\n           android:id  =  \"@+id/add\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           app:layout_constraintHorizontal_weight  =  \"1\"\n           android:text  =  \"+\"\n           android:onClick  =  \"add\"\n           app:layout_constraintRight_toLeftOf  =  \"@+id/remove\"\n           app:layout_constraintLeft_toRightOf  =  \"@+id/userName\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  />\n           \n       \u003C  Button\n           android:id  =  \"@+id/remove\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           app:layout_constraintHorizontal_weight  =  \"1\"\n           android:text  =  \"-\"\n           android:onClick  =  \"remove\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintLeft_toRightOf  =  \"@+id/add\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"   />\n           \n       \u003C  ListView\n           android:id  =  \"@+id/usersList\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           android:choiceMode  =  \"multipleChoice\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/userName\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"  >\n       \u003C/  ListView  >\n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Для відображення списку використовується   ListView  з можливістю множинного вибору елементів. Для додавання та видалення визначено дві кнопки. Для введення нового об'єкта в список призначено поле   EditText .     package   com.example.listapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.AdapterView  ;\n   import   android.widget.ArrayAdapter  ;\n   import   android.widget.EditText  ;\n   import   android.widget.ListView  ;\n   import   java.util.ArrayList  ;\n   import   java.util.Collections  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       ArrayList  \u003C  String  > users   =   new   ArrayList  \u003C  String  >();\n       ArrayList  \u003C  String  > selectedUsers   =   new   ArrayList  \u003C  String  >();\n       ArrayAdapter  \u003C  String  > adapter;\n       ListView   usersList;\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n   \n           // додаємо початкові елементи\n           Collections.  addAll  (users,   \"Tom\"  ,   \"Bob\"  ,   \"Sam\"  ,   \"Alice\"  );\n   \n           // отримуємо елемент ListView\n           usersList   =   findViewById  (R.id.usersList);\n   \n           // створюємо адаптер\n           adapter   =   new   ArrayAdapter  (  this  , android.R.layout.simple_list_item_multiple_choice, users);\n   \n           // встановлюємо для списку адаптер\n           usersList.  setAdapter  (adapter);\n   \n           // обробка встановлення та зняття позначок в списку\n           usersList.  setOnItemClickListener  (  new   AdapterView.  OnItemClickListener  (){\n               @  Override\n               public   void   onItemClick  (  AdapterView  \u003C?>   parent,   View   v,   int   position,   long   id) {\n                   // отримуємо натиснутий елемент\n                   String   user   =   adapter.  getItem  (position);\n                   if  (usersList.  isItemChecked  (position))\n                       selectedUsers.  add  (user);\n                   else\n                       selectedUsers.  remove  (user);\n               }\n           });\n       }\n   \n       public   void   add  (  View   view  ) {\n           EditText   userName   =   findViewById  (R.id.userName);\n           String   user   =   userName.  getText  ().  toString  ();\n           if  (  !  user.  isEmpty  ()){\n               adapter.  add  (user);\n               userName.  setText  (  \"\"  );\n               adapter.  notifyDataSetChanged  ();\n           }\n       }\n   \n       public   void   remove  (  View   view  ) {\n           // отримуємо та видаляємо виділені елементи\n           for  (  int   i   =   0  ; i   \u003C   selectedUsers.  size  (); i  ++  ){\n               adapter.  remove  (selectedUsers.  get  (i));\n           }\n   \n           // знімаємо всі раніше встановлені позначки\n           usersList.  clearChoices  ();\n   \n           // очищаємо масив вибраних елементів\n           selectedUsers.  clear  ();\n   \n           adapter.  notifyDataSetChanged  ();\n       }\n   }\n  З додаванням все відносно просто: отримуємо введену строку та додаємо її в список за допомогою методу   adapter.add() . Щоб оновити   ListView  після додавання, викликаємо метод   adapter.notifyDataSetChanged() .  Для видалення створюється додатковий список   selectedUsers , який містить виділені елементи. Для отримання виділених елементів та додавання їх у список використовується слухач   AdapterView.OnItemClickListener . Метод   onItemClick()  цього слухача викликається при встановленні або знятті позначки з елемента, тобто при будь-якому натисканні на елемент.  При натисканні на кнопку видалення, ми проходимо по списку виділених елементів і викликаємо для кожного з них метод   adapter.remove() .     html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":451,"path":452,"dir":395,"title":453,"description":454,"keywords":455,"body":457},"content:1.android:3.lesson3:8.extending-lists.md","/android/lesson3/extending-lists","Розширення списків і створення адаптера","Традиційні списки ListView, які використовують стандартні адаптери ArrayAdapter, чудово працюють з масивами рядків. Однак частіше ми будемо стикатися з більш складними структурами списків, де один елемент представляє не одну строку, а кілька рядків, зображень та інших компонентів.",[456],"Створення складного списку з використанням кастомного адаптера","  Розширення списків і створення адаптера  Традиційні списки   ListView , які використовують стандартні адаптери   ArrayAdapter , чудово працюють з масивами рядків. Однак частіше ми будемо стикатися з більш складними структурами списків, де один елемент представляє не одну строку, а кілька рядків, зображень та інших компонентів.  Для створення складного списку нам потрібно перевизначити один із використовуваних адаптерів. Оскільки, як правило, використовується   ArrayAdapter , то саме його ми і перевизначимо.  Але на початку визначимо модель, дані якої будуть відображатися в списку. Для цього додамо до того ж каталогу, де знаходиться клас   MainActivity , новий клас.     package   com.example.listapp  ;\n    \n   public   class   State   {\n    \n       private   String   name;\n       private   String   capital;\n       private   int   flagResource;\n    \n       public   State  (  String   name  ,   String   capital  ,   int   flag  ){\n    \n           this  .name  =  name;\n           this  .capital  =  capital;\n           this  .flagResource  =  flag;\n       }\n    \n       public   String   getName  () {\n           return   this  .name;\n       }\n    \n       public   void   setName  (  String   name  ) {\n           this  .name   =   name;\n       }\n    \n       public   String   getCapital  () {\n           return   this  .capital;\n       }\n    \n       public   void   setCapital  (  String   capital  ) {\n           this  .capital   =   capital;\n       }\n    \n       public   int   getFlagResource  () {\n           return   this  .flagResource;\n       }\n    \n       public   void   setFlagResource  (  int   flagResource  ) {\n           this  .flagResource   =   flagResource;\n       }\n   }\n  Створення складного списку з використанням кастомного адаптера  Цей клас зберігає два рядкових поля — назву держави та її столицю, а також числове поле, яке вказує на ресурс зображення з папки   drawable , що відображатиме прапор держави.  Далі додамо в папку   res/layout  новий файл   list_item.xml , який представлятиме розмітку одного елемента в списку:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"wrap_content\"  >\n       \n       \u003C  ImageView\n           android:id  =  \"@+id/flag\"\n           android:layout_width  =  \"70dp\"\n           android:layout_height  =  \"50dp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toLeftOf  =  \"@+id/name\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"   />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/name\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_marginLeft  =  \"16dp\"\n           android:text  =  \"Название\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintLeft_toRightOf  =  \"@+id/flag\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toTopOf  =  \"@+id/capital\"   />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/capital\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_marginLeft  =  \"16dp\"\n           android:text  =  \"Столица\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintLeft_toRightOf  =  \"@+id/flag\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/name\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Кожен елемент буде мати зображення у вигляді   ImageView  та два компоненти   TextView  для відображення назви та столиці держави.  Після цього додамо до каталогу, де знаходяться класи   MainActivity  та   State , новий клас, який називатимемо   StateAdapter :     package   com.example.listapp  ;\n   \n   import   android.content.Context  ;\n   import   android.view.LayoutInflater  ;\n   import   android.view.View  ;\n   import   android.view.ViewGroup  ;\n   import   android.widget.ArrayAdapter  ;\n   import   android.widget.ImageView  ;\n   import   android.widget.TextView  ;\n   \n   import   java.util.List  ;\n   \n   public   class   StateAdapter   extends   ArrayAdapter  \u003C  State  > {\n   \n       private   LayoutInflater   inflater;\n       private   int   layout;\n       private   List  \u003C  State  > states;\n   \n       public   StateAdapter  (  Context   context  ,   int   resource  ,   List  \u003C  State  >   states  ) {\n           super  (context, resource, states);\n           this  .states   =   states;\n           this  .layout   =   resource;\n           this  .inflater   =   LayoutInflater.  from  (context);\n       }\n   \n       public   View   getView  (  int   position  ,   View   convertView  ,   ViewGroup   parent  ) {\n   \n           View   view   =   inflater.  inflate  (  this  .layout, parent,   false  );\n   \n           ImageView   flagView   =   view.  findViewById  (R.id.flag);\n           TextView   nameView   =   view.  findViewById  (R.id.name);\n           TextView   capitalView   =   view.  findViewById  (R.id.capital);\n   \n           State   state   =   states.  get  (position);\n   \n           flagView.  setImageResource  (state.  getFlagResource  ());\n           nameView.  setText  (state.  getName  ());\n           capitalView.  setText  (state.  getCapital  ());\n   \n           return   view;\n       }\n   }\n  Все взаємодія зі списком буде відбуватися через клас   StateAdapter . У конструкторі   StateAdapter  нам потрібно передати три параметри:    Контекст , в якому використовується клас (як правило, це клас   Activity ).   Ресурс розмітки інтерфейсу , який буде використовуватися для створення одного елемента в   ListView .   Набір об'єктів , які будуть відображатися в   ListView .  У конструкторі   StateAdapter  ми отримуємо ресурс розмітки та набір об'єктів і зберігаємо їх у окремі змінні. Також для створення об'єкта   View  по отриманому ресурсу розмітки нам потрібен об'єкт   LayoutInflater , який зберігається у змінній.  Метод   getView()  відповідає за відображення елемента списку. Цей метод приймає три параметри:    position : позиція елемента в адаптері, для якого створюється представлення.   convertView : старе представлення елемента, яке при наявності використовує   ListView  для оптимізації.   parent : батьківський компонент для представлення елемента.  В даному випадку за допомогою об'єкта   LayoutInflater  створюємо об'єкт   View  для кожного окремого елемента в списку:     View   view   =   inflater.  inflate  (  this  .layout, parent,   false  );\n  З створеного об'єкта   View  отримуємо елементи   ImageView  та   TextView  за їхнім   id :     ImageView   flagView   =   (ImageView) view.  findViewById  (R.id.flag);\n   TextView   nameView   =   (TextView) view.  findViewById  (R.id.name);\n   TextView   capitalView   =   (TextView) view.  findViewById  (R.id.capital);\n  Далі, використовуючи параметр   position , отримуємо об'єкт   State , для якого створюється розмітка:     State   state   =   states.  get  (position);\n  Потім заповнюємо елементи   ImageView  та   TextView  з отриманого об'єкта   State :     flagView.  setImageResource  (state.  getFlagResource  ());\n   nameView.  setText  (state.  getName  ());\n   capitalView.  setText  (state.  getCapital  ());\n  І в кінці повертаємо створений елемент   View  для відображення об'єкта   State :     return   view;\n  Для використання зображень додамо в папку   res/drawable  кілька зображень, у моєму випадку це п'ять зображень прапорів держав. У підсумку проєкт матиме такий вигляд:    У файлі   activity_main.xml  визначимо   ListView , у який будуть завантажуватися дані:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n       \u003C  ListView\n           android:id  =  \"@+id/countriesList\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  А у файлі   MainActivity  з'єднаємо   StateAdapter  з   ListView :     package   com.example.listapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.AdapterView  ;\n   import   android.widget.ListView  ;\n   import   android.widget.Toast  ;\n   import   java.util.ArrayList  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       ArrayList  \u003C  State  > states   =   new   ArrayList  \u003C  State  >();\n       ListView   countriesList;\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n           \n           // початкова ініціалізація списку\n           setInitialData  ();\n           \n           // отримуємо елемент ListView\n           countriesList   =   findViewById  (R.id.countriesList);\n           \n           // створюємо адаптер\n           StateAdapter   stateAdapter   =   new   StateAdapter  (  this  , R.layout.list_item, states);\n           \n           // встановлюємо адаптер\n           countriesList.  setAdapter  (stateAdapter);\n           \n           // слухач вибору в списку\n           AdapterView  .  OnItemClickListener   itemListener   =   new   AdapterView.  OnItemClickListener  () {\n               @  Override\n               public   void   onItemClick  (  AdapterView  \u003C?>   parent,   View   v,   int   position,   long   id) {\n                   // отримуємо вибраний пункт\n                   State   selectedState   =   (State) parent.  getItemAtPosition  (position);\n                   Toast.  makeText  (  getApplicationContext  (),   \"Був обраний пункт \"   +   selectedState.  getName  (),\n                           Toast.LENGTH_SHORT).  show  ();\n               }\n           };\n           \n           countriesList.  setOnItemClickListener  (itemListener);\n       }\n   \n       private   void   setInitialData  () {\n           states.  add  (  new   State  (  \"Бразилія\"  ,   \"Бразилія\"  , R.drawable.brazilia));\n           states.  add  (  new   State  (  \"Аргентина\"  ,   \"Буенос-Айрес\"  , R.drawable.argentina));\n           states.  add  (  new   State  (  \"Колумбія\"  ,   \"Богота\"  , R.drawable.columbia));\n           states.  add  (  new   State  (  \"Уругвай\"  ,   \"Монтевідео\"  , R.drawable.uruguai));\n           states.  add  (  new   State  (  \"Чилі\"  ,   \"Сантьяго\"  , R.drawable.chile));\n       }\n   }\n  Як джерело даних тут використовується клас   ArrayList , який отримує дані в методі   setInitialData . Кожному додаваному об'єкту   State  у списку передається назва держави, її столиця та ресурс зображення з папки   res/drawable , яке представляє прапор держави.  При створенні адаптера йому передається раніше створений ресурс розмітки   list_item.xml  та список   states :     StateAdapter   stateAdapter   =   new   StateAdapter  (  this  , R.layout.list_item, states);\n    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":459,"path":460,"dir":395,"title":461,"description":462,"keywords":463,"body":464},"content:1.android:3.lesson3:9.optimizing-the-adapter.md","/android/lesson3/optimizing-the-adapter","Оптимізація адаптера та View Holder","У минулій темі було створено кастомний адаптер, який давав змогу працювати зі складними списками об'єктів:",[],"  Оптимізація адаптера та View Holder  У минулій темі було створено кастомний адаптер, який давав змогу працювати зі складними списками об'єктів:     import   android.content.Context  ;\n   import   android.view.LayoutInflater  ;\n   import   android.view.View  ;\n   import   android.view.ViewGroup  ;\n   import   android.widget.ArrayAdapter  ;\n   import   android.widget.ImageView  ;\n   import   android.widget.TextView  ;\n    \n   import   java.util.List  ;\n    \n   public   class   StateAdapter   extends   ArrayAdapter  \u003C  State  > {\n    \n       private   LayoutInflater   inflater;\n       private   int   layout;\n       private   List  \u003C  State  > states;\n    \n       public   StateAdapter  (  Context   context  ,   int   resource  ,   List  \u003C  State  >   states  ) {\n           super  (context, resource, states);\n           this  .states   =   states;\n           this  .layout   =   resource;\n           this  .inflater   =   LayoutInflater.  from  (context);\n       }\n       public   View   getView  (  int   position  ,   View   convertView  ,   ViewGroup   parent  ) {\n    \n           View   view  =  inflater.  inflate  (  this  .layout, parent,   false  );\n    \n           ImageView   flagView   =   view.  findViewById  (R.id.flag);\n           TextView   nameView   =   view.  findViewById  (R.id.name);\n           TextView   capitalView   =   view.  findViewById  (R.id.capital);\n    \n           State   state   =   states.  get  (position);\n    \n           flagView.  setImageResource  (state.  getFlagResource  ());\n           nameView.  setText  (state.  getName  ());\n           capitalView.  setText  (state.  getCapital  ());\n    \n           return   view;\n       }\n   }\n  Цей адаптер має один великий мінус — при прокручуванні в   ListView , якщо в списку дуже багато об'єктів, то для кожного елемента, коли він потрапить в зону видимості, буде повторно викликатися метод   getView , в якому буде знову створюватися новий об'єкт   View . Це збільшуватиме споживання пам'яті та знижуватиме продуктивність. Тому оптимізуємо код методу   getView :     public   View   getView  (  int   position,   View   convertView,   ViewGroup   parent) {\n    \n       if   (convertView   ==   null  ) {\n           convertView   =   inflater.  inflate  (  this  .layout, parent,   false  );\n       }\n        \n       ImageView   flagView   =   convertView.  findViewById  (R.id.flag);\n       TextView   nameView   =   convertView.  findViewById  (R.id.name);\n       TextView   capitalView   =   convertView.  findViewById  (R.id.capital);\n    \n       State   state   =   states.  get  (position);\n    \n       flagView.  setImageResource  (state.  getFlagResource  ());\n       nameView.  setText  (state.  getName  ());\n       capitalView.  setText  (state.  getCapital  ());\n    \n       return   convertView;\n   }\n  Параметр   convertView  вказує на елемент   View , який використовується для об'єкта в списку по позиції   position . Якщо раніше вже був створений   View  для цього об'єкта, то параметр   convertView  вже містить певне значення, яке ми можемо використовувати.  В цьому випадку ми будемо повторно використовувати вже створені об'єкти і підвищимо продуктивність, однак цей код можна ще більше оптимізувати. Справа в тому, що отримання елементів за   id  також є відносно затратною операцією. Тому далі оптимізуємо код   StateAdapter , змінивши його наступним чином:     import   android.content.Context  ;\n   import   android.view.LayoutInflater  ;\n   import   android.view.View  ;\n   import   android.view.ViewGroup  ;\n   import   android.widget.ArrayAdapter  ;\n   import   android.widget.ImageView  ;\n   import   android.widget.TextView  ;\n    \n   import   java.util.List  ;\n    \n   public   class   StateAdapter   extends   ArrayAdapter  \u003C  State  > {\n    \n       private   LayoutInflater   inflater;\n       private   int   layout;\n       private   List  \u003C  State  > states;\n    \n       public   StateAdapter  (  Context   context  ,   int   resource  ,   List  \u003C  State  >   states  ) {\n           super  (context, resource, states);\n           this  .states   =   states;\n           this  .layout   =   resource;\n           this  .inflater   =   LayoutInflater.  from  (context);\n       }\n   \n       public   View   getView  (  int   position  ,   View   convertView  ,   ViewGroup   parent  ) {\n    \n           ViewHolder   viewHolder;\n           if   (convertView   ==   null  ) {\n               convertView   =   inflater.  inflate  (  this  .layout, parent,   false  );\n               viewHolder   =   new   ViewHolder  (convertView);\n               convertView.  setTag  (viewHolder);\n           }   else   {\n               viewHolder   =   (ViewHolder) convertView.  getTag  ();\n           }\n   \n           State   state   =   states.  get  (position);\n    \n           viewHolder.imageView.  setImageResource  (state.  getFlagResource  ());\n           viewHolder.nameView.  setText  (state.  getName  ());\n           viewHolder.capitalView.  setText  (state.  getCapital  ());\n    \n           return   convertView;\n       }\n   \n       private   class   ViewHolder   {\n           final   ImageView   imageView;\n           final   TextView   nameView, capitalView;\n   \n           ViewHolder  (  View   view  ) {\n               imageView   =   view.  findViewById  (R.id.flag);\n               nameView   =   view.  findViewById  (R.id.name);\n               capitalView   =   view.  findViewById  (R.id.capital);\n           }\n       }\n   }\n  Для зберігання посилань на використані елементи   ImageView  і   TextView  визначений внутрішній приватний клас   ViewHolder , який в конструкторі отримує об'єкт   View , що містить   ImageView  та   TextView .  У методі   getView , якщо   convertView  рівний   null  (тобто якщо раніше для об'єкта не створена розмітка), створюємо об'єкт   ViewHolder , який зберігаємо в тегу   convertView :     convertView.  setTag  (viewHolder);\n  Якщо ж розмітка для об'єкта в   ListView  вже була створена, то назад отримуємо   ViewHolder  з тегу:     viewHolder   =   (ViewHolder) convertView.  getTag  ();\n  Потім для   ImageView  та   TextView  в   ViewHolder  встановлюються значення з об'єкта   State :     viewHolder.imageView.  setImageResource  (state.  getFlagResource  ());\n   viewHolder.nameView.  setText  (state.  getName  ());\n   viewHolder.capitalView.  setText  (state.  getCapital  ());\n  Тепер   ListView , особливо при великих списках, буде працювати плавніше та продуктивніше, ніж у попередній версії.    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":466,"path":467,"dir":395,"title":468,"description":469,"keywords":470,"body":471},"content:1.android:3.lesson3:10.complex-list-with-buttons.md","/android/lesson3/complex-list-with-buttons","Складний список із кнопками","Раніше були розглянуті кастомні адаптери, які дозволяють виводити в списки складні дані. Тепер перейдемо до наступного кроку і розглянемо, як ми можемо додавати в списки інші елементи, наприклад, кнопки, та обробляти їх події.",[],"  Складний список із кнопками  Раніше були розглянуті кастомні адаптери, які дозволяють виводити в списки складні дані. Тепер перейдемо до наступного кроку і розглянемо, як ми можемо додавати в списки інші елементи, наприклад, кнопки, та обробляти їх події.  Для цього спершу визначимо наступний клас   Product :     package   com.example.listapp  ;\n    \n   public   class   Product   {\n       private   final   String   name;\n       private   int   count;\n       private   final   String   unit;\n    \n       Product  (  String   name  ,   String   unit  ){\n           this  .name   =   name;\n           this  .count  =  0  ;\n           this  .unit   =   unit;\n       }\n       public   String   getUnit  () {\n           return   this  .unit;\n       }\n       public   void   setCount  (  int   count  ) {\n           this  .count   =   count;\n       }\n    \n       public   int   getCount  () {\n           return   count;\n       }\n       public   String   getName  (){\n           return   this  .name;\n       }\n   }\n  Цей клас зберігає назву, кількість продукту, а також одиницю вимірювання. Об'єкти цього класу будуть виводитися в список.  Для цього в папку   res/layout  додаємо новий файл   list_item.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"wrap_content\"\n       android:padding  =  \"16dp\"   >\n   \n       \u003C  TextView\n           android:id  =  \"@+id/nameView\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"18sp\"\n           app:layout_constraintHorizontal_weight  =  \"2\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toLeftOf  =  \"@+id/countView\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  />\n       \u003C  TextView\n           android:id  =  \"@+id/countView\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"18sp\"\n           app:layout_constraintHorizontal_weight  =  \"2\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintLeft_toRightOf  =  \"@+id/nameView\"\n           app:layout_constraintRight_toLeftOf  =  \"@+id/addButton\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n       \u003C  Button\n           android:id  =  \"@+id/addButton\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"+\"\n           app:layout_constraintHorizontal_weight  =  \"1\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintLeft_toRightOf  =  \"@+id/countView\"\n           app:layout_constraintRight_toLeftOf  =  \"@+id/removeButton\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n       \u003C  Button\n           android:id  =  \"@+id/removeButton\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"-\"\n           app:layout_constraintHorizontal_weight  =  \"1\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintLeft_toRightOf  =  \"@+id/addButton\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  />\n   \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Тут визначені два текстових поля для виведення назви і кількості продукту, а також дві кнопки для додавання і видалення одиниці продукту.  Тепер додамо клас адаптера, який називатимемо   ProductAdapter :     package   com.example.listapp  ;\n   \n   import   android.content.Context  ;\n   import   android.view.LayoutInflater  ;\n   import   android.view.View  ;\n   import   android.view.ViewGroup  ;\n   import   android.widget.ArrayAdapter  ;\n   import   android.widget.Button  ;\n   import   android.widget.TextView  ;\n   \n   import   java.util.ArrayList  ;\n   \n   class   ProductAdapter   extends   ArrayAdapter  \u003C  Product  > {\n       private   final   LayoutInflater   inflater;\n       private   final   int   layout;\n       private   final   ArrayList  \u003C  Product  > productList;\n   \n       ProductAdapter  (  Context   context  ,   int   resource  ,   ArrayList  \u003C  Product  >   products  ) {\n           super  (context, resource, products);\n           this  .productList   =   products;\n           this  .layout   =   resource;\n           this  .inflater   =   LayoutInflater.  from  (context);\n       }\n       public   View   getView  (  int   position  ,   View   convertView  ,   ViewGroup   parent  ) {\n   \n           final   ViewHolder   viewHolder;\n           if  (convertView  ==  null  ){\n               convertView   =   inflater.  inflate  (  this  .layout, parent,   false  );\n               viewHolder   =   new   ViewHolder  (convertView);\n               convertView.  setTag  (viewHolder);\n           }\n           else  {\n               viewHolder   =   (ViewHolder) convertView.  getTag  ();\n           }\n           final   Product   product   =   productList.  get  (position);\n   \n           viewHolder.nameView.  setText  (product.  getName  ());\n           viewHolder.countView.  setText  (product.  getCount  ()   +   \" \"   +   product.  getUnit  ());\n   \n           viewHolder.removeButton.  setOnClickListener  (  new   View.  OnClickListener  () {\n               @  Override\n               public   void   onClick  (  View   v) {\n                   int   count   =   product.  getCount  ()  -  1  ;\n                   if  (count  \u003C  0  ) count  =  0  ;\n                   product.  setCount  (count);\n                   viewHolder.countView.  setText  (count   +   \" \"   +   product.  getUnit  ());\n               }\n           });\n           viewHolder.addButton.  setOnClickListener  (  new   View.  OnClickListener  () {\n               @  Override\n               public   void   onClick  (  View   v) {\n                   int   count   =   product.  getCount  ()  +  1  ;\n                   product.  setCount  (count);\n                   viewHolder.countView.  setText  (count   +   \" \"   +   product.  getUnit  ());\n               }\n           });\n   \n           return   convertView;\n       }\n       private   static   class   ViewHolder   {\n           final   Button   addButton, removeButton;\n           final   TextView   nameView, countView;\n           ViewHolder  (  View   view  ){\n               addButton   =   view.  findViewById  (R.id.addButton);\n               removeButton   =   view.  findViewById  (R.id.removeButton);\n               nameView   =   view.  findViewById  (R.id.nameView);\n               countView   =   view.  findViewById  (R.id.countView);\n           }\n       }\n   }\n  Для кожної кнопки тут визначено обробник натискання, в якому ми зменшуємо або збільшуємо кількість продукту на одиницю, а потім переустановлюємо текст у відповідному текстовому полі.  Далі у файлі   activity_main.xml  визначимо елемент   ListView :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n       \u003C  ListView\n           android:id  =  \"@+id/productList\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n   \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  І змінюємо клас   MainActivity :     package   com.example.listapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.widget.ListView  ;\n   import   java.util.ArrayList  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n   \n           ArrayList  \u003C  Product  > products   =   new   ArrayList  \u003C  Product  >();\n           products.  add  (  new   Product  (  \"Картофель\"  ,   \"кг.\"  ));\n           products.  add  (  new   Product  (  \"Чай\"  ,   \"шт.\"  ));\n           products.  add  (  new   Product  (  \"Яйца\"  ,   \"шт.\"  ));\n           products.  add  (  new   Product  (  \"Молоко\"  ,   \"л.\"  ));\n           products.  add  (  new   Product  (  \"Макароны\"  ,   \"кг.\"  ));\n           ListView   productList   =   findViewById  (R.id.productList);\n           ProductAdapter   adapter   =   new   ProductAdapter  (  this  , R.layout.list_item, products);\n           productList.  setAdapter  (adapter);\n       }\n   }\n  В результаті вийде наступний проект:\n   І після запуску програми ми зможемо керувати кількістю продуктів через кнопки:\n   html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":473,"path":474,"dir":395,"title":475,"description":476,"keywords":477,"body":479},"content:1.android:3.lesson3:11.spinner.md","/android/lesson3/spinner","Список, що випадає Spinner","Spinner являє собою список, що випадає. Визначимо у файлі розмітки activity_main.xml елемент Spinner:",[478],"Обробка вибору елемента","  Список, що випадає Spinner   Spinner  являє собою список, що випадає. Визначимо у файлі розмітки   activity_main.xml  елемент Spinner:     \u003C?  xml version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns  :  android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns  :  app  =  \"http://schemas.android.com/apk/res-auto\"\n       android  :  layout_width  =  \"match_parent\"\n       android  :  layout_height  =  \"match_parent\"\n       android  :  padding  =  \"16dp\"  >\n       \u003C  Spinner\n           android  :  id  =  \"@+id/spinner\"\n           android  :  layout_width  =  \"wrap_content\"\n           android  :  layout_height  =  \"wrap_content\"\n           app  :  layout_constraintLeft_toLeftOf  =  \"parent\"\n           app  :  layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Як джерело даних, як і для   ListView , для   Spinner  може слугувати простий список або масив, створений програмно, або ресурс string-array. Взаємодія з джерелом даних також буде йти через адаптер. У цьому випадку визначимо джерело програмно у вигляді масиву в коді   MainActivity :     package   com.example.listapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.widget.ArrayAdapter  ;\n   import   android.widget.Spinner  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       String  [] countries   =   {   \"Бразилия\"  ,   \"Аргентина\"  ,   \"Колумбия\"  ,   \"Чили\"  ,   \"Уругвай\"  };\n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           Spinner   spinner   =   findViewById  (R.id.spinner);\n           // Створюємо адаптер ArrayAdapter за допомогою масиву рядків і стандартної розмітки елемента spinner\n           ArrayAdapter  \u003C  String  > adapter   =   new   ArrayAdapter  (  this  , android.R.layout.simple_spinner_item, countries);\n           // Визначаємо розмітку для використання при виборі елемента\n           adapter.  setDropDownViewResource  (android.R.layout.simple_spinner_dropdown_item);\n           // Застосовуємо адаптер до елемента spinner\n           spinner.  setAdapter  (adapter);\n       }\n   }\n  Використовуваний при створенні   ArrayAdapter  ресурс   android.R.layout.simple_spinner_item  надається платформою і є стандартною розміткою для створення випадаючого списку.  За допомогою методу   adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)  встановлюються додаткові візуальні можливості списку. А переданий в метод ресурс   android.R.layout.simple_spinner_dropdown_item  використовується для візуалізації випадаючого списку і також надається платформою.\n   Обробка вибору елемента  Використовуючи слухач   OnItemSelectedListener , зокрема його метод   onItemSelected() , ми можемо обробляти вибір елемента зі списку. Спочатку додамо в розмітку інтерфейсу текстове поле, яке буде виводити обраний елемент:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"  >\n    \n       \u003C  TextView\n           android:id  =  \"@+id/selection\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"26sp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  >\n       \u003C/  TextView  >\n       \u003C  Spinner\n           android:id  =  \"@+id/spinner\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/selection\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  І змінимо код   MainActivity , визначивши для елемента   Spinner  слухач   OnItemSelectedListener :     package   com.example.listapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.AdapterView  ;\n   import   android.widget.ArrayAdapter  ;\n   import   android.widget.Spinner  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       String  [] countries   =   {   \"Бразилия\"  ,   \"Аргентина\"  ,   \"Колумбия\"  ,   \"Чили\"  ,   \"Уругвай\"  };\n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           TextView   selection   =   findViewById  (R.id.selection);\n    \n           Spinner   spinner   =   findViewById  (R.id.spinner);\n           // Створюємо адаптер ArrayAdapter за допомогою масиву рядків і стандартної розмітки елемента spinner\n           ArrayAdapter  \u003C  String  > adapter   =   new   ArrayAdapter  (  this  , android.R.layout.simple_spinner_item, countries);\n           // Визначаємо розмітку для використання при виборі елемента\n           adapter.  setDropDownViewResource  (android.R.layout.simple_spinner_dropdown_item);\n           // Застосовуємо адаптер до елемента spinner\n           spinner.  setAdapter  (adapter);\n    \n           AdapterView  .  OnItemSelectedListener   itemSelectedListener   =   new   AdapterView.  OnItemSelectedListener  () {\n               @  Override\n               public   void   onItemSelected  (  AdapterView  \u003C?>   parent,   View   view,   int   position,   long   id) {\n    \n                   // Отримуємо обраний об'єкт\n                   String   item   =   (String)parent.  getItemAtPosition  (position);\n                   selection.  setText  (item);\n               }\n    \n               @  Override\n               public   void   onNothingSelected  (  AdapterView  \u003C?>   parent) {\n               }\n           };\n           spinner.  setOnItemSelectedListener  (itemSelectedListener);\n       }\n   }\n  Метод   onItemSelected  слухача   OnItemSelectedListener  отримує чотири параметри:    parent : об'єкт   Spinner , в якому сталося подія вибору елемента.   view : об'єкт   View  всередині   Spinner , який представляє вибраний елемент.   position : індекс вибраного елемента в адаптері.   id : ідентифікатор рядка того елемента, який був вибраний.  Отримавши позицію вибраного елемента, ми можемо знайти його в списку:     String   item   =   (String) parent.  getItemAtPosition  (position);\n  Для встановлення слухача   OnItemSelectedListener  в класі   Spinner  застосовується метод   setOnItemSelectedListener .    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":481,"path":482,"dir":395,"title":483,"description":484,"keywords":485,"body":486},"content:1.android:3.lesson3:12.auto-complete-text-view.md","/android/lesson3/auto-complete-text-view","Віджет автодоповнення AutoCompleteTextView","AutoCompleteTextView представляє елемент, створений на основі класу EditText, і має можливість автодоповнення.",[],"  Віджет автодоповнення AutoCompleteTextView   AutoCompleteTextView  представляє елемент, створений на основі класу   EditText , і має можливість автодоповнення.  По-перше, оголосимо в ресурсі розмітки цей елемент:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"  >\n    \n       \u003C  AutoCompleteTextView\n           android:id  =  \"@+id/autocomplete\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:completionHint  =  \"Введіть місто\"\n           android:completionThreshold  =  \"1\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n       />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Атрибут   android:completionHint  дозволяє задати напис, який відображається внизу списку, а властивість   android:completionThreshold  встановлює, яку кількість символів треба ввести, щоб почало працювати автодоповнення. Тобто в даному випадку вже після введення одного символа має з'явитися список з підстановками.  Як і у випадку з елементами   ListView  та   Spinner ,   AutoCompleteTextView  підключається до джерела даних через адаптер. Джерелом даних може бути масив або список об'єктів, або ресурс   string-array .  Тепер підключимо до віджету масив рядків у класі   MainActivity :     package   com.example.listapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.widget.ArrayAdapter  ;\n   import   android.widget.AutoCompleteTextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       String  [] cities   =   {  \"Київ\"  ,   \"Миколаїв\"  ,   \"Херсон\"  ,   \"Львів\"  ,   \"Чернівці\"  ,   \"Житомир\"  };\n       \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           // Отримуємо посилання на елемент AutoCompleteTextView в розмітці\n           AutoCompleteTextView   autoCompleteTextView   =   findViewById  (R.id.autocomplete);\n           \n           // Створюємо адаптер для автозаповнення елемента AutoCompleteTextView\n           ArrayAdapter  \u003C  String  > adapter   =   new   ArrayAdapter  (  this  , R.layout.support_simple_spinner_dropdown_item, cities);\n           autoCompleteTextView.  setAdapter  (adapter);\n       }\n   }\n  Після введення в текстове поле однієї літери відобразиться список з варіантами автодоповнення, де можна вибрати бажаний варіант:\n   MultiAutoCompleteTextView  Цей віджет доповнює функціональність елемента   AutoCompleteTextView .   MultiAutoCompleteTextView  дозволяє використовувати автодоповнення не тільки для одного рядка, але й для окремих слів. Наприклад, якщо вводиться слово, і після нього ставиться кома, то автозаповнення все одно буде працювати для нововведених слів після коми або іншого роздільника.   MultiAutoCompleteTextView  має таку ж форму оголошення, як і   AutoCompleteTextView :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"  >\n    \n       \u003C  MultiAutoCompleteTextView\n           android:id  =  \"@+id/autocomplete\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:completionHint  =  \"Введите город\"\n           android:completionThreshold  =  \"1\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Щоб увімкнути   MultiAutoCompleteTextView  у коді, треба встановити токен роздільника:     package   com.example.listapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.widget.ArrayAdapter  ;\n   import   android.widget.MultiAutoCompleteTextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       String  [] cities   =   {  \"Київ\"  ,   \"Миколаїв\"  ,   \"Херсон\"  ,   \"Львів\"  ,   \"Чернівці\"  ,   \"Житомир\"  };\n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n           // Отримуємо посилання на елемент AutoCompleteTextView у розмітці\n           MultiAutoCompleteTextView   autoCompleteTextView   =   findViewById  (R.id.autocomplete);\n           // Створюємо адаптер для автозаповнення елемента MultiAutoCompleteTextView\n           ArrayAdapter  \u003C  String  > adapter   =   new   ArrayAdapter  (  this  , R.layout.support_simple_spinner_dropdown_item, cities);\n           autoCompleteTextView.  setAdapter  (adapter);\n           // встановлення коми як роздільника\n           autoCompleteTextView.  setTokenizer  (  new   MultiAutoCompleteTextView.  CommaTokenizer  ());\n       }\n   }\n  Тут як роздільник використовується вбудований роздільник на основі коми   CommaTokenizer() . За необхідності ми можемо створити свої роздільники.    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":488,"path":489,"dir":395,"title":490,"description":491,"keywords":492,"body":493},"content:1.android:3.lesson3:13.grid-view.md","/android/lesson3/grid-view","GridView","Елемент GridView представляє відображення у вигляді таблиці — набору рядків і стовпців.",[],"  GridView  Елемент   GridView  представляє відображення у вигляді таблиці — набору рядків і стовпців.   Основні атрибути GridView :    android:columnWidth : встановлює фіксовану ширину стовпців.   android:gravity : встановлює вирівнювання вмісту всередині кожної комірки.   android:horizontalSpacing : встановлює горизонтальні відступи між стовпцями.   android:numColumns : встановлює кількість стовпців.   android:stretchMode : встановлює, як стовпці будуть розтягуватись і займати простір контейнера. Може приймати такі значення:\n    columnWidth : кожен стовпець розтягується рівномірно по всій ширині. Еквівалентно значенню 2.   none : стовпці не розтягуються. Еквівалентно значенню 0.   spacingWidth : між стовпцями утворюються відступи. Еквівалентно значенню 1.   spacingWidthUniform : між стовпцями утворюються рівномірні відступи. Еквівалентно значенню 3.   android:verticalSpacing : встановлює вертикальні відступи між рядками.   Основні методи класу GridView :    int getColumnWidth() : повертає ширину стовпців.   int getHorizontalSpacing() : повертає розмір горизонтального відступу.   int getNumColumns() : повертає кількість стовпців.   int getStretchMode() : повертає режим розтягування простору всередині грида.   int getVerticalSpacing() : повертає розмір вертикального відступу.   void setAdapter(ListAdapter adapter) : встановлює адаптер для підключення до джерела даних.   void setColumnWidth(int columnWidth) : встановлює ширину стовпців.   void setHorizontalSpacing(int horizontalSpacing) : встановлює розмір горизонтального відступу.   void setNumColumns(int numColumns) : встановлює кількість стовпців.   void setStretchMode(int stretchMode) : встановлює режим розтягування простору всередині грида.   void setVerticalSpacing(int verticalSpacing) : встановлює розмір вертикального відступу.   void setSelection(int position) : встановлює поточний виділений елемент.   Визначимо GridView у   activity_main.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"  >\n       \u003C  GridView\n           android:id  =  \"@+id/gridview\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           android:numColumns  =  \"2\"\n           android:verticalSpacing  =  \"16dp\"\n           android:horizontalSpacing  =  \"16dp\"\n           android:stretchMode  =  \"columnWidth\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"   />\n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  У даному випадку вказується, що грід буде мати 2 стовпці, які розтягуються рівномірно по всій ширині грида, а між комірками будуть відступи по горизонталі та вертикалі в 16 dp.  Тепер, як і в разі з   ListView , треба встановити зв'язок з адаптером:     package   com.example.listapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.AdapterView  ;\n   import   android.widget.ArrayAdapter  ;\n   import   android.widget.GridView  ;\n   import   android.widget.Toast  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       String  [] countries   =   {   \"Бразилия\"  ,   \"Аргентина\"  ,   \"Чили\"  ,   \"Колумбия\"  ,   \"Уругвай\"  };\n       \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n   \n           // отримуємо елемент GridView\n           GridView   countriesList   =   findViewById  (R.id.gridview);\n           // створюємо адаптер\n           ArrayAdapter  \u003C  String  > adapter   =   new   ArrayAdapter  (  this  , android.R.layout.simple_list_item_1, countries);\n           countriesList.  setAdapter  (adapter);\n   \n           AdapterView  .  OnItemClickListener   itemListener   =   new   AdapterView.  OnItemClickListener  () {\n   \n               @  Override\n               public   void   onItemClick  (  AdapterView  \u003C?>   parent,   View   view,   int   position,   long   id) {\n                   Toast.  makeText  (  getApplicationContext  (),  \"Ви вибрали \"\n                                   +   parent.  getItemAtPosition  (position).  toString  (),\n                           Toast.LENGTH_SHORT).  show  ();\n               }\n           };\n           countriesList.  setOnItemClickListener  (itemListener);\n       }\n   }\n  Для обробки натискання в   GridView  застосовується слухач   AdapterView.OnItemClickListener .    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":495,"path":496,"dir":395,"title":497,"description":498,"keywords":499,"body":500},"content:1.android:3.lesson3:14.recycler-view.md","/android/lesson3/recycler-view","RecyclerView","Елемент RecyclerView призначений для оптимізації роботи зі списками і в багатьох випадках дозволяє підвищити продуктивність порівняно з стандартним ListView.",[],"  RecyclerView  Елемент   RecyclerView  призначений для оптимізації роботи зі списками і в багатьох випадках дозволяє підвищити продуктивність порівняно з стандартним   ListView .  Для представлення даних додамо в проект у ту саму папку, де знаходиться клас   MainActivity , новий клас Java, який назвемо   State :     package   com.example.listapp  ;\n   \n   public   class   State   {\n   \n       private   String   name;   // назва\n       private   String   capital;    // столиця\n       private   int   flagResource;   // ресурс прапора\n   \n       public   State  (  String   name  ,   String   capital  ,   int   flag  ){\n           this  .name   =   name;\n           this  .capital   =   capital;\n           this  .flagResource   =   flag;\n       }\n   \n       public   String   getName  () {\n           return   this  .name;\n       }\n   \n       public   void   setName  (  String   name  ) {\n           this  .name   =   name;\n       }\n   \n       public   String   getCapital  () {\n           return   this  .capital;\n       }\n   \n       public   void   setCapital  (  String   capital  ) {\n           this  .capital   =   capital;\n       }\n   \n       public   int   getFlagResource  () {\n           return   this  .flagResource;\n       }\n   \n       public   void   setFlagResource  (  int   flagResource  ) {\n           this  .flagResource   =   flagResource;\n       }\n   }\n  Клас   State  містить поля для збереження назви та столиці країни, а також посилання на ресурс зображення прапора країни. В даному випадку передбачається, що в папці   res/drawable  будуть зберігатися файли зображень прапорів для використовуваних країн.  Припустимо, ми хочемо вивести список об'єктів   State  за допомогою   RecyclerView . Для цього додамо в папку   res/layout  новий файл   list_item.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"wrap_content\"  >\n       \n       \u003C  ImageView\n           android:id  =  \"@+id/flag\"\n           android:layout_width  =  \"70dp\"\n           android:layout_height  =  \"50dp\"\n           android:layout_marginTop  =  \"16dp\"\n           android:layout_marginBottom  =  \"16dp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toLeftOf  =  \"@+id/name\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"   />\n   \n       \u003C  TextView\n           android:id  =  \"@+id/name\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_marginLeft  =  \"16dp\"\n           android:text  =  \"Назва\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintLeft_toRightOf  =  \"@+id/flag\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toTopOf  =  \"@+id/capital\"   />\n   \n       \u003C  TextView\n           android:id  =  \"@+id/capital\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_marginLeft  =  \"16dp\"\n           android:text  =  \"Столиця\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintLeft_toRightOf  =  \"@+id/flag\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/name\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"   />\n       \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Цей файл визначає розмітку для виведення одного об'єкта   State .  Як і в разі з   ListView , для виведення складних об'єктів у   RecyclerView  потрібно визначити свій адаптер. Тому додамо в ту саму папку, де знаходяться класи   MainActivity  та   State , новий клас Java, який назвемо   StateAdapter :     package   com.example.listapp  ;\n   \n   import   android.content.Context  ;\n   import   android.view.LayoutInflater  ;\n   import   android.view.View  ;\n   import   android.view.ViewGroup  ;\n   import   android.widget.ImageView  ;\n   import   android.widget.TextView  ;\n   \n   import   androidx.recyclerview.widget.RecyclerView  ;\n   \n   import   java.util.List  ;\n   \n   public   class   StateAdapter   extends   RecyclerView.Adapter  \u003C  StateAdapter  .  ViewHolder  > {\n   \n       private   final   LayoutInflater   inflater;\n       private   final   List  \u003C  State  > states;\n   \n       StateAdapter  (  Context   context  ,   List  \u003C  State  >   states  ) {\n           this  .states   =   states;\n           this  .inflater   =   LayoutInflater.  from  (context);\n       }\n   \n       @  Override\n       public   StateAdapter  .  ViewHolder   onCreateViewHolder  (  ViewGroup   parent  ,   int   viewType  ) {\n           View   view   =   inflater.  inflate  (R.layout.list_item, parent,   false  );\n           return   new   ViewHolder  (view);\n       }\n   \n       @  Override\n       public   void   onBindViewHolder  (  StateAdapter  .  ViewHolder   holder  ,   int   position  ) {\n           State   state   =   states.  get  (position);\n           holder.flagView.  setImageResource  (state.  getFlagResource  ());\n           holder.nameView.  setText  (state.  getName  ());\n           holder.capitalView.  setText  (state.  getCapital  ());\n       }\n   \n       @  Override\n       public   int   getItemCount  () {\n           return   states.  size  ();\n       }\n   \n       public   static   class   ViewHolder   extends   RecyclerView.ViewHolder   {\n           final   ImageView   flagView;\n           final   TextView   nameView, capitalView;\n           \n           ViewHolder  (  View   view  ) {\n               super  (view);\n               flagView   =   view.  findViewById  (R.id.flag);\n               nameView   =   view.  findViewById  (R.id.name);\n               capitalView   =   view.  findViewById  (R.id.capital);\n           }\n       }\n   }\n  Адаптер, який використовується в   RecyclerView , повинен успадковуватися від абстрактного класу   RecyclerView.Adapter . Цей клас визначає три методи:    onCreateViewHolder : повертає об'єкт   ViewHolder , який буде зберігати дані по одному об'єкту   State .   onBindViewHolder : виконує прив'язку об'єкта   ViewHolder  до об'єкта   State  за певною позицією.   getItemCount : повертає кількість об'єктів у списку.  Для зберігання даних у класі адаптера визначено статичний клас   ViewHolder , який використовує елементи керування, визначені в   list_item.xml .  Тепер визначимо в файлі   activity_main.xml  елемент   RecyclerView :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"  >\n       \n       \u003C  androidx.recyclerview.widget.RecyclerView\n           android:id  =  \"@+id/list\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           app:layoutManager  =  \"androidx.recyclerview.widget.LinearLayoutManager\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"  />\n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Слід враховувати, що   RecyclerView  розташований у пакеті   androidx.recyclerview.widget  і є частиною Android Jetpack тулкита, тому при використанні віджета вказується повне його ім'я з урахуванням пакету (як і для   ConstraintLayout ):     \u003C  androidx.recyclerview.widget.RecyclerView   ....>\n  Для   RecyclerView  слід встановити атрибут   app:layoutManager , який вказує на тип менеджера компонування. Менеджер компонування — це об'єкт, представлений класом   LayoutManager . За замовчуванням бібліотека   RecyclerView  надає три реалізації цього менеджера:    LinearLayoutManager : впорядковує елементи у вигляді списку з однією колонкою.   GridLayoutManager : впорядковує елементи у вигляді сітки зі стовпцями і рядками. Сітка може упорядковувати елементи по горизонталі (горизонтальна сітка) або по вертикалі (вертикальна сітка).   StaggeredGridLayoutManager : аналогічний до   GridLayoutManager , однак не вимагає, щоб кожен елемент у рядку мав однакову висоту (для вертикальної сітки) або однакову ширину (для горизонтальної сітки).  В даному випадку, використовуючи значення   androidx.recyclerview.widget.LinearLayoutManager , ми вказуємо, що елементи будуть розташовуватися у вигляді простого списку. Зверніть увагу, що клас   LinearLayoutManager  також розташований у бібліотеці   RecyclerView , тому при вказанні значення вказується повне ім'я класу з іменем пакету.  І наприкінці змінемо клас   MainActivity :     package   com.example.listapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   androidx.recyclerview.widget.RecyclerView  ;\n   import   android.os.Bundle  ;\n   import   java.util.ArrayList  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       ArrayList  \u003C  State  > states   =   new   ArrayList  \u003C  State  >();\n       \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n           \n           // початкова ініціалізація списку\n           setInitialData  ();\n           \n           RecyclerView   recyclerView   =   findViewById  (R.id.list);\n           \n           // створюємо адаптер\n           StateAdapter   adapter   =   new   StateAdapter  (  this  , states);\n           \n           // встановлюємо адаптер для списку\n           recyclerView.  setAdapter  (adapter);\n       }\n       \n       private   void   setInitialData  () {\n           states.  add  (  new   State  (  \"Бразилія\"  ,   \"Бразилія\"  , R.drawable.brazilia));\n           states.  add  (  new   State  (  \"Аргентина\"  ,   \"Буенос-Айрес\"  , R.drawable.argentina));\n           states.  add  (  new   State  (  \"Колумбія\"  ,   \"Богота\"  , R.drawable.columbia));\n           states.  add  (  new   State  (  \"Уругвай\"  ,   \"Монтевідео\"  , R.drawable.uruguai));\n           states.  add  (  new   State  (  \"Чилі\"  ,   \"Сантьяго\"  , R.drawable.chile));\n       }\n   }\n  За допомогою методу   setInitialData()  встановлюється набір початкових даних. В даному випадку передбачається, що в папці   res/drawables  зберігаються файли зображень для об'єктів   State .  Як і у випадку з виведенням списку через   ListView , тут спочатку отримуємо елемент   RecyclerView , створюємо адаптер і встановлюємо адаптер для   RecyclerView .  Весь проект в підсумку виглядатиме наступним чином:   \nУ результаті   RecyclerView  виведе набір об'єктів:\n   html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":502,"path":503,"dir":395,"title":504,"description":505,"keywords":506,"body":507},"content:1.android:3.lesson3:15.item-selection.md","/android/lesson3/item-selection","Обробка вибору елемента в RecyclerView","При роботі з віджетом RecyclerView неминуче виникає питання, як обробляти вибір елемента в RecyclerView. І тут слід зазначити, що на відміну від інших типів віджетів для роботи зі списками, RecyclerView за замовчуванням не надає якогось спеціального методу, за допомогою якого можна було б визначити слухач на натискання на елемент у списку. Тому всю інфраструктуру необхідно визначати самому розробнику. Але на щастя, на практиці все не так складно. Для прикладу візьмемо проект з попередньої теми:\n",[],"  Обробка вибору елемента в RecyclerView  При роботі з віджетом   RecyclerView  неминуче виникає питання, як обробляти вибір елемента в   RecyclerView . І тут слід зазначити, що на відміну від інших типів віджетів для роботи зі списками,   RecyclerView  за замовчуванням не надає якогось спеціального методу, за допомогою якого можна було б визначити слухач на натискання на елемент у списку. Тому всю інфраструктуру необхідно визначати самому розробнику. Але на щастя, на практиці все не так складно. Для прикладу візьмемо проект з попередньої теми:\n      package   com.example.listapp  ;\n   \n   public   class   State   {\n   \n       private   String   name;   // назва\n       private   String   capital;    // столиця\n       private   int   flagResource;   // ресурс прапора\n   \n       public   State  (  String   name  ,   String   capital  ,   int   flag  ){\n   \n           this  .name  =  name;\n           this  .capital  =  capital;\n           this  .flagResource  =  flag;\n       }\n   \n       public   String   getName  () {\n           return   this  .name;\n       }\n   \n       public   void   setName  (  String   name  ) {\n           this  .name   =   name;\n       }\n   \n       public   String   getCapital  () {\n           return   this  .capital;\n       }\n   \n       public   void   setCapital  (  String   capital  ) {\n           this  .capital   =   capital;\n       }\n   \n       public   int   getFlagResource  () {\n           return   this  .flagResource;\n       }\n   \n       public   void   setFlagResource  (  int   flagResource  ) {\n           this  .flagResource   =   flagResource;\n       }\n   }\n  Клас   State  містить поля для збереження назви та столиці країни, а також посилання на ресурс зображення прапора країни. В даному випадку передбачається, що в папці   res/drawable  знаходяться файли зображень прапорів для використаних країн.  У папці   res/layout  для виведення одного об'єкта   State  в списку визначений наступний файл   list_item.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"wrap_content\"  >\n       \u003C  ImageView\n           android:id  =  \"@+id/flag\"\n           android:layout_width  =  \"70dp\"\n           android:layout_height  =  \"50dp\"\n           android:layout_marginTop  =  \"16dp\"\n           android:layout_marginBottom  =  \"16dp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toLeftOf  =  \"@+id/name\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"   />\n   \n       \u003C  TextView\n           android:id  =  \"@+id/name\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_marginLeft  =  \"16dp\"\n           android:text  =  \"Назва\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintLeft_toRightOf  =  \"@+id/flag\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toTopOf  =  \"@+id/capital\"   />\n   \n       \u003C  TextView\n           android:id  =  \"@+id/capital\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_marginLeft  =  \"16dp\"\n           android:text  =  \"Столиця\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintLeft_toRightOf  =  \"@+id/flag\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/name\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"   />\n   \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Тепер перейдемо до класу   StateAdapter  і наступним чином визначимо його код:     package   com.example.listapp  ;\n   \n   import   android.content.Context  ;\n   import   android.view.LayoutInflater  ;\n   import   android.view.View  ;\n   import   android.view.ViewGroup  ;\n   import   android.widget.ImageView  ;\n   import   android.widget.TextView  ;\n   import   androidx.recyclerview.widget.RecyclerView  ;\n   \n   import   java.util.List  ;\n   \n   public   class   StateAdapter    extends   RecyclerView.Adapter  \u003C  StateAdapter  .  ViewHolder  >{\n   \n       interface   OnStateClickListener  {\n           void   onStateClick  (  State   state  ,   int   position  );\n       }\n   \n       private   final   OnStateClickListener   onClickListener;\n   \n       private   final   LayoutInflater   inflater;\n       private   final   List  \u003C  State  > states;\n   \n       StateAdapter  (  Context   context  ,   List  \u003C  State  >   states  ,   OnStateClickListener   onClickListener  ) {\n           this  .onClickListener   =   onClickListener;\n           this  .states   =   states;\n           this  .inflater   =   LayoutInflater.  from  (context);\n       }\n   \n       @  Override\n       public   StateAdapter  .  ViewHolder   onCreateViewHolder  (  ViewGroup   parent  ,   int   viewType  ) {\n   \n           View   view   =   inflater.  inflate  (R.layout.list_item, parent,   false  );\n           return   new   ViewHolder  (view);\n       }\n   \n       @  Override\n       public   void   onBindViewHolder  (  StateAdapter  .  ViewHolder   holder  ,   int   position  ) {\n           State   state   =   states.  get  (position);\n           holder.flagView.  setImageResource  (state.  getFlagResource  ());\n           holder.nameView.  setText  (state.  getName  ());\n           holder.capitalView.  setText  (state.  getCapital  ());\n   \n           holder.itemView.  setOnClickListener  (  new   View.  OnClickListener  (){\n               @  Override\n               public   void   onClick  (  View   v)\n               {\n                   onClickListener.  onStateClick  (state, position);\n               }\n           });\n       }\n   \n       @  Override\n       public   int   getItemCount  () {\n           return   states.  size  ();\n       }\n   \n       public   static   class   ViewHolder   extends   RecyclerView.ViewHolder   {\n           final   ImageView   flagView;\n           final   TextView   nameView, capitalView;\n           ViewHolder  (  View   view  ){\n               super  (view);\n               flagView   =   view.  findViewById  (R.id.flag);\n               nameView   =   view.  findViewById  (R.id.name);\n               capitalView   =   view.  findViewById  (R.id.capital);\n           }\n       }\n   }\n  Тут я зупинюся на тих моментах, які були додані порівняно з кодом з попередньої статті.  Передусім потрібно визначити інтерфейс слухача події натискання. Для цього в класі   StateAdapter  визначено інтерфейс:     interface   OnStateClickListener  {\n       void   onStateClick  (  State   state  ,   int   position  );\n   }\n  Інтерфейс визначає один метод   onStateClick() , який, як передбачається, буде викликатися при виборі об'єкта   State  і який отримає вибраний об'єкт   State  та його позицію в списку.  Наступний момент - визначення в класі адаптера змінної для збереження об'єкта цього інтерфейсу та отримання для неї значення в конструкторі:     private   final   OnStateClickListener   onClickListener;\n   \n   StateAdapter  (  Context   context,   List  \u003C  State  >   states,   OnStateClickListener   onClickListener) {\n       this  .onClickListener   =   onClickListener;\n       // ........................\n   }\n  Таким чином, поза кодом адаптера ми можемо встановити будь-який об'єкт слухача і передати його в адаптер.  І третій момент - виклик методу слухача при натисканні на елемент у списку в методі   onBindViewHolder :     public   void   onBindViewHolder  (StateAdapter.ViewHolder holder,   int   position) {\n       State   state   =   states.  get  (position);\n       holder.flagView.  setImageResource  (state.  getFlagResource  ());\n       holder.nameView.  setText  (state.  getName  ());\n       holder.capitalView.  setText  (state.  getCapital  ());\n   \n       // обробка натискання\n       holder.itemView.  setOnClickListener  (  new   View.  OnClickListener  (){\n           @  Override\n           public   void   onClick  (  View   v)\n           {\n               // викликаємо метод слухача, передаючи йому дані\n               onClickListener.  onStateClick  (state, position);\n           }\n       });\n   }\n  Клас   ViewHolder  має поле   itemView , яке представляє інтерфейс для одного об'єкта в списку і фактично є об'єктом   View . А в цього об'єкта є метод   setOnClickListener() , через який можна підключити стандартний слухач натискання   OnClickListener  і в його методі   onClick()  викликати метод нашого інтерфейсу, передавши йому необхідні дані - вибраний об'єкт   State  та його позицію в списку.  Може виникнути питання, чому б не обробляти натискання на елемент безпосередньо тут? Навіщо створювати додатковий інтерфейс, його змінну і викликати його метод? Звісно, ми можемо спробувати безпосередньо обробити натискання тут, але це не є гарною або поширеною практикою, оскільки, можливо, ми захочемо визначити обробку натискання в класі   MainActivity , виходячи з того коду, який там визначений (або з якогось іншого місця ззовні).  У файлі   activity_main.xml  залишається той самий візуальний інтерфейс:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"  >\n       \u003C  androidx.recyclerview.widget.RecyclerView\n           android:id  =  \"@+id/list\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n            \n           app:layoutManager  =  \"androidx.recyclerview.widget.LinearLayoutManager\"\n            \n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"  />\n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  І наприкінці змінимо клас   MainActivity :     package   com.example.listapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   androidx.recyclerview.widget.RecyclerView  ;\n   import   android.os.Bundle  ;\n   import   android.widget.Toast  ;\n   import   java.util.ArrayList  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       ArrayList  \u003C  State  > states   =   new   ArrayList  \u003C  State  >();\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n   \n           // початкова ініціалізація списку\n           setInitialData  ();\n   \n           RecyclerView   recyclerView   =   findViewById  (R.id.list);\n   \n           // визначаємо слухача натискання елемента у списку\n           StateAdapter  .  OnStateClickListener   stateClickListener   =   new   StateAdapter.  OnStateClickListener  () {\n               @  Override\n               public   void   onStateClick  (  State   state,   int   position) {\n                   // показуємо спливаюче повідомлення з назвою країни\n                   Toast.  makeText  (  getApplicationContext  (),   \"Був вибраний пункт \"   +   state.  getName  (),\n                           Toast.LENGTH_SHORT).  show  ();\n               }\n           };\n   \n           // створюємо адаптер і передаємо йому слухача\n           StateAdapter   adapter   =   new   StateAdapter  (  this  , states, stateClickListener);\n   \n           // встановлюємо адаптер для RecyclerView\n           recyclerView.  setAdapter  (adapter);\n       }\n   \n       // метод для додавання початкових даних\n       private   void   setInitialData  (){\n           states.  add  (  new   State  (  \"Бразилія\"  ,   \"Бразиліа\"  , R.drawable.brazilia));\n           states.  add  (  new   State  (  \"Аргентина\"  ,   \"Буенос-Айрес\"  , R.drawable.argentina));\n           states.  add  (  new   State  (  \"Колумбія\"  ,   \"Богота\"  , R.drawable.columbia));\n           states.  add  (  new   State  (  \"Уругвай\"  ,   \"Монтевідео\"  , R.drawable.uruguai));\n           states.  add  (  new   State  (  \"Чилі\"  ,   \"Сантьяго\"  , R.drawable.chile));\n       }\n   }\n  Під час створення адаптера йому передається визначений у класі   MainActivity  слухач:     StateAdapter  .  OnStateClickListener   stateClickListener   =   new   StateAdapter.  OnStateClickListener  () {\n       @  Override\n       public   void   onStateClick  (  State   state,   int   position) {\n    \n           Toast.  makeText  (  getApplicationContext  (),   \"Був обраний пункт \"   +   state.  getName  (),  \n                           Toast.LENGTH_SHORT).  show  ();\n       }\n   };\n  Тут просто виводиться спливаюче повідомлення про обраний елемент списку.\n   html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":509,"path":510,"dir":395,"title":511,"description":512,"keywords":513,"body":516},"content:1.android:3.lesson3:16.styles.md","/android/lesson3/styles","Стилі","Ми можемо налаштувати елемент за допомогою різних атрибутів, які задають висоту, ширину, колір фону, тексту тощо. Але якщо у нас кілька елементів використовують одні й ті самі налаштування, то ми можемо об'єднати ці налаштування в стилі.",[514,515],"Визначення стилю в файлі styles.xml","Застосування стилю","  Стилі  Ми можемо налаштувати елемент за допомогою різних атрибутів, які задають висоту, ширину, колір фону, тексту тощо. Але якщо у нас кілька елементів використовують одні й ті самі налаштування, то ми можемо об'єднати ці налаштування в   стилі .  Наприклад, нехай у нас є кілька елементів   TextView :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView1\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:gravity  =  \"center\"\n           android:textSize  =  \"28sp\"\n           android:textColor  =  \"#3f51b5\"\n           android:text  =  \"Android Lollipop\"\n    \n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toTopOf  =  \"@+id/textView2\"\n           />\n       \u003C  TextView\n           android:id  =  \"@+id/textView2\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:gravity  =  \"center\"\n           android:textSize  =  \"28sp\"\n           android:textColor  =  \"#3f51b5\"\n           android:text  =  \"Android Marshmallow\"\n    \n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintBottom_toTopOf  =  \"@+id/textView3\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/textView1\"\n           />\n       \u003C  TextView\n           android:id  =  \"@+id/textView3\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:gravity  =  \"center\"\n           android:textSize  =  \"28sp\"\n           android:textColor  =  \"#3f51b5\"\n           android:text  =  \"Android Nougat\"\n    \n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/textView2\"\n           />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n    Усі ці   TextView  мають однаковий набір властивостей, і, наприклад, якщо ми захочемо змінити колір тексту, то доведеться змінювати його для кожного з трьох   TextView . Цей підхід не є оптимальним. Більш оптимальний підхід — це використання стилів, які визначаються у проєкті в папці   res/values .  Отже, додамо до проєкту в папку   res/values  новий елемент   Value Resource File , який назвемо   styles.xml :    Визначення стилю в файлі   styles.xml     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  resources  >\n       \u003C  style   name  =  \"TextViewStyle\"  >\n           \u003C  item   name  =  \"android:layout_width\"  >0dp\u003C/  item  >\n           \u003C  item   name  =  \"android:layout_height\"  >wrap_content\u003C/  item  >\n           \u003C  item   name  =  \"android:textColor\"  >#3f51b5\u003C/  item  >\n           \u003C  item   name  =  \"android:textSize\"  >28sp\u003C/  item  >\n           \u003C  item   name  =  \"android:gravity\"  >center\u003C/  item  >\n       \u003C/  style  >\n   \u003C/  resources  >\n  Тут визначено новий стиль   TextViewStyle , який за допомогою елементів   item  задає значення для атрибутів   TextView .  Стиль задається за допомогою елемента   \u003Cstyle> . Атрибут   name  вказує на назву стилю, через яку потім можна посилатися на нього. Необов'язковий атрибут   parent  встановлює для цього стилю батьківський стиль, від якого дочірній стиль буде успадковувати всі свої характеристики.  За допомогою елементів   item  встановлюються конкретні властивості віджета, який приймає в якості значення атрибута   name  ім'я встановлюваної властивості.  Застосування стилю  Тепер застосуємо стиль, змінимо файл   activity_main.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView1\"\n           style  =  \"@style/TextViewStyle\"\n           android:text  =  \"Android Lollipop\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toTopOf  =  \"@+id/textView2\"\n           />\n       \u003C  TextView\n           android:id  =  \"@+id/textView2\"\n           style  =  \"@style/TextViewStyle\"\n           android:text  =  \"Android Marshmallow\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintBottom_toTopOf  =  \"@+id/textView3\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/textView1\"\n           />\n       \u003C  TextView\n           android:id  =  \"@+id/textView3\"\n           style  =  \"@style/TextViewStyle\"\n           android:text  =  \"Android Nougat\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/textView2\"\n           />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Використовуючи визначення   style=\"@style/TextViewStyle\" , текстове поле пов'язується з визначенням стилю. Підсумковий результат буде таким самим, як і раніше, тільки коду стає менше. А якщо ми захочемо змінити якісь характеристики, то достатньо змінити потрібний елемент   item     html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":518,"path":519,"dir":395,"title":520,"description":521,"keywords":522,"body":526},"content:1.android:3.lesson3:17.themes.md","/android/lesson3/themes","Теми","Окрім застосування окремих стилів до окремих елементів, ми можемо задавати стилі для всього додатка або конкретного activity у вигляді тем. Тема представляє колекцію атрибутів, які застосовуються до всього додатка, класу activity або ієрархії віджетів.",[523,524,525],"Створення власної теми","Застосування теми до activity","Застосування теми до ієрархії віджетів","  Теми  Окрім застосування окремих стилів до окремих елементів, ми можемо задавати стилі для всього додатка або конкретного   activity  у вигляді тем.   Тема  представляє колекцію атрибутів, які застосовуються   до всього додатка ,   класу   activity  або   ієрархії віджетів .  Ми можемо самостійно створити тему. Однак Android уже надає кілька передвстановлених тем для стилізації додатка, наприклад,   Theme.AppCompat.Light.DarkActionBar  та інші.  За замовчуванням додаток вже використовує теми. Наприклад, відкриємо файл   AndroidManifest.xml . У ньому можна побачити таке визначення елемента   application , що представляє додаток:   \u003Capplication\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.ViewApp\">\n  Задання теми відбувається за допомогою атрибута   android:theme . У цьому випадку використовується ресурс із назвою   Theme.ViewApp . За замовчуванням файли тем визначені в папці   res/values .  Зокрема, тут можна знайти каталог   themes , у якому за замовчуванням є два елементи:   themes.xml .    Один файл представляє   світлу тему , а інший —   темну . Наприклад, розглянемо файл   themes.xml , який визначає світлу тему:     \u003C  resources   xmlns:tools  =  \"http://schemas.android.com/tools\"  >\n       \u003C!-- Базова тема додатка -->\n       \u003C  style   name  =  \"Theme.ViewApp\"   parent  =  \"Theme.MaterialComponents.DayNight.DarkActionBar\"  >\n           \u003C!-- Основний колір бренду -->\n           \u003C  item   name  =  \"colorPrimary\"  >@color/purple_500\u003C/  item  >\n           \u003C  item   name  =  \"colorPrimaryVariant\"  >@color/purple_700\u003C/  item  >\n           \u003C  item   name  =  \"colorOnPrimary\"  >@color/white\u003C/  item  >\n           \u003C!-- Вторинний колір бренду -->\n           \u003C  item   name  =  \"colorSecondary\"  >@color/teal_200\u003C/  item  >\n           \u003C  item   name  =  \"colorSecondaryVariant\"  >@color/teal_700\u003C/  item  >\n           \u003C  item   name  =  \"colorOnSecondary\"  >@color/black\u003C/  item  >\n           \u003C!-- Колір статус-бара -->\n           \u003C  item   name  =  \"android:statusBarColor\"   tools:targetApi  =  \"l\"  >?attr/colorPrimaryVariant\u003C/  item  >\n           \u003C!-- Налаштуйте вашу тему тут -->\n       \u003C/  style  >\n   \u003C/  resources  >\n  Опис теми:    Тема  визначається за допомогою елемента   \u003Cstyle> .   Атрибут   parent  вказує на батьківську тему, від якої поточна тема успадковує всі стилі. У цьому прикладі тема   Theme.ViewApp  успадковує стилі від теми   Theme.MaterialComponents.DayNight.DarkActionBar .  Можна визначати   власні стилі , наприклад, задавати атрибути   colorPrimary ,   colorSecondary  тощо.  Атрибути кольорів:   Для властивості   colorPrimary  використовується ресурс   @color/purple_500 , який задає основний колір бренду.   Семантичні імена  (наприклад,   colorPrimary ) полегшують роботу з темами.  Зміна кольорів:  Для зміни вигляду можна змінити значення властивості, наприклад:     \u003C  item   name  =  \"colorPrimary\"  >#1565C0\u003C/  item  >\n  Це змінить колір фону заголовка та кнопки.  Застосування зміненої теми:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  Button\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Hello Android\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  При застосуванні зміненої теми колір кнопки та заголовка автоматично оновиться відповідно до нової характеристики   colorPrimary .\n   Створення власної теми  Замість використання вбудованих тем ми можемо створити свою. Для цього додаємо до папки   res/values  новий файл   mythemes.xml  і визначаємо в ньому наступне вміст:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  resources  >\n       \u003C  style   name  =  \"MyTheme\"   parent  =  \"Theme.AppCompat.Light\"  >\n           \u003C  item   name  =  \"android:textColor\"  >#FF018786\u003C/  item  >\n           \u003C  item   name  =  \"android:textSize\"  >28sp\u003C/  item  >\n       \u003C/  style  >\n   \u003C/  resources  >\n  Отже, ми створили стиль   \"MyTheme\" , який успадковує стиль   Theme.AppCompat.Light . В цьому стилі ми перевизначили дві властивості: висоту шрифта (  textSize ) — 28sp, а також колір тексту (  textColor ) — #FF018786.  Тепер визначимо цей стиль як тему для додатку в файлі   AndroidManifest.xml :     \u003C  application\n       android:allowBackup  =  \"true\"\n       android:icon  =  \"@mipmap/ic_launcher\"\n       android:label  =  \"@string/app_name\"\n       android:roundIcon  =  \"@mipmap/ic_launcher_round\"\n       android:supportsRtl  =  \"true\"\n       android:theme  =  \"@style/MyTheme\"  >   \u003C!-- застосування теми -->\n    Нехай у нас буде наступна розмітка в   activity_main.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n   \n       \u003C  TextView\n           android:id  =  \"@+id/textView1\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:gravity  =  \"center\"\n           android:text  =  \"Android Lollipop\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toTopOf  =  \"@+id/textView2\"\n           />\n       \u003C  TextView\n           android:id  =  \"@+id/textView2\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:gravity  =  \"center\"\n           android:text  =  \"Android Marshmallow\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintBottom_toTopOf  =  \"@+id/textView3\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/textView1\"\n           />\n       \u003C  TextView\n           android:id  =  \"@+id/textView3\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:gravity  =  \"center\"\n           android:text  =  \"Android Nougat\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/textView2\"\n           />\n   \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Як видно, для елементів   TextView  не встановлено атрибути   textSize  та   textColor , але оскільки вони визначені в темі, яка застосовується глобально до нашого додатку, елементи   TextView  будуть використовувати ці стилі.\n   Застосування теми до activity  Раніше теми застосовувалися глобально до всього додатку. Однак також можна застосувати їх до окремого класу   Activity . Для цього потрібно змінити файл манифеста   AndroidManifest.xml . Наприклад:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  manifest   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       package  =  \"com.example.viewapp\"\n       android:versionCode  =  \"1\"\n       android:versionName  =  \"1.0\"  >\n   \n       \u003C  application\n           android:allowBackup  =  \"true\"\n           android:icon  =  \"@mipmap/ic_launcher\"\n           android:label  =  \"@string/app_name\"\n           android:roundIcon  =  \"@mipmap/ic_launcher_round\"\n           android:supportsRtl  =  \"true\"\n           android:theme  =  \"@style/Theme.ViewApp\"  >\n           \n           \u003C  activity   android:name  =  \".MainActivity\"   android:theme  =  \"@style/MyTheme\"  >\n               \u003C  intent-filter  >\n                   \u003C  action   android:name  =  \"android.intent.action.MAIN\"   />\n                   \u003C  category   android:name  =  \"android.intent.category.LAUNCHER\"   />\n               \u003C/  intent-filter  >\n           \u003C/  activity  >\n       \u003C/  application  >\n   \n   \u003C/  manifest  >\n  Атрибут   android:theme  елемента   \u003Cactivity>  вказує на тему, яку застосовують до   MainActivity . Тобто глобально до додатку застосовується тема   \"Theme.ViewApp\" , а до   MainActivity  —   \"MyTheme\" .  Застосування теми до ієрархії віджетів  Також можна застосувати тему до ієрархії віджетів, встановивши атрибут   android:theme  у елементі, до якого (включаючи його вкладені елементи) ми хочемо застосувати тему. Наприклад, застосування теми до   ConstraintLayout  і його елементів:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:theme  =  \"@style/MyTheme\"  >\n   \n       \u003C  TextView\n           android:id  =  \"@+id/textView1\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:gravity  =  \"center\"\n           android:text  =  \"Android Lollipop\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"   />\n       \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":528,"path":529,"dir":395,"title":530,"description":531,"keywords":532,"body":538},"content:1.android:3.lesson3:18.menu.md","/android/lesson3/menu","Створення меню","Меню в додатках представляє клас android.view.Menu, і кожен Activity асоціюється з об'єктом цього типу. Об'єкт android.view.Menu може містити різну кількість елементів, а ті, в свою чергу, можуть містити піделементи.",[533,534,535,536,537],"Визначення меню в xml","Тег \u003Cmenu> в Android","Наповнення меню елементами","Обробка натискань в меню","Програмне створення меню","  Створення меню  Меню в додатках представляє клас   android.view.Menu , і кожен   Activity  асоціюється з об'єктом цього типу. Об'єкт   android.view.Menu  може містити різну кількість елементів, а ті, в свою чергу, можуть містити піделементи.  Визначення меню в xml  Меню, як і файли інтерфейсу чи зображення, також є ресурсом. Однак при створенні нового проекту з типом   Empty Activity  за замовчуванням немає жодних ресурсів меню, тому їх потрібно додавати вручну, якщо це необхідно. Для визначення ресурсів меню в проекті, натискаємо правою кнопкою миші на каталог   res  і в списку вибираємо пункт   New -> Android Resource File :   \nДалі у вікні, що з'явилося, вкажемо для імені файлу назву   main_menu , а для поля   Resource Type  (тип ресурсу) виберемо   Menu :\n  \nПісля цього в каталозі res буде створено підкаталог   menu , у якому міститиметься файл   main_menu.xml .   \nЗа замовчуванням цей файл визначає один порожній елемент   menu :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  menu   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"  >\n    \n   \u003C/  menu  >\n  Змінимо вміст файлу, визначивши кілька пунктів:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  menu   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"  >\n       \u003C  item\n           android:id  =  \"@+id/action_settings\"\n           android:orderInCategory  =  \"1\"\n           android:title  =  \"Настройки\"   />\n       \u003C  item\n           android:id  =  \"@+id/save_settings\"\n           android:orderInCategory  =  \"3\"\n           android:title  =  \"Сохранить\"   />\n       \u003C  item\n           android:id  =  \"@+id/open_settings\"\n           android:orderInCategory  =  \"2\"\n           android:title  =  \"Открыть\"   />\n   \u003C/  menu  >\n  Тег   \u003Cmenu>  в Android  Тег   \u003Cmenu>  є кореневим елементом файлу і визначає меню, яке складається з одного або кількох елементів   \u003Citem>  та   \u003Cgroup> .  Елемент   \u003Citem>  Елемент   \u003Citem>  представляє об'єкт   MenuItem , який є одним із елементів меню. Цей елемент може містити внутрішній піделемент   \u003Cmenu> , за допомогою якого створюється підменю.  Елемент   \u003Citem>  включає такі атрибути, які визначають його зовнішній вигляд і поведінку:    android:id : унікальний id елемента меню, який дозволяє його ідентифікувати при виборі користувачем і знайти через пошук ресурсу за id.   android:icon : посилання на ресурс   drawable , який задає зображення для елемента (наприклад:   android:icon=\"@drawable/ic_help\" ).   android:title : посилання на ресурс рядка, який містить заголовок елемента. За замовчуванням значення - \"Settings\".   android:orderInCategory : порядок елемента в меню.  Наповнення меню елементами  Ми визначили меню з трьома елементами, але саме визначення елементів у файлі ще не створює меню. Це лише декларативний опис. Щоб вивести його на екран, нам потрібно використовувати його в класі   Activity . Для цього слід перевизначити метод   onCreateOptionsMenu . Тож, давайте перейдемо до класу   MainActivity  і змінемо його таким чином:     package   com.example.menuapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   \n   import   android.os.Bundle  ;\n   import   android.view.Menu  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n   \n       @  Override\n       public   boolean   onCreateOptionsMenu  (  Menu   menu  ) {\n   \n           getMenuInflater  ().  inflate  (R.menu.main_menu, menu);\n           return   true  ;\n       }\n   }\n  Метод   getMenuInflater()  повертає об'єкт   MenuInflater , у якого викликається метод   inflate() . Цей метод, як перший параметр, приймає ресурс, який представляє наше декларативне опис меню в xml, і заповнює їм об'єкт   menu , переданий як другий параметр.  Запустимо додаток за замовчуванням і натиснемо на кнопку меню в правому верхньому кутку:\n   Обробка натискань в меню  Якщо ми натиснемо на будь-який з пунктів меню, нічого не станеться. Щоб прив'язати дії до меню, потрібно перевизначити в класі   Activity  метод   onOptionsItemSelected .  Для виведення вибраного елемента меню в файлі   activity_main.xml  визначимо текстове поле з   id=header :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"   >\n   \n       \u003C  TextView\n           android:id  =  \"@+id/selectedMenuItem\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Hello World!\"\n           android:textSize  =  \"28sp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n   \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Змінимо клас   MainActivity :     package   com.example.menuapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   \n   import   android.os.Bundle  ;\n   import   android.view.Menu  ;\n   import   android.view.MenuItem  ;\n   import   android.widget.TextView  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n   \n       @  Override\n       public   boolean   onCreateOptionsMenu  (  Menu   menu  ) {\n   \n           getMenuInflater  ().  inflate  (R.menu.main_menu, menu);\n           return   true  ;\n       }\n   \n       @  Override\n       public   boolean   onOptionsItemSelected  (  MenuItem   item  ) {\n           int   id   =   item.  getItemId  ();\n           TextView   headerView   =   findViewById  (R.id.selectedMenuItem);\n           switch  (id){\n               case   R.id.action_settings   :\n                   headerView.  setText  (  \"Настройки\"  );\n                   return   true  ;\n               case   R.id.open_settings  :\n                   headerView.  setText  (  \"Открыть\"  );\n                   return   true  ;\n               case   R.id.save_settings  :\n                   headerView.  setText  (  \"Сохранить\"  );\n                   return   true  ;\n           }\n           //headerView.setText(item.getTitle());\n           return   super  .  onOptionsItemSelected  (item);\n       }\n   }\n  Щоб зрозуміти, який пункт меню вибрано, спочатку отримуємо його ідентифікатор   int id = item.getItemId() . Потім проходимо через конструкцію   switch..case  і вибираємо потрібний варіант, виконуючи відповідні дії. У даному випадку встановлюємо текст у   TextView .    Варто зауважити, що в цьому випадку, якщо наша задача полягала б у тому, щоб просто вивести текст вибраного пункту меню, то замість конструкції   switch  ми могли б просто написати так:     headerView.  setText  (item.  getTitle  ());\n  Програмне створення меню  Окрім визначення елементів меню в XML, можна також створити меню програмним способом. Для додавання нових пунктів меню використовується метод   add()  класу   Menu .  Наприклад, змінімо код   MainActivity :     package   com.example.menuapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   \n   import   android.os.Bundle  ;\n   import   android.view.Menu  ;\n   import   android.view.MenuItem  ;\n   import   android.widget.TextView  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n   \n       @  Override\n       public   boolean   onCreateOptionsMenu  (  Menu   menu  ) {\n           super  .  onCreateOptionsMenu  (menu);\n           menu.  add  (  \"Налаштування\"  );\n           menu.  add  (  \"Відкрити\"  );\n           menu.  add  (  \"Зберегти\"  );\n           return   true  ;\n       }\n   \n       @  Override\n       public   boolean   onOptionsItemSelected  (  MenuItem   item  ) {\n           String   title   =   item.  getTitle  ().  toString  ();\n           TextView   headerView   =   findViewById  (R.id.selectedMenuItem);\n           headerView.  setText  (title);\n   \n           return   super  .  onOptionsItemSelected  (item);\n       }\n   }\n  Використана версія методу   add()  приймає заголовок для пункту меню.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":540,"path":541,"dir":395,"title":542,"description":7,"keywords":543,"body":547},"content:1.android:3.lesson3:19.menugroup-submenu.md","/android/lesson3/menugroup-submenu","Групи в меню та підменю",[544,545,546],"Створення підменю","Групи в меню","Програмне створення груп в меню та підменю","  Групи в меню та підменю  Створення підменю  Для створення підменю у файлі розмітки меню визначимо внутрішній елемент   menu :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  menu   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"  >\n       \u003C  item\n           android:id  =  \"@+id/action_settings\"\n           android:title  =  \"Налаштування\"  >\n           \u003C  menu  >\n               \u003C  item   android:id  =  \"@+id/save_settings\"\n                   android:title  =  \"Зберегти\"   />\n               \u003C  item   android:id  =  \"@+id/open_settings\"\n                   android:title  =  \"Відкрити\"   />\n           \u003C/  menu  >\n    \n       \u003C/  item  >\n       \u003C  item\n           android:id  =  \"@+id/action_move\"\n           android:title  =  \"Перехід\"  >\n           \u003C  menu  >\n               \u003C  item   android:id  =  \"@+id/forward\"\n                   android:title  =  \"Вперед\"   />\n               \u003C  item   android:id  =  \"@+id/back\"\n                   android:title  =  \"Назад\"   />\n           \u003C/  menu  >\n    \n       \u003C/  item  >\n   \u003C/  menu  >\n  Після натискання на меню відобразяться елементи верхнього рівня, після натискання на які ми можемо перейти до підменю:\n   Групи в меню  Використання елемента   group  дозволяє оформити елементи меню в групу:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  menu   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"  >\n   \n       \u003C  group   android:checkableBehavior  =  \"single\"  >\n           \u003C  item\n               android:id  =  \"@+id/action_settings\"\n               android:title  =  \"Налаштування\"\n               android:checked  =  \"true\"   />\n           \u003C  item   android:id  =  \"@+id/save_settings\"\n               android:title  =  \"Зберегти\"   />\n           \u003C  item   android:id  =  \"@+id/open_settings\"\n               android:title  =  \"Відкрити\"    />\n       \u003C/  group  >\n   \u003C/  menu  >\n  У визначенні групи ми можемо встановити атрибут   android:checkableBehavior . Цей атрибут може приймати наступні значення:   single  (для кожного елемента створюється радіокнопка),   all  (для кожного елемента створюється прапорчик) та   none .  У цьому випадку для кожного елемента буде створюватися радіокнопка (візуально кружок). І для першого елемента встановлюється відмічена радіокнопка (  android:checked=\"true\" ).  У файлі розмітки інтерфейсу   activity_main.xml  також повинно бути визначено текстове поле:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"   >\n   \n       \u003C  TextView\n           android:id  =  \"@+id/selectedMenuItem\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"28sp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n   \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  А в класі   MainActivity  визначимо виділення радіокнопки у вибраному пункті меню:     package   com.example.menuapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   \n   import   android.os.Bundle  ;\n   import   android.view.Menu  ;\n   import   android.view.MenuItem  ;\n   import   android.widget.TextView  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n   \n       @  Override\n       public   boolean   onCreateOptionsMenu  (  Menu   menu  ) {\n           getMenuInflater  ().  inflate  (R.menu.main_menu, menu);\n           return   true  ;\n       }\n   \n       @  Override\n       public   boolean   onOptionsItemSelected  (  MenuItem   item  ) {\n           int   id   =   item.  getItemId  ();\n           TextView   headerView   =   findViewById  (R.id.selectedMenuItem);\n           switch  (id){\n               case   R.id.action_settings   :\n                   headerView.  setText  (  \"Налаштування\"  );\n                   return   true  ;\n               case   R.id.open_settings  :\n                   headerView.  setText  (  \"Відкрити\"  );\n                   return   true  ;\n               case   R.id.save_settings  :\n                   headerView.  setText  (  \"Зберегти\"  );\n                   return   true  ;\n           }\n           return   super  .  onOptionsItemSelected  (item);\n       }\n   }\n    Програмне створення груп в меню та підменю  Також групи та підменю можна створювати програмним способом. Тож змінімо код   MainActivity :     package   com.example.menuapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   \n   import   android.os.Bundle  ;\n   import   android.view.Menu  ;\n   import   android.view.MenuItem  ;\n   import   android.widget.TextView  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n   \n       @  Override\n       public   boolean   onCreateOptionsMenu  (  Menu   menu  ) {\n           super  .  onCreateOptionsMenu  (menu);\n   \n           menu.  add  (  0          // Група\n                   ,  1          // id\n                   ,  0          // порядок\n                   ,  \"Створити\"  );    // заголовок\n   \n           menu.  add  (  0  ,  2  ,  1  ,  \"Відкрити\"  );\n           menu.  add  (  0  ,  3  ,  2  ,  \"Зберегти\"  );\n           return   true  ;\n       }\n   \n       @  Override\n       public   boolean   onOptionsItemSelected  (  MenuItem   item  ) {\n           int   id   =   item.  getItemId  ();\n           TextView   headerView   =   findViewById  (R.id.selectedMenuItem);\n   \n           switch  (id){\n               case   1   :\n                   headerView.  setText  (  \"Створити документ\"  );\n                   return   true  ;\n               case   2  :\n                   headerView.  setText  (  \"Відкрити документ\"  );\n                   return   true  ;\n               case   3  :\n                   headerView.  setText  (  \"Зберегти документ\"  );\n                   return   true  ;\n           }\n   \n           return   super  .  onOptionsItemSelected  (item);\n       }\n   }\n  Використаний тут метод   add()  додає пункт у меню, приймаючи наступні параметри: номер групи, id, порядок елемента в меню та заголовок елемента.    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":549,"path":550,"dir":551,"title":552,"description":553,"keywords":554,"body":558},"content:1.android:4.lesson4:1.fragments.md","/android/lesson4/fragments","lesson4","Введення у фрагменти","Організація додатка на основі декількох activity не завжди може бути оптимальною. Світ ОС Android досить сильно фрагментований і складається з багатьох пристроїв. І якщо для мобільних апаратів із невеликими екранами взаємодія між різними activity має доволі непоганий вигляд, то на великих екранах - планшетах, телевізорах - вікна activity мали б не дуже гарний вигляд завдяки великому розміру екрана. Власне тому і з'явилася концепція фрагментів.",[555,556,557],"Додавання фрагмента в Activity","Додавання логіки до фрагмента","Додавання фрагмента в коді","  Введення у фрагменти  Організація додатка на основі декількох activity не завжди може бути оптимальною. Світ ОС Android досить сильно фрагментований і складається з багатьох пристроїв. І якщо для мобільних апаратів із невеликими екранами взаємодія між різними activity має доволі непоганий вигляд, то на великих екранах - планшетах, телевізорах - вікна activity мали б не дуже гарний вигляд завдяки великому розміру екрана. Власне тому і з'явилася концепція фрагментів.   Фрагмент  являє собою шматочок візуального інтерфейсу застосунку, який може використовуватися повторно і багаторазово. У фрагмента може бути   власний файл layout , у фрагментів є   свій власний життєвий цикл .   Фрагмент існує в контексті activity  і має свій життєвий цикл, поза activity відокремлено він існувати не може.   Кожна activity може мати кілька фрагментів .    Для початку роботи з фрагментами створимо новий проєкт із порожньою   MainActivity . І спочатку створимо перший фрагмент. Але відразу варто зазначити, що не вся функціональність фрагментів за замовчуванням може бути доступною в проєкті, оскільки розташовується в окремій бібліотеці -   AndroidX Fragment library . І спочатку необхідно підключити до проекту цю бібліотеку у файлі   build.gradle .    Знайдемо в ньому секцію   dependencies , яка за замовчуванням має приблизно такий вигляд:     dependencies {\n    \n       implementation   'androidx.appcompat:appcompat:1.3.1'\n       implementation   'com.google.android.material:material:1.4.0'\n       implementation   'androidx.constraintlayout:constraintlayout:2.1.0'\n       testImplementation   'junit:junit:4.+'\n       androidTestImplementation   'androidx.test.ext:junit:1.1.3'\n       androidTestImplementation   'androidx.test.espresso:espresso-core:3.4.0'\n   }\n  На її початок додамо рядок     implementation   \"androidx.fragment:fragment:1.3.6\"\n  Тобто в моєму випадку вийде     dependencies {\n    \n       implementation   \"androidx.fragment:fragment:1.3.6\"\n        \n       implementation   'androidx.appcompat:appcompat:1.3.1'\n       implementation   'com.google.android.material:material:1.4.0'\n       implementation   'androidx.constraintlayout:constraintlayout:2.1.0'\n       testImplementation   'junit:junit:4.+'\n       androidTestImplementation   'androidx.test.ext:junit:1.1.3'\n       androidTestImplementation   'androidx.test.espresso:espresso-core:3.4.0'\n   }\n    І потім натиснемо на з'явившуся посилання   \"Sync Now\" .   Фактично фрагмент  — це звичайний клас Java, який успадковується від класу   Fragment . Однак, як і клас   Activity , фрагмент може використовувати xml-файли   layout  для визначення графічного інтерфейсу. І таким чином, ми можемо додати окремо клас Java, який представляє фрагмент, та файл xml для зберігання в ньому розмітки інтерфейсу, яку буде використовувати фрагмент.  Отже, додамо до папки   res/layout  новий файл   fragment_content.xml  і визначимо в ньому наступний код:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n        \n       \u003C  Button\n           android:id  =  \"@+id/updateButton\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Оновити\"\n           app:layout_constraintBottom_toTopOf  =  \"@+id/dateTextView\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n        \n       \u003C  TextView\n           android:id  =  \"@+id/dateTextView\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Привіт з Фрагмента\"\n           android:textSize  =  \"28sp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/updateButton\"   />\n        \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Фрагменти містять ті ж елементи керування, що й   activity . Зокрема, тут визначено кнопку та текстове поле, які складатимуть інтерфейс фрагмента.  Тепер створимо сам клас фрагмента. Для цього додамо до однієї папки з   MainActivity  новий клас. Для цього натиснемо на папку правою кнопкою миші та виберемо в меню   New -> Java Class . Назвемо новий клас   ContentFragment  та визначимо в ньому наступний вміст:     package   com.example.fragmentapp  ;\n   \n   import   androidx.fragment.app.Fragment  ;\n   \n   public   class   ContentFragment   extends   Fragment   {\n   \n       public   ContentFragment  (){\n           super  (R.layout.fragment_content);\n       }\n   }\n  Клас фрагмента повинен успадковуватися від класу   Fragment .  Щоб вказати, що фрагмент буде використовувати певний xml-файл   layout , ідентифікатор ресурсу   layout  передається в виклик конструктора батьківського класу (тобто класу   Fragment ).  Весь проєкт матиме такий вигляд:\n   Додавання фрагмента в Activity  Для використання фрагмента додамо його в   MainActivity . Для цього змінемо файл   activity_main.xml , який визначає інтерфейс для   MainActivity :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.fragment.app.FragmentContainerView\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:id  =  \"@+id/fragment_container_view\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:name  =  \"com.example.fragmentapp.ContentFragment\"   />\n  Для додавання фрагмента застосовується елемент   FragmentContainerView . По суті,   FragmentContainerView  представляє об'єкт   View , який розширює клас   FrameLayout  і призначений спеціально для роботи з фрагментами. Власне, крім фрагментів, він більше нічого не може містити.  Його атрибут   android:name  вказує на ім'я класу фрагмента, який буде використовуватися. У моєму випадку — повне ім'я класу фрагмента з урахуванням пакета   com.example.fragmentapp.ContentFragment .  Код класу   MainActivity  залишається тим самим, що й при створенні проєкту:     package   com.example.fragmentapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n   }\n  Якщо ми запустимо застосунок, то побачимо фактично той самий інтерфейс, який ми могли б зробити і через   activity , тільки в даному випадку інтерфейс буде визначено у фрагменті.\n   Варто зазначити, що Android Studio представляє готовий шаблон для додавання фрагмента. Власне скористаємося цим способом.  Для цього натиснемо на папку, де міститься клас   MainActivity , правою кнопкою миші і в меню, що з'явиться, виберемо   New -> Fragment -> Fragment(Blank) :\n   Цей шаблон запропонувати вказати клас фрагмента і назву файлу пов'язаного з ним класу розмітки інтерфейсу.\n   Додавання логіки до фрагмента  Фрагмент визначає кнопку. Тепер додамо до цієї кнопки певну дію. Для цього змінемо клас   ContentFragment :     package   com.example.fragmentapp  ;\n   \n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.Button  ;\n   import   android.widget.TextView  ;\n   \n   import   androidx.annotation.NonNull  ;\n   import   androidx.annotation.Nullable  ;\n   import   androidx.fragment.app.Fragment  ;\n   \n   import   java.util.Date  ;\n   \n   public   class   ContentFragment   extends   Fragment   {\n   \n       public   ContentFragment  (){\n           super  (R.layout.fragment_content);\n       }\n   \n       @  Override\n       public   void   onViewCreated  (@  NonNull   View   view  , @  Nullable   Bundle   savedInstanceState  ) {\n           super  .  onViewCreated  (view, savedInstanceState);\n           Button   updateButton   =   view.  findViewById  (R.id.updateButton);\n           TextView   updateBox   =   view.  findViewById  (R.id.dateTextView);\n   \n           updateButton.  setOnClickListener  (  new   View.  OnClickListener  () {\n               @  Override\n               public   void   onClick  (  View   v) {\n                   String   curDate   =   new   Date  ().  toString  ();\n                   updateBox.  setText  (curDate);\n               }\n           });\n       }\n   }\n  Тут переозначено метод   onViewCreated  класу   Fragment , який викликається після створення об'єкта   View  для візуального інтерфейсу, що представляє цей фрагмент. Створений об'єкт   View  передається як перший параметр. Далі ми можемо отримати конкретні елементи управління в рамках цього об'єкта   View , зокрема   TextView  і   Button , і виконати з ними певні дії. У даному випадку в обробнику натискання кнопки в текстовому полі відображається поточна дата.    Додавання фрагмента в коді  Крім визначення фрагмента у xaml-файлі інтерфейсу, ми можемо додати його динамічно в activity.  Для цього змінимо файл   activity_main.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.fragment.app.FragmentContainerView\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:id  =  \"@+id/fragment_container_view\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"   />\n  І також змінимо клас   MainActivity :     package   com.example.fragmentapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   \n   import   android.os.Bundle  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n           if   (savedInstanceState   ==   null  ) {\n               getSupportFragmentManager  ().  beginTransaction  ()\n                       .  add  (R.id.fragment_container_view, ContentFragment.class,   null  )\n                       .  commit  ();\n           }\n       }\n   }\n  Метод   getSupportFragmentManager()  повертає об'єкт   FragmentManager , який керує фрагментами.  Об'єкт   FragmentManager  за допомогою методу   beginTransaction()  створює об'єкт   FragmentTransaction .   FragmentTransaction  виконує два методи:   add()  і   commit() . Метод   add()  додає фрагмент:   add(R.id.fragment_container_view, new ContentFragment())  — першим аргументом передається ресурс розмітки, в який потрібно додати фрагмент (це визначений в   activity_main.xml  елемент   androidx.fragment.app.FragmentContainerView ). І метод   commit()  підтверджує і завершує операцію додавання.  Кінцевий результат такого додавання фрагмента буде таким самим, як і при явному визначенні фрагмента через елемент   FragmentContainerView  в розмітці інтерфейсу.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":560,"path":561,"dir":551,"title":562,"description":563,"keywords":564,"body":567},"content:1.android:4.lesson4:2.lifecycle-of-fragments.md","/android/lesson4/lifecycle-of-fragments","Життєвий цикл фрагментів","Кожен клас фрагмента успадковується від базового класу Fragment і має свій життєвий цикл, що складається з низки етапів:",[565,566],"Методи життєвого циклу фрагмента","Lifecycle","  Життєвий цикл фрагментів  Кожен клас фрагмента успадковується від базового класу Fragment і має свій життєвий цикл, що складається з низки етапів:    Кожен етап життєвого циклу описується однією з констант перерахунку   Lifecycle.State :    INITIALIZED   CREATED   STARTED   RESUMED   DESTROYED  Варто зауважити, що подання фрагмента (його візуальний інтерфейс або View) має окремий життєвий цикл.  Під час створення фрагмент знаходиться в стані   INITIALIZED . Щоб фрагмент пройшов усі інші етапи життєвого циклу, фрагмент необхідно передати в об'єкт   FragmentManager , який далі визначає стан фрагмента і переводить фрагмент з одного стану в інший.  Методи життєвого циклу фрагмента    onCreate()  — відбувається створення фрагмента. У цьому методі ми можемо отримати раніше збережений стан фрагмента через параметр методу   Bundle savedInstanceState . (Якщо фрагмент створюється вперше, то цей об'єкт має значення   null ) Цей метод викликається після виклику відповідного методу   onCreate()  у   activity .     public   void   onCreate  (  Bundle   savedInstanceState)\n    onCreateView()  — фрагмент створює подання (View або візуальний інтерфейс). У цьому методі ми можемо встановити, який саме візуальний інтерфейс буде використовувати фрагмент. Під час виконання цього методу подання фрагмента переходить у стан   INITIALIZED , а сам фрагмент все ще знаходиться в стані   CREATED .     public   View   onCreateView  (  LayoutInflater   inflater,   ViewGroup   container,   Bundle   savedInstanceState)\n  Перший параметр — об'єкт   LayoutInflater  дозволяє отримати вміст ресурсу   layout  і передати його у фрагмент.  Другий параметр — об'єкт   ViewGroup  представляє контейнер, у який буде завантажуватись фрагмент.  Третій параметр — об'єкт   Bundle  представляє стан фрагмента. (Якщо фрагмент завантажується вперше, то дорівнює   null )  На виході метод повертає створене за допомогою   LayoutInflater  подання у вигляді об'єкта   View  — власне подання фрагмента.    onViewCreated()  — викликається після створення подання фрагмента.     public   void   onViewCreated   (  View   view,   Bundle   savedInstanceState)\n  Перший параметр — об'єкт   View  — подання фрагмента, яке було створене через метод   onCreateView .  Другий параметр — об'єкт   Bundle  представляє стан фрагмента. (Якщо фрагмент завантажується вперше, то дорівнює   null )    onViewStateRestored()  — отримує стан подання фрагмента. Після виконання цього методу подання фрагмента переходить у стан   CREATED .     public   void   onViewStateRestored   (  Bundle   savedInstanceState)\n    onStart()  — викликається, коли фрагмент стає видимим і разом з поданням переходить у стан   STARTED .     public   void   onStart   ()\n    onResume()  — викликається, коли фрагмент стає активним, і користувач може з ним взаємодіяти. При цьому фрагмент і його подання переходять у стан   RESUMED .     public   void   onResume   ()\n    onPause()  — фрагмент продовжує залишатися видимим, але вже не активний, і разом з поданням переходить у стан   STARTED .     public   void   onPause   ()\n    onStop()  — фрагмент більше не є видимим і разом з поданням переходить у стан   CREATED .     public   void   onStop   ()\n  На цьому етапі життєвого циклу ми можемо зберегти стан фрагмента за допомогою методу   onSaveInstanceState() . Однак варто враховувати, що виклик цього методу залежить від версії API. До API 28   onSaveInstanceState()  викликається до   onStop() , а починаючи з API 28 після   onStop() .    onDestroyView()  — знищується подання фрагмента. Подання переходить у стан   DESTROYED .   onDestroy()  — остаточне знищення фрагмента — він також переходить у стан   DESTROYED .  Додатково для фрагмента визначено два методи зворотного виклику, які пов'язані з приєднанням фрагмента до   activity :   Коли фрагмент додається в   FragmentManager  і приєднується до певного класу   Activity , у фрагмента викликається метод   onAttach() . Цей метод викликається до всіх інших методів життєвого циклу. З цього моменту фрагмент стає активним, і   FragmentManager  починає керувати його життєвим циклом.  Метод   onDetach()  викликається, коли фрагмент видаляється з   FragmentManager  і від'єднується від класу   Activity . Цей метод викликається після всіх інших методів життєвого циклу.  У коді класу фрагмента ми можемо перевизначити всі або частину з цих методів. Наприклад, нехай у нас буде визначено такий проєкт:    У каталозі   res/layout  визначено файл   layout  для фрагмента -   fragment_content.xml  з такою розміткою:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  Button\n           android:id  =  \"@+id/updateButton\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Обновить\"\n           app:layout_constraintBottom_toTopOf  =  \"@+id/dateTextView\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/dateTextView\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"26sp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/updateButton\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Клас фрагмента використовує цей файл для встановлення подання, а також визначає методи для управління життєвим циклом:     package   com.example.fragmentapp  ;\n    \n   import   android.content.Context  ;\n   import   android.os.Bundle  ;\n   import   android.view.LayoutInflater  ;\n   import   android.view.View  ;\n   import   android.view.ViewGroup  ;\n   import   android.widget.Button  ;\n   import   android.widget.TextView  ;\n    \n   import   androidx.annotation.NonNull  ;\n   import   androidx.annotation.Nullable  ;\n   import   androidx.fragment.app.Fragment  ;\n   import   android.util.Log  ;\n    \n   import   java.util.Date  ;\n    \n   public   class   ContentFragment   extends   Fragment   {\n    \n       private   final   static   String   TAG   =   \"ContentFragment\"  ;\n    \n       public   ContentFragment  (){\n           Log.  d  (TAG,   \"Constructor\"  );\n       }\n    \n       @  Override\n       public   void   onAttach  (@  NonNull   Context   context  ) {\n           super  .  onAttach  (context);\n           Log.  d  (TAG,   \"onAttach\"  );\n       }\n    \n       @  Override\n       public   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           Log.  d  (TAG,   \"onCreate\"  );\n       }\n    \n       @  Override\n       public   View   onCreateView  (  LayoutInflater   inflater  ,   ViewGroup   container  ,\n                                Bundle   savedInstanceState  ) {\n           Log.  d  (TAG,   \"onCreateView\"  );\n           return   inflater.  inflate  (R.layout.fragment_content, container,   false  );\n       }\n       @  Override\n       public   void   onViewCreated  (@  NonNull   View   view  , @  Nullable   Bundle   savedInstanceState  ) {\n           super  .  onViewCreated  (view, savedInstanceState);\n           Button   updateButton   =   view.  findViewById  (R.id.updateButton);\n           TextView   updateBox   =   view.  findViewById  (R.id.dateTextView);\n    \n           updateButton.  setOnClickListener  (  new   View.  OnClickListener  () {\n               @  Override\n               public   void   onClick  (  View   v) {\n                   String   curDate   =   new   Date  ().  toString  ();\n                   updateBox.  setText  (curDate);\n               }\n           });\n           Log.  d  (TAG,   \"onViewCreated\"  );\n       }\n    \n       @  Override\n       public   void   onViewStateRestored  (@  Nullable   Bundle   savedInstanceState  ) {\n           super  .  onViewStateRestored  (savedInstanceState);\n           Log.  d  (TAG,   \"onViewStateRestored\"  );\n       }\n    \n       @  Override\n       public   void   onStart  () {\n           super  .  onStart  ();\n           Log.  d  (TAG,   \"onStart\"  );\n       }\n    \n       @  Override\n       public   void   onResume  () {\n           super  .  onResume  ();\n           Log.  d  (TAG,   \"onResume\"  );\n       }\n    \n       @  Override\n       public   void   onPause  () {\n           super  .  onPause  ();\n           Log.  d  (TAG,   \"onPause\"  );\n       }\n    \n       @  Override\n       public   void   onStop  () {\n           super  .  onStop  ();\n           Log.  d  (TAG,   \"onStop\"  );\n       }\n    \n       @  Override\n       public   void   onDestroyView  () {\n           super  .  onDestroyView  ();\n           Log.  d  (TAG,   \"onDestroyView\"  );\n       }\n    \n       @  Override\n       public   void   onDestroy  () {\n           super  .  onDestroy  ();\n           Log.  d  (TAG,   \"onDestroy\"  );\n       }\n    \n       @  Override\n       public   void   onDetach  () {\n           super  .  onDetach  ();\n           Log.  d  (TAG,   \"onDetach\"  );\n       }\n   }\n  На відміну від попередньої статті, де розглядалося створення фрагмента, тут фрагмент встановлює подання в методі   onCreateView . Для цього в метод   inflate()  об'єкта   LayoutInflater  передається ідентифікатор ресурсу   layout  і контейнер — об'єкт   ViewGroup , в який буде завантажуватись фрагмент. В результаті метод   inflate()  повертає створене подання.     return   inflater.  inflate  (R.layout.fragment_content, container,   false  );\n  Під час виконання методу   onViewCreated()  подання вже створене, і воно передається як перший параметр — об'єкт   View , через який за допомогою ідентифікаторів ми можемо отримати візуальні елементи —   TextView  і   Button , які визначені в поданні.  Для решти методів життєвого циклу встановлено просте логування за допомогою методу   Log.d() .  Нехай у файлі   activity_main.xml  відбувається додавання фрагмента:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.fragment.app.FragmentContainerView\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:id  =  \"@+id/fragment_container_view\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:name  =  \"com.example.fragmentapp.ContentFragment\"   />\n  І клас   MainActivity :     package   com.example.fragmentapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n   }\n  Якщо ми запустимо проект, то на екрані пристрою ми побачимо візуальний інтерфейс, визначений для фрагмента.   \nА у вікні Logcat в Android Studio можна буде спостерігати логгування методів життєвого циклу\n   Lifecycle  Досить часто частина логіки програми зав'язана на життєвий цикл   Activity . Ми вмикаємо що-небудь у методах   onStart  або   onResume  і вимикаємо в   onPause  або   onStop .  Розглянемо приклад.  У нас є якийсь клас для роботи із сервером. Він має взаємодіяти із сервером, поки   Activity  відкрито. Відповідно, ми будемо підключати його до сервера під час показу   Activity  і відключати під час приховування   Activity .     public   class   MyServer   {\n   \n      public   void   connect  () {\n          // ...\n      }\n   \n      public   void   disconnect  () {\n          // ...\n      }\n   \n   }\n  Метод   connect  використовується для підключення до сервера,   disconnect  - для відключення.  Викликаємо ці методи в   onStart  і   onStop  в   Activity .     @  Override\n   protected   void   onStart  () {\n      super  .  onStart  ();\n      myServer.  connect  ();\n   }\n   \n   \n   @  Override\n   protected   void   onStop  () {\n      super  .  onStop  ();\n      myServer.  disconnect  ();\n   }\n  Тепер   MyServer  буде під'єднано, поки   Activity  мабуть на екрані.  Це цілком класична, часто використовувана схема. І в простому прикладі все виглядає непогано. Але в складних додатках зміст методів   onStart ,   onStop  тощо може складатися з декількох десятків рядків і бути досить заплутаним. Гугл рекомендує виносити цю логіку з   Activity . Давайте подивимося, як це можна зробити.  У Activity є метод   getLifecycle , який повертає об'єкт   Lifecycle . На цей об'єкт можна підписати слухачів, які отримуватимуть сповіщення при зміні   lifecycle-стану Activity .  Activity і фрагменти в   Support Library , починаючи з версії 26.1.0 реалізують інтерфейс   LifecycleOwner . Саме цей інтерфейс і додає їм метод   getLifecycle .  Тобто у вас має бути такий рядок у   build.gradle  файлі модуля, у секції   dependencies     implementation   'com.android.support:appcompat-v7:26.1.0'\n  Або використовуйте більш свіжу версію.  У нашому прикладі слухачем буде   MyServer . Щоб мати можливість підписатися на   Lifecycle , він повинен наслідувати інтерфейс   LifecycleObserver .     public   class   MyServer   implements   LifecycleObserver   {\n   \n      @  OnLifecycleEvent  (Lifecycle.Event.ON_START)\n      public   void   connect  () {\n          // ...\n      }\n   \n      @  OnLifecycleEvent  (Lifecycle.Event.ON_STOP)\n      public   void   disconnect  () {\n          // ...\n      }\n   \n   }\n  Зверніть увагу, що інтерфейс   LifecycleObserver  порожній. У ньому немає купи методів типу   onStart ,   onStop  тощо. Ми просто позначаємо в класі   MyServer  його ж власні методи анотацією   OnLifecycleEvent  і вказуємо, за якої   lifecycle-події  метод має бути викликаний.  У нашому прикладі ми вказуємо, що метод connect має викликатися в момент   onStart , а метод   disconnect  - у момент   onStop .  Залишилося підписати екземпляр   MyServer  на   Lifecycle .     @  Override\n   protected   void   onCreate  (  Bundle   savedInstanceState) {\n      super  .  onCreate  (savedInstanceState);\n      setContentView  (R.layout.activity_main);\n      // ...\n      getLifecycle  ().  addObserver  (myServer);\n   }\n  В Activity методом   getLifecycle  отримуємо   Lifecycle , і методом   addObserver  підписуємо   myServer .  А методи   onStart  і   onStop  в Activity нам більше не потрібні, їх можна видалити.  Тепер, під час переходу Activity зі стану   CREATED  у стан   STARTED , його об'єкт   Lifecycle  викличе метод   myServer.connect . А при переході зі   STARTED  у   CREATED  -   Lifecycle  викличе   myServer disconnect .  При цьому в   Acivity  це вимагало від нас мінімум коду - тільки підписати   myServer  на   Lifecycle . Все інше вирішує сам   MyServer .  На схемі нижче ви можете побачити, які стани проходить   Activity  і які події при цьому викликаються.   \nНічого нового тут для нас немає, все це ази Android. Тут ви можете бачити стани і події. Вони пов'язані дуже просто - при переході між станами відбуваються події.  Ці події ми вказували в анотаціях   OnLifecycleEvent  до методів об'єкта   MyServer .  Повний список подій можна подивитися в   документації .  Відписатися від   Lifecycle  можна методом   removeObserver  (  документація ).  Any  Ви можете використовувати подію   ON_ANY  для отримання всіх подій в одному методі         @  OnLifecycleEvent  (ON_ANY)\n       void   onAny  (  LifecycleOwner   source, Lifecycle.Event event) {\n           // ...\n       }\n  У цьому випадку всі події будуть викликати цей метод.  Використовуйте вхідний параметр   event , щоб визначити, яка саме подія відбулася  Стан  Якщо ви хочете дізнатися поточний стан Activity, то у його об'єкта   Lifecycle  є метод   getCurrentState :     if   (  getLifecycle  ().  getCurrentState  ()   ==   Lifecycle.State.RESUMED) {\n      // ...\n   }\n  Повний список станів можна подивитися в документації.  Також ви можете перевірити, що поточний стан   Activity  не нижчий за певний стан.     if   (  getLifecycle  ().  getCurrentState  ().  isAtLeast  (Lifecycle.State.STARTED)) {\n      // ...\n   }\n  Метод   isAtLeast  тут перевіряє, що стан   Activity  не нижчий, ніж   STARTED . Тобто або   STARTED , або   RESUMED .  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":569,"path":570,"dir":551,"title":571,"description":572,"keywords":573,"body":574},"content:1.android:4.lesson4:3.interaction-between-fragments.md","/android/lesson4/interaction-between-fragments","Взаємодія між фрагментами","Одна activity може використовувати кілька фрагментів, наприклад, з одного боку список, а з іншого - детальний опис обраного елемента списку. У такій конфігурації activity використовує два фрагменти, які між собою повинні взаємодіяти. Розглянемо базові принципи взаємодії фрагментів у додатку.",[],"  Взаємодія між фрагментами  Одна   activity  може використовувати кілька фрагментів, наприклад, з одного боку список, а з іншого - детальний опис обраного елемента списку. У такій конфігурації   activity  використовує два фрагменти, які між собою повинні взаємодіяти. Розглянемо базові принципи взаємодії фрагментів у додатку.  Створимо новий проєкт із порожньою   MainActivity . Далі створимо розмітку   layout  для фрагментів. Нехай у нас у додатку буде два фрагменти. Додамо в папку   res/layout  новий xml-файл   fragment_list.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"  >\n       \u003C  ListView\n           android:id  =  \"@+id/countriesList\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  >\n       \u003C/  ListView  >\n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Тут визначено елемент   ListView  для виведення списку об'єктів.  І також додамо для іншого фрагмента файл розмітки   fragment_detail.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"  >\n       \u003C  TextView\n           android:id  =  \"@+id/detailsText\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_gravity  =  \"center\"\n    \n           android:text  =  \"Не вибрано\"\n           android:textSize  =  \"22sp\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           />\n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Обидва фрагменти будуть максимально простими: один буде містити список, а другий — текстове поле. Логіка програми буде така: при виборі елемента в списку в одному фрагменті вибраний елемент повинен відобразитися в текстовому полі, яке знаходиться в другому фрагменті.  Далі додамо в проект в одну папку з   MainActivity  власне класи фрагментів. Додамо новий клас   ListFragment  з наступним вмістом:     package   com.example.fragmentapp  ;\n   \n   import   android.content.Context  ;\n   import   android.os.Bundle  ;\n   import   android.view.LayoutInflater  ;\n   import   android.view.View  ;\n   import   android.view.ViewGroup  ;\n   import   android.widget.AdapterView  ;\n   import   android.widget.ArrayAdapter  ;\n   import   android.widget.ListView  ;\n   import   androidx.fragment.app.Fragment  ;\n   \n   public   class   ListFragment   extends   Fragment   {\n   \n       interface   OnFragmentSendDataListener   {\n           void   onSendData  (  String   data  );\n       }\n   \n       private   OnFragmentSendDataListener   fragmentSendDataListener;\n       String  [] countries   =   {   \"Бразилія\"  ,   \"Аргентина\"  ,   \"Колумбія\"  ,   \"Чилі\"  ,   \"Уругвай\"  };\n   \n       @  Override\n       public   void   onAttach  (  Context   context  ) {\n           super  .  onAttach  (context);\n           try   {\n               fragmentSendDataListener   =   (OnFragmentSendDataListener) context;\n           }   catch   (  ClassCastException   e  ) {\n               throw   new   ClassCastException  (context.  toString  ()\n                       +   \" повинен реалізовувати інтерфейс OnFragmentInteractionListener\"  );\n           }\n       }\n   \n       @  Override\n       public   View   onCreateView  (  LayoutInflater   inflater  ,   ViewGroup   container  ,\n                                Bundle   savedInstanceState  ) {\n           View   view   =   inflater.  inflate  (R.layout.fragment_list, container,   false  );\n           // отримуємо елемент ListView\n           ListView   countriesList   =   view.  findViewById  (R.id.countriesList);\n           // створюємо адаптер\n           ArrayAdapter  \u003C  String  > adapter   =   new   ArrayAdapter  (  getContext  (), android.R.layout.simple_list_item_1, countries);\n           // встановлюємо для списку адаптер\n           countriesList.  setAdapter  (adapter);\n           // додаємо для списку слухач\n           countriesList.  setOnItemClickListener  (  new   AdapterView.  OnItemClickListener  (){\n               @  Override\n               public   void   onItemClick  (  AdapterView  \u003C?>   parent,   View   v,   int   position,   long   id)\n               {\n                   // отримуємо вибраний елемент\n                   String   selectedItem   =   (String)parent.  getItemAtPosition  (position);\n                   // Посилаємо дані Activity\n                   fragmentSendDataListener.  onSendData  (selectedItem);\n               }\n           });\n           return   view;\n       }\n   \n   }\n  Фрагменти не можуть напряму взаємодіяти між собою. Для цього треба звертатися до контексту, в якості якого виступає клас   Activity . Для звернення до   activity , зазвичай, створюється вкладений інтерфейс. У цьому випадку він називається   OnFragmentSendDataListener  з одним методом.     interface   OnFragmentSendDataListener   {\n           void   onSendData  (  String   data  );\n   }\n    \n   private   OnFragmentSendDataListener   fragmentSendDataListener;\n  Але щоб взаємодіяти з іншим фрагментом через   activity , нам треба прикріпити поточний фрагмент до   activity . Для цього в класі фрагмента визначений метод   onAttach(Context context) . В ньому відбувається установка об'єкта   OnFragmentSendDataListener :     fragmentSendDataListener   =   (OnFragmentSendDataListener) context;\n  При обробці натискання на елемент в списку ми можемо відправити   Activity  дані про вибраний об'єкт:     String   selectedItem   =   (String)parent.  getItemAtPosition  (position);\n   fragmentSendDataListener.  onSendData  (selectedItem);\n  Таким чином, при виборі об'єкта в списку   MainActivity  отримає вибраний об'єкт.  Тепер визначимо клас для другого фрагмента. Назвемо його   DetailFragment :     package   com.example.fragmentapp  ;\n   \n   import   android.os.Bundle  ;\n   import   android.view.LayoutInflater  ;\n   import   android.view.View  ;\n   import   android.view.ViewGroup  ;\n   import   android.widget.TextView  ;\n   import   androidx.fragment.app.Fragment  ;\n   \n   public   class   DetailFragment   extends   Fragment   {\n   \n       @  Override\n       public   View   onCreateView  (  LayoutInflater   inflater  ,   ViewGroup   container  ,\n                                Bundle   savedInstanceState  ) {\n           return   inflater.  inflate  (R.layout.fragment_detail, container,   false  );\n       }\n   \n       // оновлення текстового поля\n       public   void   setSelectedItem  (  String   selectedItem  ) {\n           TextView   view   =   getView  ().  findViewById  (R.id.detailsText);\n           view.  setText  (selectedItem);\n       }\n   }\n  Задача цього фрагмента — виведення певної інформації. Оскільки він не повинен передавати жодну інформацію іншому фрагменту, тут ми можемо обмежитися лише перевизначенням методу   onCreateView() , який в якості візуального інтерфейсу встановлює розмітку з файлу   fragment_detail.xml .  Але для імітації взаємодії між двома фрагментами, тут також визначений метод   setSelectedItem() , який оновлює текст у текстовому полі.  У підсумку вийде така структура:   \nТепер змінимо файл розмітки   activity_main.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"   >\n        \n       \u003C  androidx.fragment.app.FragmentContainerView\n           android:id  =  \"@+id/listFragment\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           android:name  =  \"com.example.fragmentapp.ListFragment\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toTopOf  =  \"@+id/detailFragment\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"  />\n    \n       \u003C  androidx.fragment.app.FragmentContainerView\n           android:id  =  \"@+id/detailFragment\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           android:name  =  \"com.example.fragmentapp.DetailFragment\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/listFragment\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"  />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  За допомогою двох елементів   FragmentContainerView  у   MainActivity  додаються два вище визначені фрагменти.  І наприкінці змінимо код   MainActivity :     package   com.example.fragmentapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity    implements   ListFragment.OnFragmentSendDataListener   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n    \n       @  Override\n       public   void   onSendData  (  String   selectedItem  ) {\n           DetailFragment   fragment   =   (DetailFragment)   getSupportFragmentManager  ()\n                   .  findFragmentById  (R.id.detailFragment);\n           if   (fragment   !=   null  )\n               fragment.  setSelectedItem  (selectedItem);\n       }\n   }\n  Для взаємодії фрагмента   ListFragment  з іншим фрагментом через   MainActivity  необхідно, щоб ця activity реалізовувала інтерфейс   OnFragmentSendDataListener . Для цього реалізуємо метод   onSendData() , який отримує фрагмент   DetailFragment  і викликає в ньому метод   setSelectedItem() .  В результаті вийде, що при виборі елемента в списку у фрагменті   ListFragment  буде спрацьовувати слухач списку, а саме його метод   onItemClick(AdapterView\u003C?> parent, View v, int position, long id) , який викликає метод   fragmentSendDataListener.onSendData(selectedItem); .   fragmentSendDataListener  встановлюється як   MainActivity , тому при цьому буде викликаний метод   setSelectedItem  у фрагмента   DetailFragment . Таким чином, відбудеться взаємодія між двома фрагментами.  Якщо ми запустимо проект, то на екран будуть виведені обидва фрагменти, які зможуть взаємодіяти між собою.    Однак поки що фрагменти однаково виводяться в одній   activity  як в альбомній, так і в портретній орієнтації незалежно від пристрою. Тому оптимізуємо застосунок.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":576,"path":577,"dir":551,"title":578,"description":579,"keywords":580,"body":581},"content:1.android:4.lesson4:4.fragments-in-landscape-and-portrait-mode.md","/android/lesson4/fragments-in-landscape-and-portrait-mode","Фрагменти в альбомному та портретному режимі","У минулій темі було розроблено додаток, який виводить обидва фрагменти на екран. Продовжимо роботу з цим проектом. Загалом було створено два фрагменти: ListFragment для відображення списку та DetailFragment для відображення обраного елемента у списку. І MainActivity виводила обидва фрагменти на екран:\n",[],"  Фрагменти в альбомному та портретному режимі  У минулій темі було розроблено додаток, який виводить обидва фрагменти на екран. Продовжимо роботу з цим проектом. Загалом було створено два фрагменти:   ListFragment  для відображення списку та   DetailFragment  для відображення обраного елемента у списку. І   MainActivity  виводила обидва фрагменти на екран:\n   Але відображення двох і більше фрагментів при портретній орієнтації не дуже оптимальне. Наприклад, у минулій темі додаток мав такий вигляд:\n   Але якщо список великий, то другий фрагмент, який відображає обраний елемент, відповідно йде вниз. При альбомній орієнтації вийде розташування ще більш неоптимальне. Тому спочатку змінимо файл   activity_main.xml , щоб зручніше розташовувати фрагменти в альбомній орієнтації:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"   >\n       \u003C  androidx.fragment.app.FragmentContainerView\n           android:id  =  \"@+id/listFragment\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           android:name  =  \"com.example.fragmentapp.ListFragment\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintRight_toLeftOf  =  \"@id/detailFragment\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"   />\n    \n       \u003C  androidx.fragment.app.FragmentContainerView\n           android:id  =  \"@+id/detailFragment\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           android:name  =  \"com.example.fragmentapp.DetailFragment\"\n           app:layout_constraintLeft_toRightOf  =  \"@id/listFragment\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"  />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Для зручнішого розташування за альбомної орієнтації, як правило, рішення досить просте - два фрагменти розташовуються горизонтально в ряд.    Тепер розглянемо як вдаліше розташувати фрагменти при портретній орієнтації. Нерідко в цьому випадку рішення таке - одномоментно екран відображає тільки один фрагмент.  Отже, створимо в проекті в папці   res , де зберігаються всі ресурси, підкаталог   layout-port , який буде зберігати файли інтерфейсу для портретної орієнтації. Для цього перемкнемося до повного вигляду проекту. Натиснемо на папку   res  правою кнопкою миші і в контекстному меню виберемо   New -> Android Resource Directory :   \nНазвемо нову папку   layout-port :\n  \nДалі додамо в   res/layout-port  новий файл activity_main.xml і визначимо в ньому такий код:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.fragment.app.FragmentContainerView\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:id  =  \"@+id/listFragment\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:name  =  \"com.example.fragmentapp.ListFragment\"   />\n  Цей файл буде використовуватися для портретної орієнтації   MainActivity . Таким чином,   MainActivity  у портретному режимі відображатиме лише один список.  Тепер додамо нову activity, яку назвемо   DetailActivity :   \nУ підсумку проєкт матиме такий вигляд:\n   У папці   res/layout  у файлі   activity_detail.xml  визначимо для   DetailActivity  такий інтерфейс:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.fragment.app.FragmentContainerView\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:id  =  \"@+id/detailFragment\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:name  =  \"com.example.fragmentapp.DetailFragment\"   />\n  Таким чином, інтерфейс   DetailActivity  визначатиметься завантажуваним фрагментом   DetailFragment .  Далі в коді   DetailActivity  визначимо такий код:     package   com.example.fragmentapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.content.res.Configuration  ;\n   import   android.os.Bundle  ;\n    \n   public   class   DetailActivity   extends   AppCompatActivity   {\n    \n       public   static   final   String   SELECTED_ITEM   =   \"SELECTED_ITEM\"  ;\n       String   selectedItem   =   \"Не обрано\"  ;\n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n    \n           if   (  getResources  ().  getConfiguration  ().orientation   ==   Configuration.ORIENTATION_LANDSCAPE) {\n               finish  ();\n               return  ;\n           }\n           setContentView  (R.layout.activity_detail);\n           Bundle   extras   =   getIntent  ().  getExtras  ();\n           if   (extras   !=   null  )\n               selectedItem   =   extras.  getString  (SELECTED_ITEM);\n       }\n    \n       @  Override\n       protected   void   onResume  () {\n           super  .  onResume  ();\n           DetailFragment   fragment   =   (DetailFragment)   getSupportFragmentManager  ()\n                   .  findFragmentById  (R.id.detailFragment);\n           if   (fragment   !=   null  )\n               fragment.  setSelectedItem  (selectedItem);\n       }\n   }\n  Тут насамперед перевіряємо конфігурацію. Оскільки ця activity призначена тільки для портретного режиму, то при альбомній орієнтації здійснюємо вихід:     if   (  getResources  ().  getConfiguration  ().orientation   ==   Configuration.ORIENTATION_LANDSCAPE) {\n       finish  ();\n       return  ;\n   }\n  Якщо пристрій перебуває в портретному режимі, то отримуємо передані дані за ключем   \"SELECTED_ITEM\" :     Bundle   extras   =   getIntent  ().  getExtras  ();\n   if   (extras   !=   null  )\n       selectedItem   =   extras.  getString  (SELECTED_ITEM);\n  Передбачається, що за ключем \"SELECTED_ITEM\" буде передаватися вибраний елемент списку з   MainActivity , коли вона буде знаходитися в портретній орієнтації.  І дуже важливий момент — нам потрібно передати це значення в текстове поле, яке визначене у фрагменті. Однак потрібно врахувати особливості життєвого циклу представлення фрагмента. У даному випадку перевизначенний метод   onResume() , тому що при виклику цього методу фрагмент   DetailActivity  вже буде видимий на екрані, і користувач зможе з ним взаємодіяти. Це також означає, що на цей момент вже буде активним і фрагмент, і його представлення. Наприклад, у методі   onCreate()  представлення фрагмента ще не створене повністю, тому ми не можемо в ньому отримати віджети, які визначені у фрагменті. Натомість можемо зробити це в методі   onResume() .     protected   void   onResume  () {\n           super  .  onResume  ();\n           DetailFragment   fragment   =   (DetailFragment)   getSupportFragmentManager  ()\n                   .  findFragmentById  (R.id.detailFragment);\n           if   (fragment   !=   null  )\n               fragment.  setSelectedItem  (selectedItem);\n       }\n  У цьому випадку ми отримуємо фрагмент   DetailFragment  за допомогою методу   getSupportFragmentManager()  і викликаємо його метод   setSelectedItem() . Як аргумент у цей метод передається строкове значення, передане через   Intent .  Також змінимо головну activity —   MainActivity :     package   com.example.fragmentapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.content.Intent  ;\n   import   android.os.Bundle  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   implements   ListFragment.OnFragmentSendDataListener   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n    \n       @  Override\n       public   void   onSendData  (  String   selectedItem  ) {\n           DetailFragment   fragment   =   (DetailFragment)   getSupportFragmentManager  ()\n                   .  findFragmentById  (R.id.detailFragment);\n           if   (fragment   !=   null   &&   fragment.  isVisible  ())\n               fragment.  setSelectedItem  (selectedItem);\n           else   {\n               Intent   intent   =   new   Intent  (  getApplicationContext  (),\n                       DetailActivity.class);\n               intent.  putExtra  (DetailActivity.SELECTED_ITEM, selectedItem);\n               startActivity  (intent);\n           }\n       }\n   }\n  За допомогою методу   fragment.isVisible()  ми можемо дізнатися, чи активний конкретний фрагмент в розмітці інтерфейсу. Якщо фрагмент   DetailFragment  на цей момент не видимий, то використовується портретний режим, і тому запускається   DetailActivity . В іншому випадку робота відбувається з фрагментом всередині   MainActivity , який в альбомному режимі відображає одразу два фрагменти —   ListFragment  і   DetailFragment .  Запустимо додаток і перейдемо в альбомний режим:\n  \nА при портретній орієнтації екран матиме інший вигляд:\n   html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":583,"path":584,"dir":551,"title":585,"description":586,"keywords":587,"body":588},"content:1.android:4.lesson4:5.threads.md","/android/lesson4/threads","Створення потоків і візуальний інтерфейс","Коли ми запускаємо додаток на Android, система створює потік, який називається основним потоком додатка або UI-потоком. Цей потік обробляє всі зміни та події інтерфейсу користувача. Однак для допоміжних операцій, таких як відправка або завантаження файлів, тривалі обчислення тощо, ми можемо створювати додаткові потоки.",[],"  Створення потоків і візуальний інтерфейс  Коли ми запускаємо додаток на Android, система створює потік, який називається основним потоком додатка або UI-потоком. Цей потік обробляє всі зміни та події інтерфейсу користувача. Однак для допоміжних операцій, таких як відправка або завантаження файлів, тривалі обчислення тощо, ми можемо створювати додаткові потоки.  Для створення нових потоків нам доступний стандартний функціонал класу   Thread  з базової бібліотеки Java з пакету   java.util.concurrent , які не викликають особливих труднощів. Однак труднощі можуть виникнути при оновленні візуального інтерфейсу з потоку.  Наприклад, створимо простий додаток із використанням потоків. Окреслимо наступну розмітку інтерфейсу в файлі   activity_main.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  TextView\n           android:id  =  \"@+id/textView\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Hello World!\"\n           android:textSize  =  \"22sp\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/button\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n       \u003C  Button\n           android:id  =  \"@+id/button\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Запустити потік\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/textView\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"    />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Тут визначена кнопка для запуску фоновго потоку, а також текстове поле для відображення деяких даних, які будуть генеруватися в запущеному потоці.  Далі визначимо в класі   MainActivity  наступний код:     package   com.example.threadapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.Button  ;\n   import   android.widget.TextView  ;\n   import   java.util.Calendar  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           TextView   textView   =   findViewById  (R.id.textView);\n           Button   button   =   findViewById  (R.id.button);\n           button.  setOnClickListener  (  new   View.  OnClickListener  () {\n               @  Override\n               public   void   onClick  (  View   v) {\n                   // Визначаємо об'єкт Runnable\n                   Runnable   runnable   =   new   Runnable  () {\n                       @  Override\n                       public   void   run  () {\n                           // отримуємо поточний час\n                           Calendar   c   =   Calendar.  getInstance  ();\n                           int   hours   =   c.  get  (Calendar.HOUR_OF_DAY);\n                           int   minutes   =   c.  get  (Calendar.MINUTE);\n                           int   seconds   =   c.  get  (Calendar.SECOND);\n                           String   time   =   hours   +   \":\"   +   minutes   +   \":\"   +   seconds;\n                           // відображаємо в текстовому полі\n                           textView.  setText  (time);\n                       }\n                   };\n                   // Визначаємо об'єкт Thread - новий потік\n                   Thread   thread   =   new   Thread  (runnable);\n                   // Запускаємо потік\n                   thread.  start  ();\n               }\n           });\n       }\n   }\n  Отже, тут до кнопки прикріплений обробник натискання, який запускає новий потік. Створювати та запускати потік в Java можна різними способами. У цьому випадку самі дії, які виконуються в потоці, визначаються в методі   run()  об'єкта   Runnable :     Runnable   runnable   =   new   Runnable  () {\n       @  Override\n       public   void   run  () {\n           // отримуємо поточний час\n           Calendar   c   =   Calendar.  getInstance  ();\n           int   hours   =   c.  get  (Calendar.HOUR_OF_DAY);\n           int   minutes   =   c.  get  (Calendar.MINUTE);\n           int   seconds   =   c.  get  (Calendar.SECOND);\n           String   time   =   hours   +   \":\"   +   minutes   +   \":\"   +   seconds;\n           // відображаємо в текстовому полі\n           textView.  setText  (time);\n       }\n   };\n  Для прикладу ми отримуємо поточний час і намагаємося відобразити його в елементі   TextView .  Далі визначаємо об'єкт потоку - об'єкт   Thread , який приймає об'єкт   Runnable . І за допомогою методу   start()  запускаємо потік:     // Визначаємо об'єкт Thread - новий потік\n   Thread   thread   =   new   Thread  (runnable);\n   // Запускаємо потік\n   thread.  start  ();\n  Начебто нічого складного. Але якщо ми запустимо додаток і натиснемо на кнопку, то ми зіткнемося з помилкою:    Оскільки змінювати стан візуальних елементів, звертатися до них ми можемо тільки в основному потоці додатка або UI-потоці.  Для вирішення цієї проблеми — взаємодії у вторинних потоках з елементами графічного інтерфейсу клас   View()  визначає метод   post() :     boolean   post   (  Runnable   action)\n  Як параметр він приймає задачу, яку треба виконати, і повертає логічне значення —   true , якщо задача   Runnable  успішно поміщена в чергу повідомлень, або   false , якщо не вдалося розмістити в черзі.  Також у класу   View  є аналогічний метод:     boolean   postDelayed   (  Runnable   action,   long   millsec)\n  Він також запускає задачу, тільки через певний проміжок часу в мілісекундах, який вказується в другому параметрі.  Тепер змінемо код   MainActivity  наступним чином:     package   com.example.threadapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.Button  ;\n   import   android.widget.TextView  ;\n   import   java.util.Calendar  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           TextView   textView   =   findViewById  (R.id.textView);\n           Button   button   =   findViewById  (R.id.button);\n           button.  setOnClickListener  (  new   View.  OnClickListener  () {\n               @  Override\n               public   void   onClick  (  View   v) {\n                   // Визначаємо об'єкт Runnable\n                   Runnable   runnable   =   new   Runnable  () {\n                       @  Override\n                       public   void   run  () {\n                           // отримуємо поточний час\n                           Calendar   c   =   Calendar.  getInstance  ();\n                           int   hours   =   c.  get  (Calendar.HOUR_OF_DAY);\n                           int   minutes   =   c.  get  (Calendar.MINUTE);\n                           int   seconds   =   c.  get  (Calendar.SECOND);\n                           String   time   =   hours   +   \":\"   +   minutes   +   \":\"   +   seconds;\n                           // відображаємо в текстовому полі\n                           textView.  post  (  new   Runnable  () {\n                               public   void   run  () {\n                                   textView.  setText  (time);\n                               }\n                           });\n                       }\n                   };\n                   // Визначаємо об'єкт Thread - новий потік\n                   Thread   thread   =   new   Thread  (runnable);\n                   // Запускаємо потік\n                   thread.  start  ();\n               }\n           });\n       }\n   }\n  Тепер для оновлення   TextView  застосовується метод   post :     textView.  post  (  new   Runnable  () {\n       public   void   run  () {\n           textView.  setText  (time);\n       }\n   });\n  Тобто, в методі   run() , переданому в метод   post()  об'єкта   Runnable , ми можемо звертатися до елементів візуального інтерфейсу та взаємодіяти з ними.   \nПодібним чином можна працювати і з іншими віджетами, які успадковуються від класу   View .  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":590,"path":591,"dir":551,"title":592,"description":593,"keywords":594,"body":597},"content:1.android:4.lesson4:6.threads-fragments-and-viewmodel.md","/android/lesson4/threads-fragments-and-viewmodel","Потоки, фрагменти та ViewModel","Під час використання вторинних потоків слід враховувати такий момент. Оптимальнішим способом є робота потоків із фрагментом, ніж безпосередньо з activity. Наприклад, визначимо у файлі activity_main.xml такий інтерфейс:",[595,596],"Додавання ViewModel","Використання фрагментів","  Потоки, фрагменти та ViewModel  Під час використання вторинних потоків слід враховувати такий момент. Оптимальнішим способом є робота потоків із фрагментом, ніж безпосередньо з activity. Наприклад, визначимо у файлі   activity_main.xml  такий інтерфейс:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  Button\n           android:id  =  \"@+id/progressBtn\"\n           android:text  =  \"Запуск\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/statusView\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/statusView\"\n           android:text  =  \"Статус\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/indicator\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/progressBtn\"   />\n       \u003C  ProgressBar\n           android:id  =  \"@+id/indicator\"\n           style  =  \"@android:style/Widget.ProgressBar.Horizontal\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:max  =  \"100\"\n           android:progress  =  \"0\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/statusView\"  />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Тут визначено кнопку для запуску вторинної задачі та елементи   TextView  і   ProgressBar , які відображають індикацію виконання задачі.  У класі   MainActivity  визначимо такий код:     package   com.example.threadapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.Button  ;\n   import   android.widget.ProgressBar  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       int   currentValue   =   0  ;\n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           ProgressBar   indicatorBar   =   findViewById  (R.id.indicator);\n           TextView   statusView   =   findViewById  (R.id.statusView);\n           Button   btnFetch   =   findViewById  (R.id.progressBtn);\n           btnFetch.  setOnClickListener  (  new   View.  OnClickListener  () {\n               @  Override\n               public   void   onClick  (  View   v) {\n    \n                   Runnable   runnable   =   new   Runnable  () {\n                       @  Override\n                       public   void   run  () {\n    \n                           for  (; currentValue   \u003C=   100  ; currentValue  ++  ){\n                               try   {\n                                   statusView.  post  (  new   Runnable  () {\n                                       public   void   run  () {\n                                           indicatorBar.  setProgress  (currentValue);\n                                           statusView.  setText  (  \"Статус: \"   +   currentValue);\n                                       }\n                                   });\n    \n                                   Thread.  sleep  (  400  );\n                               }   catch   (  InterruptedException   e  ) {\n                                   e.  printStackTrace  ();\n                               }\n                           }\n                       }\n                   };\n                   Thread   thread   =   new   Thread  (runnable);\n                   thread.  start  ();\n               }\n           });\n       }\n   }\n  Тут після натискання кнопки ми запускаємо задачу   Runnable , у якій у циклі від   0  до   100  змінюємо показники   ProgressBar  і   TextView , імітуючи деяку довгу роботу.  Однак якщо в процесі роботи завдання ми змінимо орієнтацію мобільного пристрою, то відбудеться перестворення   activity , і застосунок перестане працювати належним чином.    У цьому разі проблема впирається в стан, яким оперує потік, а саме - змінну   currentValue , до значення якої прив'язані віджети в   Activity .  Додавання ViewModel  Для подібних випадків як вирішення проблеми пропонується використовувати   ViewModel . Отже, додамо в ту саму папку, де міститься файл   MainActivity.java , новий клас   MyViewModel  із таким кодом:     package   com.example.threadapp  ;\n    \n   import   androidx.lifecycle.LiveData  ;\n   import   androidx.lifecycle.MutableLiveData  ;\n   import   androidx.lifecycle.ViewModel  ;\n    \n   public   class   MyViewModel   extends   ViewModel   {\n    \n       private   MutableLiveData  \u003C  Boolean  > isStarted   =   new   MutableLiveData  \u003C  Boolean  >(  false  );\n       private   MutableLiveData  \u003C  Integer  > value;\n       public   LiveData  \u003C  Integer  >   getValue  () {\n           if   (value   ==   null  ) {\n               value   =   new   MutableLiveData  \u003C  Integer  >(  0  );\n           }\n           return   value;\n       }\n       public   void   execute  (){\n    \n           if  (  !  isStarted.  getValue  ()){\n               isStarted.  postValue  (  true  );\n               Runnable   runnable   =   new   Runnable  () {\n                   @  Override\n                   public   void   run  () {\n    \n                       for  (  int   i   =   value.  getValue  ();  i   \u003C=   100  ; i  ++  ){\n                           try   {\n                               value.  postValue  (i);\n                               Thread.  sleep  (  400  );\n                           }   catch   (  InterruptedException   e  ) {\n                               e.  printStackTrace  ();\n                           }\n                       }\n                   }\n               };\n               Thread   thread   =   new   Thread  (runnable);\n               thread.  start  ();\n           }\n       }\n   }\n  Отже, тут визначений клас   MyViewModel , який успадковується від класу   ViewModel , спеціально призначеного для зберігання та керування станом або моделлю.  Як стан тут визначені для об'єкта. По-перше, це числове значення, до якого будуть прив'язані віджети   MainActivity . По-друге, нам потрібен деякий індикатор того, що потік вже запущено, щоб по натисканню кнопки не було запущено зайвих потоків.  Для зберігання числового значення призначена змінна   value :     private   MutableLiveData  \u003C  Integer  > value;\n  Для прив'язки до цього значення вона має тип   MutableLiveData . А оскільки ми будемо зберігати в цій змінній числове значення, то тип змінної типізовано типом   Integer .  Для доступу ззовні класу до цього значення визначено метод   getValue , який має тип   LiveData  і який при першому зверненні до змінної встановлює 0, або просто повертає значення змінної:     public   LiveData  \u003C  Integer  >   getValue  () {\n       if   (value   ==   null  ) {\n           value   =   new   MutableLiveData  \u003C  Integer  >(  0  );\n       }\n       return   value;\n   }\n  Для індикації, запущений чи потік, визначена змінна   isStarted , яка зберігає значення типу   Boolean , тобто фактично   true  або   false . За замовчуванням вона має значення   false  (тобто потік не запущено).  Для зміни числового значення, до якого будуть прив'язані віджети, визначено метод   execute() . Він запускає потік, якщо потік не запущено:     if  (  !  isStarted.  getValue  ()){\n  Далі перемикає значення змінної   isStarted  на   true , оскільки ми запускаємо потік.  В самому потоці також запускається цикл:     for  (  int   i   =   value.  getValue  ();  i   \u003C=   100  ; i  ++  ){\n  І в цьому випадку ми користуємось перевагами класу   ViewModel , який дозволяє автоматично зберігати своє стан.  Причому лічильник циклу як початкове значення бере значення з змінної   value  і збільшується на одиницю, поки не досягне ста.  В самому циклі змінюється значення змінної   value  за допомогою передачі значення в метод   postValue() :     value.  postValue  (i);\n  Таким чином, в циклі здійснюється прохід від 0 до 100, і при кожній ітерації циклу змінюється значення змінної   value .  Тепер задіємо наш клас   MyViewModel  і для цього змінимо код класу   MainActivity :     package   com.example.threadapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   androidx.lifecycle.ViewModelProvider  ;\n    \n   import   android.os.Bundle  ;\n   import   android.widget.Button  ;\n   import   android.widget.ProgressBar  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           ProgressBar   indicatorBar   =   findViewById  (R.id.indicator);\n           TextView   statusView   =   findViewById  (R.id.statusView);\n           Button   btnFetch   =   findViewById  (R.id.progressBtn);\n           MyViewModel   model   =   new   ViewModelProvider  (  this  ).  get  (MyViewModel.class);\n    \n           model.  getValue  ().  observe  (  this  , value   ->   {\n               indicatorBar.  setProgress  (value);\n               statusView.  setText  (  \"Статус: \"   +   value);\n           });\n           btnFetch.  setOnClickListener  (v   ->   model.  execute  ());\n       }\n   }\n  Щоб залучити   MyViewModel , створюємо об'єкт класу   ViewModelProvider , у конструктор якого передається об'єкт-володар   ViewModel . У цьому випадку це поточний об'єкт   MainActivity :     new   ViewModelProvider  (  this  )\n  І далі за допомогою методу   get()  створюємо об'єкт класу   ViewModel , який буде використовуватися в об'єкті   MainActivity .     MyViewModel   model   =   new   ViewModelProvider  (  this  ).  get  (MyViewModel.class);\n  Отримавши об'єкт   MyViewModel , визначаємо прослуховування змін його змінної   value  за допомогою методу   observe :     model.  getValue  ().  observe  (  this  , value   ->   {\n       indicatorBar.  setProgress  (value);\n       statusView.  setText  (  \"Статус: \"   +   value);\n   });\n  Метод   observe()  як перший параметр приймає володаря функції спостерігача - у цьому випадку поточний об'єкт   MainActivity . А як другий параметр - функцію спостерігача (а точніше об'єкт інтерфейсу   Observer ). Функція спостерігача приймає один параметр - нове значення відстежуваної змінної (тобто в цьому випадку змінної   value ). Отримавши нове значення змінної   value , ми змінюємо параметри віджетів.  Таким чином, при кожній зміні значення в змінній   value  віджети отримають її нове значення.  Тепер, якщо ми запустимо додаток, то незалежно від зміни орієнтації мобільного пристрою фонове завдання продовжить свою роботу:\n   Використання фрагментів  Аналогічно ми можемо використовувати фрагменти. Отже, додамо в проєкт новий фрагмент, який назвемо   ProgressFragment .   \nВизначимо для нього новий файл розмітки інтерфейсу   fragment_progress.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  Button\n           android:id  =  \"@+id/progressBtn\"\n           android:text  =  \"Запуск\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/statusView\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/statusView\"\n           android:text  =  \"Статус\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/indicator\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/progressBtn\"   />\n       \u003C  ProgressBar\n           android:id  =  \"@+id/indicator\"\n           style  =  \"@android:style/Widget.ProgressBar.Horizontal\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:max  =  \"100\"\n           android:progress  =  \"0\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/statusView\"  />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Сам клас фрагмента   ProgressFragment  змінимо таким чином:     package   com.example.threadapp  ;\n    \n   import   android.os.Bundle  ;\n   import   androidx.fragment.app.Fragment  ;\n   import   androidx.lifecycle.ViewModelProvider  ;\n   import   android.util.Log  ;\n   import   android.view.LayoutInflater  ;\n   import   android.view.View  ;\n   import   android.view.ViewGroup  ;\n   import   android.widget.Button  ;\n   import   android.widget.ProgressBar  ;\n   import   android.widget.TextView  ;\n    \n    \n   public   class   ProgressFragment   extends   Fragment   {\n    \n       @  Override\n       public   View   onCreateView  (  LayoutInflater   inflater  ,   ViewGroup   container  ,   Bundle   savedInstanceState  ) {\n    \n           View   view   =   inflater.  inflate  (R.layout.fragment_progress, container,   false  );\n    \n           ProgressBar   indicatorBar   =   (ProgressBar) view.  findViewById  (R.id.indicator);\n           TextView   statusView   =   (TextView) view.  findViewById  (R.id.statusView);\n           Button   btnFetch   =   (Button)view.  findViewById  (R.id.progressBtn);\n    \n           MyViewModel   model   =   new   ViewModelProvider  (  requireActivity  ()).  get  (MyViewModel.class);\n    \n           model.  getValue  ().  observe  (  getViewLifecycleOwner  (), value   ->   {\n               indicatorBar.  setProgress  (value);\n               statusView.  setText  (  \"Статус: \"   +   value);\n           });\n           btnFetch.  setOnClickListener  (v   ->   model.  execute  ());\n           return   view;\n       }\n   }\n  Тут аналогічним чином застосовується клас   MyViewModel . Єдине, для отримання асоційованої з фрагментом   Activity  тут використовується метод   requireActivity() . А для отримання власника життєвого циклу - метод   getViewLifecycleOwner .  Тепер зв'яжемо фрагмент з   Activity . Для цього визначимо в файлі   activity_main.xml  наступний код:     \u003C  androidx.fragment.app.FragmentContainerView\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:id  =  \"@+id/fragment_container_view\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:name  =  \"com.example.threadapp.ProgressFragment\"   />\n  А сам клас   MainActivity  скоротимо:     package   com.example.threadapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n   }\n  І код з фрагментом буде працювати аналогічно:\n   html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":599,"path":600,"dir":551,"title":601,"description":602,"keywords":603,"body":605},"content:1.android:4.lesson4:7.async-task.md","/android/lesson4/async-task","Клас AsyncTask (застарілий)","У попередніх статтях був описаний загальний підхід, який застосовується зараз для запуску нового потоку в додатку та оновлення в ньому користувацького інтерфейсу. Розглянемо інший підхід, який представляє клас AsyncTask. Хоча застосування AsyncTask в сучасних додатках Android застаріло, тим не менш, оскільки він досі широко застосовується, також розглянемо його.",[604],"AsyncTask і фрагменти","  Клас AsyncTask (застарілий)  У попередніх статтях був описаний загальний підхід, який застосовується зараз для запуску нового потоку в додатку та оновлення в ньому користувацького інтерфейсу. Розглянемо інший підхід, який представляє клас   AsyncTask . Хоча застосування   AsyncTask  в сучасних додатках Android застаріло, тим не менш, оскільки він досі широко застосовується, також розглянемо його.  Щоб використовувати   AsyncTask , нам потрібно:   Створити клас, який успадковується від   AsyncTask  (як правило, для цього створюється внутрішній клас у   activity  або у фрагменті)  Перевизначити один або кілька методів   AsyncTask  для виконання деякої роботи у фоновому режимі  При необхідності створити об'єкт   AsyncTask  і викликати його метод   execute() , щоб почати роботу  Отже, створимо найпростіший додаток із використанням   AsyncTask . Визначимо наступну розмітку інтерфейсу у файлі   activity_main.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  LinearLayout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:id  =  \"@+id/activity_main\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:paddingBottom  =  \"16dp\"\n       android:orientation  =  \"vertical\"  >\n    \n       \u003C  LinearLayout\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"wrap_content\"  >\n           \u003C  TextView\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"\n               android:textSize  =  \"22sp\"\n               android:id  =  \"@+id/clicksView\"\n               android:text  =  \"Clicks: 0\"  />\n           \u003C  Button\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"\n               android:id  =  \"@+id/clicksBtn\"\n               android:text  =  \"Click\"   />\n       \u003C/  LinearLayout  >\n    \n       \u003C  Button\n           android:id  =  \"@+id/progressBtn\"\n           android:text  =  \"Запуск\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"   />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/statusView\"\n           android:text  =  \"Статус\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"   />\n       \u003C  ProgressBar\n           android:id  =  \"@+id/indicator\"\n           style  =  \"@android:style/Widget.ProgressBar.Horizontal\"\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"wrap_content\"\n           android:max  =  \"100\"\n           android:progress  =  \"0\"   />\n   \u003C/  LinearLayout  >\n  Тут визначено кнопку для запуску фонового потоку, а також текстове поле і прогрессбар для індикації виконання завдання. Крім того, тут визначено додаткову кнопку, яка збільшує кількість кліків, і текстове поле, яке виводить число кліків.  Далі визначимо в класі   MainActivity  такий код:     import   android.os.AsyncTask  ;\n   import   android.os.SystemClock  ;\n   import   android.support.v7.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.Button  ;\n   import   android.widget.ProgressBar  ;\n   import   android.widget.TextView  ;\n   import   android.widget.Toast  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       int  [] integers  =  null  ;\n       int   clicks   =   0  ;\n       ProgressBar   indicatorBar;\n       TextView   statusView;\n       TextView   clicksView;\n       Button   progressBtn;\n       Button   clicksBtn;\n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           integers   =   new   int  [  100  ];\n           for  (  int   i  =  0  ;i  \u003C  100  ;i  ++  ) {\n               integers[i]   =   i   +   1  ;\n           }\n           indicatorBar   =   (ProgressBar)   findViewById  (R.id.indicator);\n           statusView   =   findViewById  (R.id.statusView);\n           progressBtn   =   findViewById  (R.id.progressBtn);\n           progressBtn.  setOnClickListener  (  new   View.  OnClickListener  () {\n               @  Override\n               public   void   onClick  (  View   v) {\n    \n                   new   ProgressTask  ().  execute  ();\n               }\n           });\n    \n           clicksView   =   findViewById  (R.id.clicksView);\n           clicksBtn   =   findViewById  (R.id.clicksBtn);\n           clicksBtn.  setOnClickListener  (  new   View.  OnClickListener  () {\n               @  Override\n               public   void   onClick  (  View   v) {\n    \n                   clicks  ++  ;\n                   clicksView.  setText  (  \"Clicks: \"   +   clicks);\n               }\n           });\n       }\n    \n       class   ProgressTask   extends   AsyncTask  \u003C  Void  ,   Integer  ,   Void  > {\n           @  Override\n           protected   Void   doInBackground  (  Void  ...   unused  ) {\n               for   (  int   i   =   0  ; i  \u003C  integers.length;i  ++  ) {\n    \n                   publishProgress  (i);\n                   SystemClock.  sleep  (  400  );\n               }\n               return  (  null  );\n           }\n           @  Override\n           protected   void   onProgressUpdate  (  Integer  ...   items  ) {\n               indicatorBar.  setProgress  (items[  0  ]  +  1  );\n               statusView.  setText  (  \"Статус: \"   +   String.  valueOf  (items[  0  ]  +  1  ));\n           }\n           @  Override\n           protected   void   onPostExecute  (  Void   unused  ) {\n               Toast.  makeText  (  getApplicationContext  (),   \"Задача завершена\"  , Toast.LENGTH_SHORT)\n                       .  show  ();\n           }\n       }\n   }\n  Клас задачі   ProgressTask  визначений як внутрішній клас. Він успадковується не просто від   AsyncTask , а від його типізованої версії   AsyncTask\u003CVoid, Integer, Void> . Вона типізується трьома типами:   Клас для зберігання інформації, яка потрібна для обробки задачі  Тип об'єктів, які використовуються для індикації процесу виконання задачі  Тип результату задачі  Ці типи можуть бути представлені різними класами. У даному випадку сутність задачі буде полягати в переборі масиву   integers , що представляє набір елементів   Integer . І тут нам не треба передавати в задачу жоден об'єкт, тому перший тип йде як   Void .  Для індикації перебору використовуються цілі числа, які показують, який об'єкт з масиву ми зараз перебираємо. Тому в якості другого типу використовується   Integer .  В якості третього типу знову використовується   Void , оскільки в даному випадку не потрібно нічого повертати з задачі.   AsyncTask  містить чотири методи, які можна перевизначити:   Метод   doInBackground() : виконується у фоновому потоці, повинен повертати певний результат  Метод   onPreExecute() : викликається з головного потоку перед запуском методу   doInBackground()  Метод   onPostExecute() : виконується з головного потоку після завершення роботи методу   doInBackground()  Метод   onProgressUpdate() : дозволяє сигналізувати користувачеві про виконання фонового потоку  Оскільки метод   doInBackground()  не приймає нічого і не повертає нічого, то в якості його параметра використовується   Void...  - масив   Void , і в якості повернутого типу - також   Void . Ці типи відповідають першому та третьому типам в   AsyncTask\u003CVoid, Integer, Void> .  Метод   doInBackground()  перебирає масив і при кожній ітерації сповіщає систему за допомогою методу   publishProgress(item) . Оскільки в нашому випадку для індикації використовуються цілі числа, то параметр   item  має представляти ціле число.  Метод   onProgressUpdate(Integer... items)  отримує передане вище число і застосовує його для налаштування текстового поля та прогресбару.  Метод   onPostExecute()  виконується після завершення задачі і в якості параметра приймає об'єкт, що повертається з методу   doInBackground()  - тобто в даному випадку об'єкт типу   Void . Щоб сигналізувати про закінчення роботи, тут виводиться на екран спливаюче повідомлення.  Запустимо додаток. Запустимо завдання, натиснувши на кнопку:\n  \nПри цьому поки виконується завдання, ми можемо паралельно натискати на другу кнопку і збільшувати кількість кліків, або виконувати якусь іншу роботу в застосунку.  AsyncTask і фрагменти  Під час використання   AsyncTask  слід враховувати такий момент. Оптимальнішим способом є робота   AsyncTask  із фрагментом, ніж безпосередньо з activity. Наприклад, якщо ми візьмемо попередній проєкт, запустимо застосунок і змінимо орієнтацію мобільного пристрою, то відбудеться перестворення activity. У разі зміни орієнтації пристрою потік   AsyncTask  продовжуватиме звертатися до старої activity, замість нової. Тому в цьому випадку краще використовувати фрагменти.  Отже, візьмемо проєкт з минулої теми і додамо в нього новий фрагмент, який назвемо   ProgressFragment .\n  \nВизначимо для нього новий файл розмітки інтерфейсу   fragment_progress.xml :     \u003C  LinearLayout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:id  =  \"@+id/fragment_progress\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:paddingBottom  =  \"16dp\"\n       android:orientation  =  \"vertical\"  >\n       \u003C  Button\n           android:id  =  \"@+id/progressBtn\"\n           android:text  =  \"Запуск\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"   />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/statusView\"\n           android:text  =  \"Статус\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"   />\n       \u003C  ProgressBar\n           android:id  =  \"@+id/indicator\"\n           style  =  \"@android:style/Widget.ProgressBar.Horizontal\"\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"wrap_content\"\n           android:max  =  \"100\"\n           android:progress  =  \"0\"   />\n   \u003C/  LinearLayout  >\n  Сам клас фрагмента   ProgressFragment  змінимо таким чином:     package   com.example.eugene.asyncapp  ;\n    \n   import   android.widget.Button  ;\n   import   android.os.AsyncTask  ;\n   import   android.os.Bundle  ;\n   import   android.app.Fragment  ;\n   import   android.os.SystemClock  ;\n   import   android.view.LayoutInflater  ;\n   import   android.view.View  ;\n   import   android.view.ViewGroup  ;\n   import   android.widget.ProgressBar  ;\n   import   android.widget.TextView  ;\n   import   android.widget.Toast  ;\n   import   android.view.View.OnClickListener  ;\n    \n   public   class   ProgressFragment   extends   Fragment   {\n    \n       int  [] integers  =  null  ;\n       ProgressBar   indicatorBar;\n       TextView   statusView;\n       @  Override\n       public   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setRetainInstance  (  true  );\n       }\n    \n       @  Override\n       public   View   onCreateView  (  LayoutInflater   inflater  ,   ViewGroup   container  ,\n                                Bundle   savedInstanceState  ) {\n           View   view   =   inflater.  inflate  (R.layout.fragment_progress, container,   false  );\n           integers   =   new   int  [  100  ];\n           for  (  int   i  =  0  ;i  \u003C  100  ;i  ++  ) {\n               integers[i]   =   i   +   1  ;\n           }\n           indicatorBar   =   (ProgressBar) view.  findViewById  (R.id.indicator);\n           statusView   =   (TextView) view.  findViewById  (R.id.statusView);\n           Button   btnFetch   =   (Button)view.  findViewById  (R.id.progressBtn);\n           btnFetch.  setOnClickListener  (  new   OnClickListener  () {\n               @  Override\n               public   void   onClick  (  View   v  ) {\n    \n                   new   ProgressTask  ().  execute  ();\n               }\n           });\n           return   view;\n       }\n    \n       class   ProgressTask   extends   AsyncTask  \u003C  Void  ,   Integer  ,   Void  > {\n           @  Override\n           protected   Void   doInBackground  (  Void  ...   unused  ) {\n               for   (  int   i   =   0  ; i  \u003C  integers.length;i  ++  ) {\n    \n                   publishProgress  (i);\n                   SystemClock.  sleep  (  400  );\n               }\n               return   null  ;\n           }\n           @  Override\n           protected   void   onProgressUpdate  (  Integer  ...   items  ) {\n               indicatorBar.  setProgress  (items[  0  ]  +  1  );\n               statusView.  setText  (  \"Статус: \"   +   String.  valueOf  (items[  0  ]  +  1  ));\n           }\n           @  Override\n           protected   void   onPostExecute  (  Void   unused  ) {\n               Toast.  makeText  (  getActivity  (),   \"Задача завершена\"  , Toast.LENGTH_SHORT)\n                       .  show  ();\n           }\n       }\n   }\n  Тут визначено всі ті дії, які були розглянуті в минулій темі і які раніше перебували в класі   MainActivity . Особливо варто відзначити виклик   setRetainInstance(true)  у методі   onCreate() , який дає змогу зберігати стан фрагмента незалежно від зміни орієнтації.  Тепер зв'яжемо фрагмент з activity. Для цього визначимо у файлі   activity_main.xml  такий код:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  LinearLayout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:id  =  \"@+id/activity_main\"\n       android:orientation  =  \"vertical\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  fragment\n           android:id  =  \"@+id/progressFragment\"\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"match_parent\"\n           android:name  =  \"com.example.eugene.asyncapp.ProgressFragment\"  />\n   \u003C/  LinearLayout  >\n  А сам клас   MainActivity  скоротимо:     package   com.example.eugene.asyncapp  ;\n    \n   import   android.support.v7.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n   }\n  Тепер якщо ми запустимо додаток, то незалежно від зміни орієнтації мого мобільного пристрою фонове завдання продовжуватиме свою роботу:    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":607,"path":608,"dir":551,"title":609,"description":7,"keywords":610,"body":640},"content:1.android:4.lesson4:8.mvvm.md","/android/lesson4/mvvm","Model-View-ViewModel",[611,612,96,613,614,615,616,617,618,619,620,621,622,623,624,625,626,224,627,628,629,630,631,632,633,634,635,636,637,638,639,224],"MVP — Model-View-Presenter","MVP — реалізація в Android","Крок 1: Модель (Model)","Крок 2: Presenter","Крок 3: View","Крок 4: Адаптер для відображення списку продуктів","Крок 5: Ретрофіт клієнт для мережевих запитів","Крок 6: XML для Activity","MVVM","MVVM у розробці Android: Як використати шаблон із Java та Data Binding","Вступ","Що таке MVVM?","Чому MVVM краще?","Data Binding: Що це?","Реалізація MVVM із Data Binding","Що таке LiveData?","Що таке ObservableArrayList?","Як використовувати ObservableArrayList?","Інтеграція з Data Binding","Особливості ObservableArrayList","Обмеження ObservableArrayList","Прив’язка даних (Data Binding) в XML","Основний синтаксис прив’язки","Типи прив’язки","Умовна прив’язка","Прив’язка з форматуванням","Двостороння прив’язка","Робота з LiveData","Додаткові приклади з LiveData","  Model-View-ViewModel  MVP — Model-View-Presenter  Для початку — трошки теорії. Все почалося з того, що багато хто думав, як адаптувати шаблон MVC (Model-View-Controller) для написання додатків з інтерфейсом користувача. І в 2006 році в роботі “GUI Architectures” Мартін Фаулер детально розглянув шаблон, який пізніше отримав назву “MVP” (“Model-View-Presenter”).  Отже, MVP — шаблон проектування, похідний від MVC, розроблений переважно для побудови користувацького інтерфейсу. MVP використовується для полегшення автоматичного модульного тестування та покращення розділення логіки і відображення.  В цьому шаблоні є три елементи:   View.  Presenter.  Model (модель).     Елемент View відповідає за показ користувацьких даних і перехоплення користувацьких дій. Все це він надсилає   Presenter'у .   Presenter  обробляє дії користувача в UI, враховує зміни даних у   Model  і надсилає цю інформацію   View .   Presenter  — це елемент, який містить всю бізнес-логіку роботи з користувацьким інтерфейсом.   Model  містить у собі моделі з предметної області, які відображають знання та дані предметної області вашого додатка.   Model  надсилає інформацію про зміну даних   Presenter  і приймає повідомлення від   Presenter .  MVP — реалізація в Android  MVP дозволяє створювати абстракцію представлення. Для цього необхідно виокремити інтерфейс представлення з певним набором властивостей і методів.  Тепер подивимося, як це можна реалізувати в Android — для цього напишемо невеликий «велосипед».   Presenter  взаємодіє з   View  за допомогою спеціального інтерфейсу, який описує абстракцію цього   View .  Припустимо, у нас є ось така модель   View :     public   interface   SomeScreenView   {\n       void   startLoading  (); \n       void   stopLoading  (); \n       void   mapDataItems  (  final   Collection  \u003C  DataItem  >   items  );\n   }\n  Зверніть увагу: не слід плутати цю модель   View  з тим виглядом (  View ), який ми бачимо на екрані.   View , яка використовується в MVP — це певна абстракція   View . Іншими словами, це узагальнення поведінки нашого   View . В MVP   View  не відповідає за те, як саме все буде відображатися на користувацькому інтерфейсі. Вона відповідає за те, як буде поводитися користувацький інтерфейс.   Presenter  отримує посилання на реалізацію інтерфейсу, взаємодіє з моделлю нашого   View , ініціалізує його, викликає всі його повідомлення, посилає йому якісь повідомлення і т.д. Все взаємодія відбувається напряму: у нас є реалізація   View , ми викликаємо її методи і отримуємо певний результат.  Іншими словами,   Presenter  як би підписується на події   View  і за необхідності змінює дані в   Model .     public   class   SomeScreenPresenter   extends   Presenter   {\n       private   SomeScreenView   mView;\n   \n       public   void   setView  (  SomeScreenView   view  ) {\n           mView   =   view;\n       }\n   \n       @  Override\n           public   void   initialize  () {\n           mView.  startLoading  ();\n   \n           mView.  mapDataItems  (...);\n           mView.  stopLoading  ();\n       }\n   }\n  Як приклад   View  у нашому випадку виступатиме   Activity , що відповідає за реалізацію поведінки   SomeScreenView . Роль   View  може відігравати не тільки   Activity , але й   Fragment ,   Dialog  або просто Android   View . Для цього йому також необхідно реалізувати поведінку   SomeScreenView . У зазначеному   Activity  використовується об'єкт типу   SomeScreenPresenter , який і виступає в ролі   Presenter  у нашому прикладі. Цьому об'єкту ми надаємо посилання на реалізацію вашого   View , яке взаємодіє з   Presenter  шляхом прямого виклику в нього необхідних методів. Своєю чергою,   Presenter  викликає методи, реалізовані всередині вашої   Activity , тому що вона є реалізацією вашого   View .     @  EActivity  (R.layout.activity_some_screen) \n   public   class   SomeScreenActivity   extends   Activity   implements   SomeScreenView   { \n       private   SomeScreenPresenter   mPresenter; \n   \n       @  ViewById  (R.id.drawer_layout) \n       protected   ProgressBar   mProgressBar;\n   \n       @  Override   \n       protected   void   onCreate  (  Bundle   savedInstanceState  ) { \n           super  .  onCreate  (savedInstanceState); \n   \n           mPresenter   =   new   SomeScreenPresenter  (  this  );\n           mPresenter.  gradletialize  (); \n       } \n   }\n  Цей простий приклад демонструє, як MVP дозволяє декомпозувати логіку, яка раніше повністю знаходилася в   Activity  та була пов'язана з обробкою даних і дій користувача. Ми винесли цю логіку в окремий модуль, і цей модуль, наприклад, можемо перевірити звичайним модульним тестуванням. На мою думку, це набагато простіше, ніж тестування нашої UI-функціональності за допомогою   Robotium , запуску емуляторів і т. д. Іншими словами, ми взяли всю нашу логіку з   Activity , яка раніше була   Controller , винесли її в новий елемент   Presenter , і тепер можемо цей елемент спокійно протестувати, не створюючи ніяких   Controller  і   View . Крім того, цей код можна додатково покращити — наприклад, використовуючи впровадження залежностей (скажімо, за допомогою   RoboGuice  або   Dagger ).  Приклад  Опис бізнес-сценарію:   Користувач може переглядати список товарів.  Користувач може додавати товар у кошик.  Користувач може оформити покупку.  Ми використовуємо Retrofit для мережевих запитів, щоб отримати список товарів із серверу та виконати покупку.  Крок 1: Модель (Model)  1.1. Структура товару (Product)     public   class   Product   {\n       private   String   id;\n       private   String   name;\n       private   double   price;\n   \n       public   Product  (  String   id  ,   String   name  ,   double   price  ) {\n           this  .id   =   id;\n           this  .name   =   name;\n           this  .price   =   price;\n       }\n   \n       public   String   getId  () {\n           return   id;\n       }\n   \n       public   String   getName  () {\n           return   name;\n       }\n   \n       public   double   getPrice  () {\n           return   price;\n       }\n   }\n  1.2. Інтерфейс для отримання товарів із мережі     import   retrofit2.Call  ;\n   import   retrofit2.http.GET  ;\n   \n   public   interface   ApiService   {\n       @  GET  (  \"products\"  )\n       Call  \u003C  List  \u003C  Product  >>   getProducts  ();\n   }\n  1.3. Клас для обробки покупки     public   class   Purchase   {\n       private   String   userId;\n       private   List  \u003C  Product  > products;\n   \n       public   Purchase  (  String   userId  ,   List  \u003C  Product  >   products  ) {\n           this  .userId   =   userId;\n           this  .products   =   products;\n       }\n   \n       public   String   getUserId  () {\n           return   userId;\n       }\n   \n       public   List  \u003C  Product  >   getProducts  () {\n           return   products;\n       }\n   }\n  Крок 2: Presenter  2.1. Презентер для роботи з продуктами та кошиком     import   android.util.Log  ;\n   import   java.util.List  ;\n   \n   public   class   ProductPresenter   {\n   \n       private   ProductView   view;\n       private   ApiService   apiService;\n       private   List  \u003C  Product  > products;\n   \n       public   ProductPresenter  (  ProductView   view  ,   ApiService   apiService  ) {\n           this  .view   =   view;\n           this  .apiService   =   apiService;\n       }\n   \n       public   void   loadProducts  () {\n           apiService.  getProducts  ().  enqueue  (  new   retrofit2  .  Callback  \u003C  List  \u003C  Product  >>() {\n               @  Override\n               public   void   onResponse  (  Call  \u003C  List  \u003C  Product  >>   call  ,   retrofit2  .  Response  \u003C  List  \u003C  Product  >>   response  ) {\n                   if   (response.  isSuccessful  ()) {\n                       products   =   response.  body  ();\n                       view.  showProducts  (products);\n                   }   else   {\n                       view.  showError  (  \"Failed to load products\"  );\n                   }\n               }\n   \n               @  Override\n               public   void   onFailure  (  Call  \u003C  List  \u003C  Product  >>   call  ,   Throwable   t  ) {\n                   view.  showError  (  \"Network error\"  );\n               }\n           });\n       }\n   \n       public   void   addToCart  (  Product   product  ) {\n           // Логіка додавання товару в кошик\n           view.  showProductAddedToCart  (product);\n       }\n   \n       public   void   makePurchase  (  String   userId  ) {\n           if   (products   ==   null   ||   products.  isEmpty  ()) {\n               view.  showError  (  \"Your cart is empty\"  );\n               return  ;\n           }\n           Purchase   purchase   =   new   Purchase  (userId, products);\n           // Можна реалізувати мережевий запит для оформлення покупки\n           view.  showPurchaseSuccess  (purchase);\n       }\n   }\n  Крок 3: View  3.1. Інтерфейс для View     public   interface   ProductView   {\n       void   showProducts  (  List  \u003C  Product  >   products  );\n       void   showError  (  String   error  );\n       void   showProductAddedToCart  (  Product   product  );\n       void   showPurchaseSuccess  (  Purchase   purchase  );\n   }\n  3.2. Реалізація View в Activity     import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.Button  ;\n   import   android.widget.ListView  ;\n   import   android.widget.Toast  ;\n   import   androidx.appcompat.app.AppCompatActivity  ;\n   \n   import   java.util.List  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   implements   ProductView   {\n   \n       private   ProductPresenter   presenter;\n       private   ListView   productsListView;\n       private   Button   buyButton;\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n   \n           productsListView   =   findViewById  (R.id.productsListView);\n           buyButton   =   findViewById  (R.id.buyButton);\n   \n           // Ініціалізація Retrofit\n           ApiService   apiService   =   RetrofitClient.  getRetrofitInstance  ().  create  (ApiService.class);\n           presenter   =   new   ProductPresenter  (  this  , apiService);\n   \n           // Завантаження продуктів\n           presenter.  loadProducts  ();\n   \n           buyButton.  setOnClickListener  (  new   View.  OnClickListener  () {\n               @  Override\n               public   void   onClick  (  View   v) {\n                   // Оформлення покупки (потрібно передати userId)\n                   presenter.  makePurchase  (  \"user123\"  );\n               }\n           });\n       }\n   \n       @  Override\n       public   void   showProducts  (  List  \u003C  Product  >   products  ) {\n           // Налаштовуємо адаптер для відображення товарів\n           ProductAdapter   adapter   =   new   ProductAdapter  (  this  , products);\n           productsListView.  setAdapter  (adapter);\n       }\n   \n       @  Override\n       public   void   showError  (  String   error  ) {\n           Toast.  makeText  (  this  , error, Toast.LENGTH_SHORT).  show  ();\n       }\n   \n       @  Override\n       public   void   showProductAddedToCart  (  Product   product  ) {\n           Toast.  makeText  (  this  ,   \"Product added to cart: \"   +   product.  getName  (), Toast.LENGTH_SHORT).  show  ();\n       }\n   \n       @  Override\n       public   void   showPurchaseSuccess  (  Purchase   purchase  ) {\n           Toast.  makeText  (  this  ,   \"Purchase successful! \"   +   purchase.  getProducts  ().  size  ()   +   \" items bought.\"  , Toast.LENGTH_SHORT).  show  ();\n       }\n   }\n  Крок 4: Адаптер для відображення списку продуктів     import   android.content.Context  ;\n   import   android.view.LayoutInflater  ;\n   import   android.view.View  ;\n   import   android.view.ViewGroup  ;\n   import   android.widget.BaseAdapter  ;\n   import   android.widget.TextView  ;\n   import   java.util.List  ;\n   \n   public   class   ProductAdapter   extends   BaseAdapter   {\n   \n       private   Context   context;\n       private   List  \u003C  Product  > products;\n   \n       public   ProductAdapter  (  Context   context  ,   List  \u003C  Product  >   products  ) {\n           this  .context   =   context;\n           this  .products   =   products;\n       }\n   \n       @  Override\n       public   int   getCount  () {\n           return   products.  size  ();\n       }\n   \n       @  Override\n       public   Object   getItem  (  int   position  ) {\n           return   products.  get  (position);\n       }\n   \n       @  Override\n       public   long   getItemId  (  int   position  ) {\n           return   position;\n       }\n   \n       @  Override\n       public   View   getView  (  int   position  ,   View   convertView  ,   ViewGroup   parent  ) {\n           if   (convertView   ==   null  ) {\n               convertView   =   LayoutInflater.  from  (context).  inflate  (R.layout.product_item, parent,   false  );\n           }\n   \n           Product   product   =   products.  get  (position);\n   \n           TextView   nameTextView   =   convertView.  findViewById  (R.id.productName);\n           TextView   priceTextView   =   convertView.  findViewById  (R.id.productPrice);\n   \n           nameTextView.  setText  (product.  getName  ());\n           priceTextView.  setText  (  \"$\"   +   product.  getPrice  ());\n   \n           return   convertView;\n       }\n   }\n  Крок 5: Ретрофіт клієнт для мережевих запитів     public   class   RetrofitClient   {\n   \n       private   static   Retrofit   retrofit;\n       private   static   final   String   BASE_URL   =   \"https://api.example.com/\"  ;\n   \n       public   static   Retrofit   getRetrofitInstance  () {\n           if   (retrofit   ==   null  ) {\n               retrofit   =   new   Retrofit.  Builder  ()\n                       .  baseUrl  (BASE_URL)\n                       .  addConverterFactory  (GsonConverterFactory.  create  ())\n                       .  build  ();\n           }\n           return   retrofit;\n       }\n   }\n  Крок 6: XML для Activity     \u003C!-- activity_main.xml -->\n   \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       tools:context  =  \".MainActivity\"  >\n   \n       \u003C  ListView\n           android:id  =  \"@+id/productsListView\"\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"0dp\"\n           android:layout_marginTop  =  \"16dp\"\n           android:layout_marginBottom  =  \"16dp\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toTopOf  =  \"@+id/buyButton\"   />\n   \n       \u003C  Button\n           android:id  =  \"@+id/buyButton\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Buy\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/productsListView\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"   />\n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  MVVM  Шаблон MVP непоганий, але Microsoft придумала шаблон ще кращий — MVVM (Model-View-ViewModel). Цей шаблон дуже полюбляють .NET-розробники, він використовується в Silverlight, WPF, WinUI 3, MAUI, його реалізація є в AngularJS. MVVM — дуже зручний шаблон.  Чим MVVM відрізняється від MVP?  MVVM дозволяє зв'язувати елементи   View  з властивостями та подіями   ViewModel . При цьому   ViewModel  — абстракція представлення. У MVVM є:    View  — містить поля, що відповідають інтерфейсу користувача.   ViewModel  — містить такі ж поля, але в предметній області.   Той же, Model .  Властивості   View  збігаються з властивостями   ViewModel/Model . При цьому   ViewModel  не має посилання на інтерфейс представлення. Зміна стану   ViewModel  автоматично змінює   View , і навпаки. Для цього використовується   механізм зв'язування даних . Також характерною рисою MVVM є двостороння комунікація з   View .    MVVM у розробці Android: Як використати шаблон із Java та Data Binding  Вступ   MVVM  (Model-View-ViewModel) — це один із найпопулярніших архітектурних шаблонів для Android-додатків. Він забезпечує чіткий поділ відповідальності, що робить код більш підтримуваним, тестованим і зрозумілим. У цій статті ми розглянемо, як реалізувати MVVM у Android із використанням   Java  та   Data Binding .   Що таке MVVM?   MVVM  розділяє додаток на три основні компоненти:    Model :\n   Відповідає за управління даними (логіка бізнесу, доступ до API, бази даних тощо).   View :\n   Це інтерфейс користувача (наприклад, XML-макет).  Відображає дані, які отримує від ViewModel.   ViewModel :\n   Зв'язує View і Model.  Містить всю логіку відображення даних і викликає Model для отримання або збереження даних.   Чому MVVM краще?  Переваги:    Чіткий поділ відповідальності : Легше підтримувати й розширювати додаток.   Легке тестування : ViewModel легко тестується, оскільки не має прямої залежності від UI.   Data Binding : Позбавляє необхідності оновлювати UI вручну.  Недоліки:   Додаткова складність у малих проєктах.  Потребує більшої кількості класів та налаштувань.   Data Binding: Що це?   Data Binding  дозволяє зв'язати UI-елементи напряму з даними у ViewModel, що усуває потребу в пошуку View через   findViewById  і дозволяє автоматично оновлювати UI при зміні даних.   Реалізація MVVM із Data Binding  Створимо простий приклад програми, що показує привітання користувачу за введеним ім'ям.   1. Налаштування проєкту  Додайте Data Binding у   build.gradle :     android {\n       ...\n       buildFeatures {\n           dataBinding true\n       }\n   }\n  Залежності:     dependencies {\n       implementation   'androidx.lifecycle:lifecycle-viewmodel:2.4.1'\n       implementation   'androidx.lifecycle:lifecycle-livedata:2.4.1'\n   }\n   2. Створіть ViewModel  ViewModel зберігає введені дані та генерує повідомлення.     import   androidx.lifecycle.LiveData  ;\n   import   androidx.lifecycle.MutableLiveData  ;\n   import   androidx.lifecycle.ViewModel  ;\n   \n   public   class   GreetingViewModel   extends   ViewModel   {\n   \n       private   MutableLiveData  \u003C  String  > name   =   new   MutableLiveData  \u003C>(  \"\"  );\n       private   MutableLiveData  \u003C  String  > greetingMessage   =   new   MutableLiveData  \u003C>(  \"\"  );\n   \n       public   LiveData  \u003C  String  >   getName  () {\n           return   name;\n       }\n   \n       public   void   setName  (  String   newName  ) {\n           name.  setValue  (newName);\n           updateGreetingMessage  ();\n       }\n   \n       public   LiveData  \u003C  String  >   getGreetingMessage  () {\n           return   greetingMessage;\n       }\n   \n       private   void   updateGreetingMessage  () {\n           String   currentName   =   name.  getValue  ();\n           if   (currentName   ==   null   ||   currentName.  isEmpty  ()) {\n               greetingMessage.  setValue  (  \"Привіт, незнайомцю!\"  );\n           }   else   {\n               greetingMessage.  setValue  (  \"Привіт, \"   +   currentName   +   \"!\"  );\n           }\n       }\n   }\n   3. Налаштуйте XML (View)  У XML ми використовуємо   Data Binding  для зв’язування UI-елементів із ViewModel.     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  layout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"  >\n       \u003C  data  >\n           \u003C  variable\n               name  =  \"viewModel\"\n               type  =  \"com.example.mvvmexample.GreetingViewModel\"   />\n       \u003C/  data  >\n   \n       \u003C  LinearLayout\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"match_parent\"\n           android:orientation  =  \"vertical\"\n           android:padding  =  \"16dp\"  >\n   \n           \u003C  EditText\n               android:layout_width  =  \"match_parent\"\n               android:layout_height  =  \"wrap_content\"\n               android:hint  =  \"Введіть своє ім'я\"\n               android:text  =  \"@={viewModel.name}\"   />\n   \n           \u003C  TextView\n               android:layout_width  =  \"match_parent\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"@{viewModel.greetingMessage}\"\n               android:layout_marginTop  =  \"16dp\"\n               android:textSize  =  \"20sp\"   />\n   \n       \u003C/  LinearLayout  >\n   \u003C/  layout  >\n   4. Створіть Activity (View)  У   MainActivity  ми ініціалізуємо ViewModel і зв’язуємо його з XML.     import   android.os.Bundle  ;\n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   androidx.databinding.DataBindingUtil  ;\n   import   androidx.lifecycle.ViewModelProvider  ;\n   \n   import   com.example.mvvmexample.databinding.ActivityMainBinding  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n   \n           // Використовуємо Data Binding\n           ActivityMainBinding   binding   =   DataBindingUtil.  setContentView  (  this  , R.layout.activity_main);\n   \n           // Ініціалізуємо ViewModel\n           GreetingViewModel   viewModel   =   new   ViewModelProvider  (  this  ).  get  (GreetingViewModel.class);\n   \n           // Прив'язуємо ViewModel до Binding\n           binding.  setViewModel  (viewModel);\n   \n           // Дозволяємо LiveData автоматично оновлювати UI\n           binding.  setLifecycleOwner  (  this  );\n       }\n   }\n   Що таке LiveData?   LiveData  — це об'єкт із бібліотеки Android Architecture Components, який спостерігає за даними і забезпечує автоматичне оновлення UI при зміні даних.  Переваги LiveData:   Автоматичне керування життєвим циклом.  Безпечне оновлення UI з фонових потоків.  Мінімізація витоків пам'яті.  Приклад із LiveData:  Створимо об'єкт LiveData для зберігання списку елементів:     private   MutableLiveData  \u003C  List  \u003C  String  >> items   =   new   MutableLiveData  \u003C>(  new   ArrayList  \u003C>());\n   \n   public   LiveData  \u003C  List  \u003C  String  >>   getItems  () {\n       return   items;\n   }\n   \n   public   void   addItem  (  String   item) {\n       List  \u003C  String  > currentItems   =   items.  getValue  ();\n       if   (currentItems   !=   null  ) {\n           currentItems.  add  (item);\n           items.  setValue  (currentItems);\n       }\n   }\n   Висновок  Шаблон   MVVM  у поєднанні з   Data Binding  і   LiveData  — це потужний інструмент для створення модульних і підтримуваних Android-додатків. У цьому прикладі ми створили простий додаток із привітанням, використовуючи найкращі практики. Цей підхід легко адаптується до складніших задач, таких як робота з API, базами даних або іншими джерелами даних.  ObservableArrayList в Android  Що таке ObservableArrayList?   ObservableArrayList  — це клас із бібліотеки Android Data Binding, який дозволяє створювати списки, зміни в яких автоматично відслідковуються та повідомляються підписникам. Це робить його ідеальним для використання у патерні   MVVM  разом із   Data Binding .  Клас   ObservableArrayList  особливо корисний, коли потрібно інтегрувати оновлення UI з бізнес-логікою, оскільки будь-яка зміна в списку автоматично тригерить оновлення прив’язаного представлення (  View ).   Як використовувати ObservableArrayList?     import   androidx.databinding.ObservableArrayList  ;\n   \n   public   class   CalculatorViewModel   extends   ViewModel   {\n       // Список операцій у калькуляторі\n       public   ObservableArrayList  \u003C  String  > operations   =   new   ObservableArrayList  \u003C>();\n   \n       // Додати операцію\n       public   void   addOperation  (  String   operation  ) {\n           operations.  add  (operation);\n       }\n   \n       // Видалити операцію\n       public   void   removeOperation  (  String   operation  ) {\n           operations.  remove  (operation);\n       }\n   }\n  У цьому прикладі список   operations  автоматично повідомляє прив’язаний UI, якщо змінюється його вміст.   Інтеграція з Data Binding  XML-макет     \u003C  layout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"  >\n       \u003C  data  >\n           \u003C  variable\n               name  =  \"viewModel\"\n               type  =  \"com.example.calculator.CalculatorViewModel\"   />\n       \u003C/  data  >\n   \n       \u003C  LinearLayout\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"match_parent\"\n           android:orientation  =  \"vertical\"  >\n   \n           \u003C!-- Список операцій -->\n           \u003C  ListView\n               android:id  =  \"@+id/operationsListView\"\n               android:layout_width  =  \"match_parent\"\n               android:layout_height  =  \"wrap_content\"\n               android:entries  =  \"@{viewModel.operations}\"   />\n   \n           \u003C!-- Додати операцію -->\n           \u003C  Button\n               android:layout_width  =  \"wrap_content\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"Додати операцію\"\n               android:onClick  =  \"@{() -> viewModel.addOperation(`Нова операція`)}\"   />\n       \u003C/  LinearLayout  >\n   \u003C/  layout  >\n  Що відбувається?    Прив’язка (Binding) : Список   operations  із ViewModel прив’язаний до   ListView .   Автоматичне оновлення : Будь-яка зміна в   ObservableArrayList  автоматично оновлює   ListView .   Особливості ObservableArrayList    Автоматичні повідомлення : Усі зміни в списку автоматично тригерять оновлення прив’язаного представлення.   Простота використання : Не потрібно вручну сповіщати підписників про зміни.   Інтеграція з Data Binding : Клас створений спеціально для роботи з Data Binding.   Немає підтримки складних змін : ObservableArrayList не підтримує подій на рівні окремих елементів (наприклад, оновлення властивості об’єкта в списку).   Обмеження ObservableArrayList    Масштабованість : Для великих списків або складних змін краще використовувати інші підходи, наприклад,   LiveData  чи   PagedList .   Прив’язка даних (Data Binding) в XML  Прив’язка даних у XML — це ключова особливість   Android Data Binding Library , яка дозволяє напряму з'єднати дані з інтерфейсом користувача. Цей підхід спрощує зв’язок між логікою (ViewModel) і представленням (View), що є особливо зручним у патерні MVVM.   Основний синтаксис прив’язки  1.   Декларація прив’язки в макеті  Щоб використовувати прив’язку даних у XML, макет файлу повинен починатися з   \u003Clayout> .     \u003C  layout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"  >\n       \u003C  data  >\n           \u003C!-- Оголошення змінних -->\n           \u003C  variable\n               name  =  \"viewModel\"\n               type  =  \"com.example.app.MyViewModel\"   />\n       \u003C/  data  >\n       \u003C!-- Основний макет -->\n       \u003C  LinearLayout\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"match_parent\"  >\n           \u003C!-- Елементи UI -->\n       \u003C/  LinearLayout  >\n   \u003C/  layout  >\n  2.   Оголошення змінних у   \u003Cdata>  Вкладений тег   \u003Cdata>  використовується для визначення змінних, які будуть доступні для прив’язки в XML. Змінна визначається за допомогою тега   \u003Cvariable> .     name  — ім’я змінної, яка буде доступна в XML.    type  — клас об’єкта, який буде прив’язаний.     \u003C  data  >\n       \u003C  variable\n           name  =  \"viewModel\"\n           type  =  \"com.example.app.MyViewModel\"   />\n   \u003C/  data  >\n   Типи прив’язки  1.   Прив’язка до властивостей  Використовуйте синтаксис   @{}  для прив’язки до властивостей об’єкта.     \u003C  TextView\n       android:layout_width  =  \"wrap_content\"\n       android:layout_height  =  \"wrap_content\"\n       android:text  =  \"@{viewModel.userName}\"   />\n  У цьому прикладі   userName  — це властивість у класі   MyViewModel .   2.   Прив’язка подій  Для подій (наприклад, натискань кнопок) використовується синтаксис   @{}  із лямбда-виразами.     \u003C  Button\n       android:layout_width  =  \"wrap_content\"\n       android:layout_height  =  \"wrap_content\"\n       android:text  =  \"Click Me\"\n       android:onClick  =  \"@{() -> viewModel.onButtonClick()}\"   />\n   3.   Прив’язка зі значеннями за замовчуванням  Ви можете вказати значення за замовчуванням, якщо значення прив’язки порожнє.     \u003C  TextView\n       android:layout_width  =  \"wrap_content\"\n       android:layout_height  =  \"wrap_content\"\n       android:text  =  \"@{viewModel.age != null ? viewModel.age : `Немає даних`}\"   />\n   4.   Прив’язка до методів  Можна викликати методи класу ViewModel напряму.     \u003C  ImageView\n       android:layout_width  =  \"wrap_content\"\n       android:layout_height  =  \"wrap_content\"\n       android:src  =  \"@{viewModel.getProfileImageUrl()}\"   />\n   Умовна прив’язка  Можна використовувати умовні вирази для динамічної зміни атрибутів.     \u003C  TextView\n       android:layout_width  =  \"wrap_content\"\n       android:layout_height  =  \"wrap_content\"\n       android:visibility  =  \"@{viewModel.isVisible ? View.VISIBLE : View.GONE}\"   />\n   Прив’язка з форматуванням  Використовуйте   String.format  для форматування тексту.     \u003C  TextView\n       android:layout_width  =  \"wrap_content\"\n       android:layout_height  =  \"wrap_content\"\n       android:text  =  '@{String.format(\"Привіт, %s!\", viewModel.userName)}'   />\n   Двостороння прив’язка  Двостороння прив’язка дозволяє автоматично оновлювати дані у ViewModel при зміні UI. Для цього використовується атрибут   @= .     \u003C  EditText\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"wrap_content\"\n       android:text  =  \"@={viewModel.userInput}\"   />\n   Якщо користувач вводить текст у   EditText , значення   userInput  у ViewModel автоматично оновлюється.  Зміни в   userInput  також автоматично відображаються в   EditText .   Робота з LiveData   LiveData  — це об'єкт, який використовується для спостереження за даними, які змінюються з часом. У Data Binding LiveData підтримується автоматично.  Прив’язка LiveData в XML     \u003C  TextView\n       android:layout_width  =  \"wrap_content\"\n       android:layout_height  =  \"wrap_content\"\n       android:text  =  \"@{viewModel.liveUserName}\"   />\n  ViewModel з LiveData     public   class   MyViewModel   extends   ViewModel   {\n       public   MutableLiveData  \u003C  String  > liveUserName   =   new   MutableLiveData  \u003C>();\n   \n       public   void   updateName  (  String   name  ) {\n           liveUserName.  setValue  (name);\n       }\n   }\n  У цьому прикладі:   Значення   liveUserName  автоматично відображається у   TextView .  Зміни у   liveUserName  викликають оновлення UI.   Додаткові приклади з LiveData  Прив’язка списків     \u003C  ListView\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"wrap_content\"\n       android:entries  =  \"@{viewModel.liveItems}\"   />\n  У ViewModel:     public   class   MyViewModel   extends   ViewModel   {\n       public   MutableLiveData  \u003C  List  \u003C  String  >> liveItems   =   new   MutableLiveData  \u003C>();\n   \n       public   void   addItem  (  String   item  ) {\n           List  \u003C  String  > currentItems   =   liveItems.  getValue  ();\n           if   (currentItems   ==   null  ) {\n               currentItems   =   new   ArrayList  \u003C>();\n           }\n           currentItems.  add  (item);\n           liveItems.  setValue  (currentItems);\n       }\n   }\n   Висновок  Прив’язка даних у XML за допомогою Data Binding Library — це потужний інструмент для створення сучасних Android-додатків. Використовуючи   Observable  об’єкти,   LiveData  і двосторонню прив’язку, можна значно спростити код та покращити його підтримку, особливо у великих проектах.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":642,"path":643,"dir":551,"title":644,"description":645,"keywords":646,"body":653},"content:1.android:4.lesson4:9.butter-knife.md","/android/lesson4/butter-knife","Butter Knife: Прив'язка полів та подій у Android","Butter Knife — це популярна бібліотека для Android, створена для спрощення прив'язки елементів інтерфейсу користувача (UI) та обробки подій. Вона усуває зайвий код і підвищує читабельність, роблячи розробку швидшою та приємнішою.",[647,648,649,650,651,652],"Чому Butter Knife?","Основні можливості","Як працює Butter Knife?","Переваги Butter Knife","Недоліки","Чому варто розглянути альтернативи?","  Butter Knife: Прив'язка полів та подій у Android  Butter Knife — це популярна бібліотека для Android, створена для спрощення прив'язки елементів інтерфейсу користувача (UI) та обробки подій. Вона усуває зайвий код і підвищує читабельність, роблячи розробку швидшою та приємнішою.  Чому Butter Knife?  Android-додатки часто потребують прив’язки елементів UI за допомогою методу   findViewById , який може бути громіздким і важким для підтримки. Butter Knife автоматизує цей процес, дозволяючи скоротити код, який прив'язує елементи до відповідних змінних або методів.  Основні можливості    Прив'язка видів (  Views ) : Використання анотацій для прив'язки елементів інтерфейсу.   Обробка подій : Прив'язка обробників кліків, довгих натискань та інших подій.   Групова прив'язка : Робота з групами елементів (наприклад, одночасна прив'язка кількох кнопок).   Як працює Butter Knife?  Підключення до проекту   Додайте залежність у ваш   build.gradle  файл:     dependencies {\n       implementation   'com.jakewharton:butterknife:10.2.3'\n       annotationProcessor   'com.jakewharton:butterknife-compiler:10.2.3'\n   }\n   Синхронізуйте проект, щоб завантажити бібліотеку.   Прив'язка   Views  Замість використання   findViewById , можна скористатися анотацією   @BindView :     import   butterknife.BindView  ;\n   import   butterknife.ButterKnife  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n       @  BindView  (R.id.textView)\n       TextView   textView;\n   \n       @  BindView  (R.id.button)\n       Button   button;\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n   \n           // Ініціалізація Butter Knife\n           ButterKnife.  bind  (  this  );\n   \n           // Використання прив'язаних елементів\n           textView.  setText  (  \"Привіт, Butter Knife!\"  );\n           button.  setOnClickListener  (v   ->   textView.  setText  (  \"Кнопка натиснута!\"  ));\n       }\n   }\n   Обробка подій  Butter Knife підтримує анотації для обробки подій, таких як кліки:     import   butterknife.OnClick  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n       @  BindView  (R.id.textView)\n       TextView   textView;\n   \n       @  OnClick  (R.id.button)\n       void   onButtonClick  () {\n           textView.  setText  (  \"Кнопка натиснута!\"  );\n       }\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n           ButterKnife.  bind  (  this  );\n       }\n   }\n   Групова прив'язка  Якщо потрібно обробляти події для кількох елементів одночасно:     import   butterknife.BindViews  ;\n   import   butterknife.OnClick  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n       @  BindViews  ({R.id.button1, R.id.button2, R.id.button3})\n       List  \u003C  Button  > buttons;\n   \n       @  OnClick  ({R.id.button1, R.id.button2, R.id.button3})\n       void   onAnyButtonClick  (  Button   button  ) {\n           button.  setText  (  \"Натиснуто!\"  );\n       }\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n           ButterKnife.  bind  (  this  );\n       }\n   }\n   Використання в адаптерах  Butter Knife також можна використовувати у адаптерах, що зручно для роботи зі списками (  RecyclerView ):     public   class   MyAdapter   extends   RecyclerView.Adapter  \u003C  MyAdapter  .  ViewHolder  > {\n   \n       class   ViewHolder   extends   RecyclerView.ViewHolder   {\n           @  BindView  (R.id.item_text)\n           TextView   textView;\n   \n           public   ViewHolder  (  View   itemView  ) {\n               super  (itemView);\n               ButterKnife.  bind  (  this  , itemView);\n           }\n       }\n   \n       @  Override\n       public   void   onBindViewHolder  (  ViewHolder   holder  ,   int   position  ) {\n           holder.textView.  setText  (  \"Елемент \"   +   position);\n       }\n   \n       // Інші методи адаптера...\n   }\n   Переваги Butter Knife    Менше коду : Замість десятків викликів   findViewById  використовується анотація   @BindView .   Читабельність : Код виглядає чистіше та структурованіше.   Підтримка багатьох подій : Простота обробки подій, включаючи кліки, довгі натискання тощо.   Недоліки    Менше гнучкості : Залежність від сторонньої бібліотеки.   Відсутність офіційної підтримки : Butter Knife більше не розробляється та рекомендується замінювати на Android Data Binding або View Binding.   Чому варто розглянути альтернативи?  Хоча Butter Knife досі використовується, сучасні технології Android, такі як   View Binding  та   Data Binding , є більш потужними, офіційно підтримуються Google і забезпечують аналогічну функціональність із більшою безпекою.   Butter Knife залишається корисною бібліотекою для швидкого старту з прив'язкою елементів UI, але нові проекти краще базувати на офіційних інструментах Android.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":655,"path":656,"dir":551,"title":657,"description":658,"keywords":659,"body":663},"content:1.android:4.lesson4:10.view-binding.md","/android/lesson4/view-binding","View Binding в Android","View Binding — це функція в Android, яка дозволяє спростити доступ до елементів UI та уникнути використання findViewById. Вона автоматично генерує клас для кожного XML макета в вашому проекті, надаючи вам безпечний тип доступу до елементів інтерфейсу. Це сучасна альтернатива таким бібліотекам, як Butter Knife.",[660,661,662],"Переваги View Binding","Як включити View Binding в проект","Підсумки","  View Binding в Android   View Binding  — це функція в Android, яка дозволяє спростити доступ до елементів UI та уникнути використання   findViewById . Вона автоматично генерує клас для кожного XML макета в вашому проекті, надаючи вам безпечний тип доступу до елементів інтерфейсу. Це сучасна альтернатива таким бібліотекам, як   Butter Knife .  Переваги View Binding    Безпека типів : Після активації View Binding Android Studio автоматично генерує класи для кожного макета, що забезпечує безпеку типів при доступі до елементів UI.   Продуктивність : View Binding працює без рефлексії, тому є більш швидким і продуктивним у порівнянні з іншими бібліотеками.   Легкість налаштування : Налаштування View Binding займає мінімум часу і не потребує додаткових анотацій.   Підтримка : View Binding є частиною Android Jetpack, тому він регулярно оновлюється і підтримується Google.   Автоматична генерація класів : Для кожного макета в XML генерується клас, що дозволяє працювати з елементами UI без необхідності використовувати   findViewById  чи будь-які інші бібліотеки.  Як включити View Binding в проект  Щоб почати використовувати View Binding у своєму проекті, потрібно зробити кілька простих кроків.  Крок 1: Налаштування View Binding в   build.gradle  Для активації View Binding, вам потрібно додати наступне налаштування в файл   build.gradle  (в розділ   android ):     android {\n       ...\n       viewBinding {\n           enabled   = true\n       }\n   }\n  Це дозволить Android Studio генерувати відповідні класи для ваших макетів.  Крок 2: Використання View Binding у коді  Після того, як View Binding активовано, вам потрібно замінити виклики   findViewById  на об'єкти, які генеруються автоматично.  Ось приклад використання View Binding у   Activity :     import   android.os.Bundle  ;\n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   com.example.viewbindingexample.databinding.ActivityMainBinding  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       // Створення об'єкта для ViewBinding\n       private   ActivityMainBinding   binding;\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n   \n           // Ініціалізація ViewBinding\n           binding   =   ActivityMainBinding.  inflate  (  getLayoutInflater  ());\n           setContentView  (binding.  getRoot  ());\n   \n           // Тепер доступ до елементів UI без використання findViewById\n           binding.textView.  setText  (  \"Hello, View Binding!\"  );\n           binding.button.  setOnClickListener  (v   ->   {\n               binding.textView.  setText  (  \"Button Clicked!\"  );\n           });\n       }\n   \n       @  Override\n       protected   void   onDestroy  () {\n           super  .  onDestroy  ();\n           // Очищення для уникнення утечок пам'яті\n           binding   =   null  ;\n       }\n   }\n  У цьому прикладі, клас   ActivityMainBinding  генерується автоматично на основі XML файлу   activity_main.xml . Він містить посилання на всі елементи UI, що визначені в цьому макеті.  Крок 3: Використання в   Fragment  View Binding також чудово працює в   Fragment :     import   android.os.Bundle  ;\n   import   androidx.fragment.app.Fragment  ;\n   import   com.example.viewbindingexample.databinding.FragmentExampleBinding  ;\n   \n   public   class   ExampleFragment   extends   Fragment   {\n   \n       private   FragmentExampleBinding   binding;\n   \n       @  Override\n       public   View   onCreateView  (  LayoutInflater   inflater  ,   ViewGroup   container  ,\n                                Bundle   savedInstanceState  ) {\n           binding   =   FragmentExampleBinding.  inflate  (inflater, container,   false  );\n           binding.textView.  setText  (  \"Hello from Fragment!\"  );\n           return   binding.  getRoot  ();\n       }\n   \n       @  Override\n       public   void   onDestroyView  () {\n           super  .  onDestroyView  ();\n           // Очищення для уникнення утечок пам'яті\n           binding   =   null  ;\n       }\n   }\n  Важливо пам'ятати, що в   Fragment  необхідно очищати об'єкт binding в методі   onDestroyView , щоб уникнути витоків пам'яті.  Підсумки  View Binding є чудовою альтернативою для традиційного використання   findViewById . Вона забезпечує безпеку типів, спрощує доступ до елементів UI і працює значно швидше завдяки відсутності рефлексії. Оскільки View Binding підтримується Google і є частиною Android Jetpack, він є офіційним і рекомендованим інструментом для роботи з інтерфейсами користувача в Android.  Використовуючи View Binding, ви можете значно покращити читабельність і підтримку вашого коду, спрощуючи доступ до елементів UI та мінімізуючи кількість помилок.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":665,"path":666,"dir":667,"title":668,"description":669,"keywords":670,"body":673},"content:1.android:5.lesson5:1.webview.md","/android/lesson5/webview","lesson5","WebView","WebView — це простий елемент для рендерингу HTML-коду, який базується на рушії WebKit. Завдяки цьому WebView можна використовувати як примітивний веб-браузер для перегляду контенту з інтернету. Використання рушія WebKit гарантує, що відображення контенту буде аналогічним до інших браузерів на цьому рушії, наприклад, Google Chrome і Safari.",[671,672],"Основні методи класу WebView","JavaScript","  WebView   WebView  — це простий елемент для рендерингу HTML-коду, який базується на рушії WebKit. Завдяки цьому WebView можна використовувати як примітивний веб-браузер для перегляду контенту з інтернету. Використання рушія WebKit гарантує, що відображення контенту буде аналогічним до інших браузерів на цьому рушії, наприклад, Google Chrome і Safari.  Основні методи класу WebView     boolean canGoBack()  \nПовертає   true , якщо перед поточною веб-сторінкою в історії навігації WebView є інші сторінки.    boolean canGoForward()  \nПовертає   true , якщо після поточної веб-сторінки в історії навігації WebView є інші сторінки.    void clearCache(boolean includeDiskFiles)  \nОчищає кеш WebView.    void clearFormData()  \nОчищає дані автозаповнення полів форм.    void clearHistory()  \nОчищає історію навігації WebView.    String getUrl()  \nПовертає адресу поточної веб-сторінки.    void goBack()  \nПереходить до попередньої веб-сторінки в історії навігації.    void goForward()  \nПереходить до наступної веб-сторінки в історії навігації.    void loadData(String data, String mimeType, String encoding)  \nЗавантажує в браузер дані у вигляді HTML-коду з вказаним MIME-типом і кодуванням.    void loadDataWithBaseURL(String baseUrl, String data, String mimeType, String encoding, String historyUrl)  \nЗавантажує в браузер дані у вигляді HTML-коду, використовуючи вказаний MIME-тип і кодування. Крім того, приймає валідний базовий URL для зв'язку завантаженого контенту.   Примітка:  \nМетод   loadData()  встановлює значення   null  для   window.origin , що може перешкоджати перевірці джерела вмісту. Метод   loadDataWithBaseURL()  дозволяє встановлювати джерело вмісту за допомогою валідних адрес (HTTP або HTTPS).    void loadUrl(String url)  \nЗавантажує веб-сторінку за вказаною адресою.    void postUrl(String url, byte[] postData)  \nНадсилає дані за допомогою POST-запиту за вказаною адресою.    void zoomBy(float zoomFactor)  \nЗмінює масштаб на вказаний коефіцієнт.    boolean zoomIn()  \nЗбільшує масштаб.    boolean zoomOut()  \nЗменшує масштаб.  Працювати з   WebView  дуже просто. Визначимо цей елемент у розмітці layout:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  WebView\n           android:id  =  \"@+id/webBrowser\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n    \n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"  />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n   Для отримання доступу до інтернету із застосунку, необхідно вказати у файлі маніфесту   AndroidManifest.xml  відповідний дозвіл:     \u003C  uses-permission   android:name  =  \"android.permission.INTERNET\"  />\n  Щоб завантажити певну сторінку в WebView, через метод   loadUrl()  треба встановити її адресу:     package   com.example.viewapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n   import   android.webkit.WebView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           WebView   browser  =  findViewById  (R.id.webBrowser);\n           browser.  loadUrl  (  \"https://itstep.org\"  );\n       }\n   }\n  Крім завантаження конкретної сторінки з інтернету за допомогою метод   loadData() :     WebView   browser  =   findViewById  (R.id.webBrowser);\n   browser.  loadData  (  \"\u003Chtml>\u003Cbody>\u003Ch2>Hello, Android!\u003C/h2>\u003C/body>\u003C/html>\"  ,   \"text/html\"  ,   \"UTF-8\"  );\n  Першим параметром метод приймає рядок коду html, у другому - тип вмісту, а в третьому - кодування.    JavaScript  За замовчуванням у   WebView  вимкнено javascript, щоб його увімкнути треба застосувати метод   setJavaScriptEnabled(true)  об'єкта   WebSettings :     import   android.webkit.WebSettings  ;\n   //.....................................\n   WebView   browser   =   findViewById  (R.id.webBrowser);\n   WebSettings   webSettings   =   browser.  getSettings  ();\n   webSettings.  setJavaScriptEnabled  (  true  );\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":675,"path":676,"dir":667,"title":677,"description":678,"keywords":679,"body":685},"content:1.android:5.lesson5:2.network.md","/android/lesson5/network","Робота з мережею","Робота з мережею є ключовою частиною багатьох Android-додатків. У цій статті ми розглянемо, як виконувати HTTP-запити, використовуючи нативний підхід.",[680,681,682,683,684,224],"Кроки для використання HttpURLConnection:","Приклад реалізації GET-запиту","Використання у фоновому потоці","Кращі практики при роботі з мережею","Чому варто використовувати бібліотеки?","  Робота з мережею  Робота з мережею є ключовою частиною багатьох Android-додатків. У цій статті ми розглянемо, як виконувати HTTP-запити, використовуючи нативний підхід.  Для виконання HTTP-запитів в Android за замовчуванням можна використовувати клас   HttpURLConnection . Цей клас дозволяє відправляти HTTP-запити і обробляти відповіді.   Кроки для використання   HttpURLConnection :    Встановлення з'єднання : Ініціалізація та конфігурація запиту.   Відправлення даних : Запис у вихідний потік (якщо потрібно).   Отримання відповіді : Читання вхідного потоку.   Закриття з'єднання : Закриття потоків після завершення роботи.   Приклад реалізації GET-запиту     import   java.io.BufferedReader  ;\n   import   java.io.InputStreamReader  ;\n   import   java.net.HttpURLConnection  ;\n   import   java.net.URL  ;\n   \n   public   class   NetworkUtils   {\n   \n       public   static   String   sendGetRequest  (  String   urlString  ) {\n           StringBuilder   result   =   new   StringBuilder  ();\n           HttpURLConnection   connection   =   null  ;\n   \n           try   {\n               // Створення URL-об'єкта\n               URL   url   =   new   URL  (urlString);\n   \n               // Відкриття з'єднання\n               connection   =   (HttpURLConnection) url.  openConnection  ();\n               connection.  setRequestMethod  (  \"GET\"  );\n               connection.  setConnectTimeout  (  10000  );   // Таймаут для з'єднання\n               connection.  setReadTimeout  (  10000  );      // Таймаут для читання\n   \n               // Перевірка статусу відповіді\n               int   responseCode   =   connection.  getResponseCode  ();\n               if   (responseCode   ==   HttpURLConnection.HTTP_OK) {\n                   // Читання відповіді\n                   BufferedReader   reader   =   new   BufferedReader  (  new   InputStreamReader  (connection.  getInputStream  ()));\n                   String   line;\n                   while   ((line   =   reader.  readLine  ())   !=   null  ) {\n                       result.  append  (line);\n                   }\n                   reader.  close  ();\n               }   else   {\n                   result.  append  (  \"Error: \"  ).  append  (responseCode);\n               }\n           }   catch   (  Exception   e  ) {\n               e.  printStackTrace  ();\n               result.  append  (  \"Exception: \"  ).  append  (e.  getMessage  ());\n           }   finally   {\n               if   (connection   !=   null  ) {\n                   connection.  disconnect  ();\n               }\n           }\n   \n           return   result.  toString  ();\n       }\n   }\n   Використання у фоновому потоці  Мережеві операції   не можна виконувати в головному потоці , оскільки це призведе до помилки   NetworkOnMainThreadException . Для виконання запитів у фоновому потоці можна використовувати   AsyncTask  або сучасніші підходи.  Приклад з використанням   AsyncTask :     import   android.os.AsyncTask  ;\n   \n   public   class   GetDataTask   extends   AsyncTask  \u003C  String  ,   Void  ,   String  > {\n   \n       @  Override\n       protected   String   doInBackground  (  String  ...   params  ) {\n           String   url   =   params[  0  ];\n           return   NetworkUtils.  sendGetRequest  (url);\n       }\n   \n       @  Override\n       protected   void   onPostExecute  (  String   result  ) {\n           // Оновлення UI після отримання даних\n           System.out.  println  (  \"Result: \"   +   result);\n       }\n   }\n  Виклик:     new   GetDataTask  ().  execute  (  \"https://jsonplaceholder.typicode.com/posts\"  );\n   Кращі практики при роботі з мережею    Використовуйте таймаути : Завжди налаштовуйте   setConnectTimeout  та   setReadTimeout , щоб уникнути зависання запитів.   Обробляйте виключення : Обов'язково обробляйте   IOException  та інші можливі виключення.   Закривайте з'єднання : Використовуйте   disconnect()  для закриття з'єднань.   Не виконуйте запити в головному потоці : Використовуйте фонові потоки або спеціалізовані бібліотеки.   Використовуйте кешування : Якщо дані не змінюються часто, кешуйте їх локально.   Чому варто використовувати бібліотеки?  Нативний підхід хоч і надає повний контроль над мережею, але є досить складним і громіздким для реальних проектів. Саме тому більшість розробників використовують популярні бібліотеки, такі як:    Retrofit  (простота у використанні, підтримка REST API)   Volley  (ефективне управління чергою запитів)   OkHttp  (низькорівневий клієнт з потужними можливостями)   Висновок  Нативний підхід до роботи з мережею в Android дозволяє отримати повний контроль над HTTP-запитами, але потребує багато коду для реалізації навіть простих задач. Для великих проектів рекомендується використовувати бібліотеки, що значно спрощують роботу з мережею.   Ви можете використовувати наведений код у ваших проектах, щоб зрозуміти, як працює   HttpURLConnection , і одночасно оцінити переваги бібліотек для роботи з мережею.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":687,"path":688,"dir":667,"title":689,"description":690,"keywords":691,"body":698},"content:1.android:5.lesson5:3.okhttp.md","/android/lesson5/okhttp","OkHttp","OkHttp — це популярна бібліотека для роботи з HTTP-запитами в Android. Вона надає потужний і гнучкий API для виконання мережевих запитів. OkHttp забезпечує високу продуктивність, простоту використання і підтримує сучасні мережеві протоколи, такі як HTTP/2 і WebSocket.",[692,693,694,695,696,697,224],"Чому варто використовувати OkHttp?","Додавання OkHttp до проекту","Основи використання OkHttp","Кешування","Робота з WebSocket","Кращі практики","  OkHttp   OkHttp  — це популярна бібліотека для роботи з HTTP-запитами в Android. Вона надає потужний і гнучкий API для виконання мережевих запитів. OkHttp забезпечує високу продуктивність, простоту використання і підтримує сучасні мережеві протоколи, такі як HTTP/2 і WebSocket.   Чому варто використовувати OkHttp?    Простота та зручність : Інтуїтивний API для створення і відправки запитів.   Підтримка HTTP/2 : Менше з'єднань і краща швидкість передачі.   Підтримка WebSocket : Для побудови додатків у реальному часі.   Масштабованість : Можливість кастомізації через інтерцептори.   Автоматичне кешування : Зменшення навантаження на сервер і збереження даних офлайн.   Додавання OkHttp до проекту  Щоб використовувати OkHttp у вашому проекті, додайте залежність у   build.gradle :     dependencies {\n       implementation   'com.squareup.okhttp3:okhttp:4.11.0'\n   }\n   Основи використання OkHttp  1. Виконання GET-запиту     import   okhttp3.OkHttpClient  ;\n   import   okhttp3.Request  ;\n   import   okhttp3.Response  ;\n   import   java.io.IOException  ;\n   \n   public   class   NetworkUtils   {\n   \n       private   final   OkHttpClient   client   =   new   OkHttpClient  ();\n   \n       public   String   sendGetRequest  (  String   url  )   throws   IOException   {\n           // Створення запиту\n           Request   request   =   new   Request.  Builder  ()\n                   .  url  (url)\n                   .  build  ();\n   \n           // Виконання запиту\n           try   (  Response   response   =   client.  newCall  (request).  execute  ()) {\n               if   (  !  response.  isSuccessful  ()) {\n                   throw   new   IOException  (  \"Unexpected code \"   +   response);\n               }\n               return   response.  body  ().  string  ();\n           }\n       }\n   }\n   2. Виконання POST-запиту     import   okhttp3.  *  ;\n   \n   import   java.io.IOException  ;\n   \n   public   class   NetworkUtils   {\n   \n       private   final   OkHttpClient   client   =   new   OkHttpClient  ();\n   \n       public   String   sendPostRequest  (  String   url  ,   String   json  )   throws   IOException   {\n           // Створення тіла запиту\n           RequestBody   body   =   RequestBody.  create  (json, MediaType.  get  (  \"application/json; charset=utf-8\"  ));\n   \n           // Створення запиту\n           Request   request   =   new   Request.  Builder  ()\n                   .  url  (url)\n                   .  post  (body)\n                   .  build  ();\n   \n           // Виконання запиту\n           try   (  Response   response   =   client.  newCall  (request).  execute  ()) {\n               if   (  !  response.  isSuccessful  ()) {\n                   throw   new   IOException  (  \"Unexpected code \"   +   response);\n               }\n               return   response.  body  ().  string  ();\n           }\n       }\n   }\n   3. Асинхронні запити  OkHttp дозволяє виконувати запити у фоновому потоці за допомогою методу   enqueue .     public   void   sendAsyncRequest  (  String   url) {\n       Request   request   =   new   Request.  Builder  ()\n               .  url  (url)\n               .  build  ();\n   \n       client.  newCall  (request).  enqueue  (  new   Callback  () {\n           @  Override\n           public   void   onFailure  (  Call   call  ,   IOException   e  ) {\n               e.  printStackTrace  ();\n           }\n   \n           @  Override\n           public   void   onResponse  (  Call   call  ,   Response   response  )   throws   IOException   {\n               if   (response.  isSuccessful  ()) {\n                   System.out.  println  (  \"Response: \"   +   response.  body  ().  string  ());\n               }\n           }\n       });\n   }\n   4. Використання інтерцепторів  Інтерцептори дозволяють виконувати операції перед або після відправлення запиту, наприклад, додавання заголовків.     import   okhttp3.  *  ;\n   \n   import   java.io.IOException  ;\n   \n   public   class   CustomClient   {\n   \n       public   OkHttpClient   getClientWithInterceptor  () {\n           return   new   OkHttpClient.  Builder  ()\n                   .  addInterceptor  (chain   ->   {\n                       Request   request   =   chain.  request  ().  newBuilder  ()\n                               .  addHeader  (  \"Authorization\"  ,   \"Bearer YOUR_TOKEN\"  )\n                               .  build  ();\n                       return   chain.  proceed  (request);\n                   })\n                   .  build  ();\n       }\n   }\n   Кешування  OkHttp підтримує автоматичне кешування відповідей для зменшення кількості запитів до сервера.     import   okhttp3.Cache  ;\n   import   okhttp3.OkHttpClient  ;\n   \n   import   java.io.File  ;\n   \n   public   class   CacheConfig   {\n   \n       public   OkHttpClient   getClientWithCache  (  File   cacheDir  ) {\n           int   cacheSize   =   10   *   1024   *   1024  ;   // 10 MB\n           Cache   cache   =   new   Cache  (cacheDir, cacheSize);\n   \n           return   new   OkHttpClient.  Builder  ()\n                   .  cache  (cache)\n                   .  build  ();\n       }\n   }\n   Робота з WebSocket  OkHttp спрощує роботу з WebSocket-з'єднаннями для додатків у реальному часі.     import   okhttp3.  *  ;\n   \n   public   class   WebSocketExample   {\n   \n       private   final   OkHttpClient   client   =   new   OkHttpClient  ();\n   \n       public   void   connectWebSocket  (  String   url  ) {\n           Request   request   =   new   Request.  Builder  ()\n                   .  url  (url)\n                   .  build  ();\n   \n           WebSocket   webSocket   =   client.  newWebSocket  (request,   new   WebSocketListener  () {\n               @  Override\n               public   void   onOpen  (  WebSocket   webSocket  ,   Response   response  ) {\n                   System.out.  println  (  \"WebSocket Opened\"  );\n                   webSocket.  send  (  \"Hello, Server!\"  );\n               }\n   \n               @  Override\n               public   void   onMessage  (  WebSocket   webSocket  ,   String   text  ) {\n                   System.out.  println  (  \"Message: \"   +   text);\n               }\n   \n               @  Override\n               public   void   onClosed  (  WebSocket   webSocket  ,   int   code  ,   String   reason  ) {\n                   System.out.  println  (  \"WebSocket Closed: \"   +   reason);\n               }\n   \n               @  Override\n               public   void   onFailure  (  WebSocket   webSocket  ,   Throwable   t  ,   Response   response  ) {\n                   t.  printStackTrace  ();\n               }\n           });\n       }\n   }\n   Кращі практики    Асинхронність : Використовуйте асинхронні запити для уникнення блокування головного потоку.   Безпека : Завжди обробляйте виключення та перевіряйте відповідь сервера.   Кешування : Використовуйте кеш для оптимізації мережевих ресурсів.   Тестування : Використовуйте   MockWebServer  для створення тестів.   Висновок  OkHttp є одним із найкращих інструментів для роботи з мережею в Android. Він поєднує в собі простоту, потужність і розширюваність, що робить його ідеальним вибором як для невеликих, так і для великих проектів.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":700,"path":701,"dir":667,"title":702,"description":703,"keywords":704,"body":726},"content:1.android:5.lesson5:4.okhttp-ext.md","/android/lesson5/okhttp-ext","OkHttp (extend)","OkHttp — це бібліотека та водночас HTTP‑клієнт із відкритим кодом для Java та Kotlin, розроблений компанією Square, яка також створила Retrofit.",[705,706,707,708,709,710,711,712,713,714,715,716,717,718,224,719,720,721,722,723,724,725],"Зміст:","Переваги OkHttp","Основні класи та методи","Простий GET-запит (синхронний/асинхронний)","Синхронний запит (Java):","Синхронний запит (Kotlin):","Асинхронний запит (Java):","Асинхронний запит (Kotlin):","Callback має два абстрактні методи:","Серіалізація/десеріалізація","Простий POST-запит","Особливості роботи з HTTPS","Аутентифікація на сервері","Приклад з ViewModel","Приклад okHttp з MVVM","1. Модель даних (Post.java)","2. ViewModel (PostViewModel.java)","3. Activity (MainActivity.java)","4. Адаптер для RecyclerView (PostAdapter.java)","5. Layout для Activity (activity_main.xml)","6. Layout для елемента списку (item_post.xml)","  OkHttp (extend)   OkHttp  — це бібліотека та водночас HTTP‑клієнт із відкритим кодом для Java та Kotlin, розроблений компанією   Square , яка також створила   Retrofit .   OkHttp  надає простий та легкий у використанні API для виконання HTTP‑запитів, включаючи підтримку протоколів HTTP/1.1 і HTTP/2. Бібліотека підтримує всі стандартні методи HTTP, може обробляти кілька одночасних запитів та пропонує розширені можливості: кешування запитів/відповідей, об'єднання підключень у пул (connection pooling), аутентифікацію тощо.  Зміст:   Переваги OkHttp  Основні класи та методи  Простий GET‑запит (синхронний/асинхронний)  Серіалізація/десеріалізація  Простий POST‑запит  Особливості роботи з HTTPS  Аутентифікація на сервері  Використання разом із ViewModel  Переваги OkHttp   OkHttp  — це бібліотека нижчого рівня порівняно з   Retrofit . Це означає, що HTTP‑запити, автоматизовані у   Retrofit  за допомогою анотацій, доведеться писати вручну. Проте саме в цьому і полягає головна перевага бібліотеки: вона надає ширший функціонал та налаштування з'єднань, що може підвищити продуктивність та зменшити використання пам'яті. До речі,   Retrofit  \"під капотом\" використовує   OkHttp .  Бібліотека створена як легка та ефективна, з акцентом на зниження затримок і підвищення працездатності. Це досягається завдяки застосуванню різних методів оптимізації, таких як повторне використання з'єднань, стиснення та конвеєризація.  Переваги OkHttp:    Гнучкість:  Бібліотека надає більше контролю над процесом мережевої взаємодії завдяки додатковим функціям, наприклад, кастомній обробці запитів і відповідей.   Легкість:    OkHttp  — компактніша бібліотека порівняно з   Retrofit , що дозволяє мінімізувати обсяг використовуваної додатком пам'яті.   Кешування:  Бібліотека має вбудовану підтримку HTTP‑кешування, що може підвищити продуктивність і знизити навантаження на мережу.   Аутентифікація:    OkHttp  надає гнучкий і розширюваний API для аутентифікації, що спрощує реалізацію різних її моделей.   Перехоплювачі (Interceptors):  Це механізм, який дозволяє легко налаштовувати запити та відповіді, а також є чудовим вибором для додатків, що потребують розширеної обробки запитів.   WebSockets:    OkHttp  забезпечує вбудовану підтримку   WebSockets , що дозволяє легко реалізувати комунікацію з сервером у режимі реального часу.  Основні класи та методи  1) Налаштування клієнта та запиту   Клас OkHttpClient  — це клієнт для HTTP‑викликів, який використовується для відправки запитів і читання відповідей.    OkHttpClient.Builder  — клас, що надає методи для налаштування клієнта (кеш, аутентифікація, перехоплювачі, тайм‑аути тощо). Завершується налаштування викликом методу   build() , який повертає екземпляр класу   OkHttpClient .   Рекомендація:  створюйте один екземпляр   OkHttpClient  і використовуйте його повторно для всіх HTTP‑викликів. Це дозволяє зменшити затримки та економити пам'ять завдяки повторному використанню пулів з'єднань і потоків. Створення клієнта для кожного запиту призводить до марнування ресурсів.   Клас Request  представляє HTTP‑запит.    Request.Builder  дозволяє встановити параметри запиту, такі як   url  та заголовки.  Робота із заголовками:    header(name, value)  — встановлює одне значення для заголовка, видаляючи всі існуючі.   addHeader(name, value)  — додає нове значення заголовка, не видаляючи існуючі.  Для читання заголовків із відповіді:    header(name)  — повертає останнє значення заголовка або   null , якщо значення відсутнє.   headers(name)  — повертає всі значення заголовка у вигляді списку.  Для встановлення цільового URL використовується метод   url() . Завершення налаштування запиту виконується викликом методу   build() .   2) Відправка запиту    Метод newCall  класу   OkHttpClient  готує запит до виконання. Приймає об'єкт   Request  і повертає об'єкт   Call .   Клас Call  представляє запит, готовий до виконання. Він не може бути виконаний двічі та підтримує скасування.  Методи для виконання запиту:    execute()  — синхронний виклик, блокує потік до отримання відповіді або виникнення помилки.   enqueue()  — асинхронний виклик, виконує запит у майбутньому, повертає   responseCallback  із відповіддю або винятком у разі помилки.   3) Читання відповіді   Клас Response  представляє HTTP‑відповідь. Тіло відповіді є одноразовим і має бути закрите після використання. Усі інші властивості незмінні.  Перед обробкою тіла необхідно перевірити успішність запиту:    Метод isSuccessful()  перевіряє код статусу HTTP‑відповіді. Повертає   true , якщо код у діапазоні 200-300, інакше —   false .  Для отримання тіла відповіді використовується метод   body() , який повертає об'єкт   ResponseBody .   Робота з ResponseBody   ResponseBody  — це одноразовий потік даних від сервера до клієнта. Підтримує передавання великих відповідей, наприклад, потокового відео.  Методи для роботи з тілом відповіді:    bytes() ,   string()  — читають текст відповіді в пам'ять і повертають у вигляді масиву байтів або строки. Підходять для малих відповідей.   source ,   byteStream ,   charStream  — використовуються для потокового читання:\n    source  — повертає   BufferedSource  для роботи з потоком байтів.   byteStream  — повертає   InputStream .   charStream  — повертає   Reader  для роботи з потоком символів.  Якщо використати   body()  без вказаних методів, буде повернуто сам об'єкт   ResponseBody , з яким нічого не можна зробити.  Простий GET-запит (синхронний/асинхронний)  Перед використанням бібліотеки потрібно додати відповідну залежність у ini:     implementation   'com.squareup.okhttp3:okhttp:4.10.0'\n  Номер останньої версії можна подивитися на Maven Central.  Синхронний запит (Java):     OkHttpClient   client   =   new   OkHttpClient  ();\n   \n   Request   request   =   new   Request.  Builder  ()\n           .  url  (  \"https://publicobject.com/helloworld.txt\"  )\n           .  build  ();\n   \n   try   (  Response   response   =   client.  newCall  (request).  execute  ()) {\n       if   (  !  response.  isSuccessful  ()) {\n           throw   new   IOException  (  \"Запит до сервера не був успішним: \"   +\n                   response.  code  ()   +   \" \"   +   response.  message  ());\n       }\n       // приклад отримання конкретного заголовка відповіді\n       System.out.  println  (  \"Server: \"   +   response.  header  (  \"Server\"  ));\n       // виведення тіла відповіді\n       System.out.  println  (response.  body  ().  string  ());\n   }   catch   (  IOException   e  ) {\n       System.out.  println  (  \"Помилка підключення: \"   +   e);\n   }\n  Синхронний запит (Kotlin):     val   client   =   OkHttpClient  ()\n   \n   val   request   =   Request.  Builder  ()\n       .  url  (  \"https://publicobject.com/helloworld.txt\"  )\n       .  build  ()\n   \n   try   {\n       client.  newCall  (request).  execute  ().  use   { response   ->\n           if   (  !  response.isSuccessful) {\n               throw   IOException  (  \"Запит до сервера не був успішним:\"   +\n                       \"   ${  response.code  }   ${  response.message  }  \"  )\n           }\n           // приклад отримання конкретного заголовка відповіді\n           println  (  \"Server:   ${  response.  header  (  \"Server\"  )  }  \"  )\n           // виведення тіла відповіді\n           println  (response.body  !!  .  string  ())\n       }\n   }   catch   (e:   IOException  ) {\n       println  (  \"Помилка підключення:   $e  \"  );\n   }\n  В той час як у Java використовуються методи об'єктів, у Kotlin інколи використовуються їх властивості. Наприклад, властивість   body  об'єкта   Response .  Кожне тіло відповіді підтримується обмеженим ресурсом. Тому після використання воно повинно бути закрите. Закриття ресурсу звільняє всі системні засоби, які були виділені ресурсу, і робить його доступним для збору сміття (garbage collection). Якщо не закрити тіло відповіді, відбудеться витік ресурсів, що в кінцевому підсумку може призвести до уповільнення або краху додатку.  Для закриття ресурсу можна використовувати метод   close() , але переважніше використовувати блок   try-with-resources  (Java) та метод   use  (Kotlin). Обидві конструкції виконують блок коду відносно заданого ресурсу, а потім коректно закривають його, незалежно від того, викликано виключення чи ні.  Асинхронний запит (Java):     OkHttpClient   client   =   new   OkHttpClient  ();\n   \n   Request   request   =   new   Request.  Builder  ()\n           .  url  (  \"http://publicobject.com/helloworld.txt\"  )\n           .  build  ();\n   \n   client.  newCall  (request).  enqueue  (  new   Callback  () {\n       @  Override\n       public   void   onFailure  (  Call   call  ,   IOException   e  ) {\n           e.  printStackTrace  ();\n       }\n   \n       @  Override\n       public   void   onResponse  (  Call   call  ,   Response   response  )   throws   IOException   {\n           try   (  ResponseBody   responseBody   =   response.  body  ()) {\n               if   (  !  response.  isSuccessful  ()) {\n                   throw   new   IOException  (  \"Запит до сервера не був успішним: \"   +\n                           response.  code  ()   +   \" \"   +   response.  message  ());\n               }\n   \n               // приклад отримання всіх заголовків відповіді\n               Headers   responseHeaders   =   response.  headers  ();\n               for   (  int   i   =   0  , size   =   responseHeaders.  size  (); i   \u003C   size; i  ++  ) {\n                   // виведення заголовків\n                   System.out.  println  (responseHeaders.  name  (i)   +   \": \"\n                           +   responseHeaders.  value  (i));\n               }\n               // виведення тіла відповіді\n               System.out.  println  (responseBody.  string  ());\n           }\n       }\n   });\n  Асинхронний запит (Kotlin):     val   client   =   OkHttpClient  ()\n   \n   val   request   =   Request.  Builder  ()\n       .  url  (  \"http://publicobject.com/helloworld.txt\"  )\n       .  build  ()\n   \n   client.  newCall  (request).  enqueue  (  object   :   Callback   {\n       override   fun   onFailure  (call:   Call  , e:   IOException  ) {\n           e.  printStackTrace  ()\n       }\n   \n       override   fun   onResponse  (call:   Call  , response:   Response  ) {\n           response.  use   {\n               if   (  !  response.isSuccessful) {\n                   throw   IOException  (  \"Запит до сервера не був успішним:\"   +\n                           \"   ${  response.code  }   ${  response.message  }  \"  )\n               }\n               // приклад отримання всіх заголовків відповіді\n               for   ((name,   value  )   in   response.headers) {\n                   println  (  \"  $name  :   $value  \"  )\n               }\n               // виведення тіла відповіді\n               println  (response.body  !!  .  string  ())\n           }\n       }\n   })\n  Асинхронний запит виконується в потоці Worker. Коли відповідь доступна для читання, виконується зворотний виклик (callback). Цей виклик відбудеться після того, як будуть готові заголовки відповіді. Читання тіла відповіді все ще може блокувати потік. OkHttp наразі не пропонує асинхронних API для отримання тіла відповіді по частинах.  Callback має два абстрактні методи:    onResponse \nВикликається, коли HTTP-відповідь була успішно отримана від віддаленого сервера.   onFailure \nВикликається, коли запит не може бути виконаний через проблеми з підключенням, тайм-аут або його скасування. Оскільки в мережі може статися збої під час з'єднання з сервером, можливий випадок, коли віддалений сервер встигає прийняти запит до збою.  Серіалізація/десеріалізація  У цьому пункті коротко розглянуто серіалізацію та десеріалізацію об'єктів (їх перетворення в певну послідовність байтів, яку можна передати по мережі, і навпаки).  Для того, щоб перетворити об'єкт у рядок JSON або навпаки, можна скористатися бібліотеками Gson і/або Moshi.  Коротко, якщо вам потрібна проста у використанні бібліотека та широкий набір функцій, то вибирайте Gson. Якщо потрібна продуктивність та ефективне використання пам'яті, то найкращим вибором буде Moshi.  Розглянемо приклад серіалізації за допомогою Moshi (Java):     Moshi   moshi   =   new   Moshi.  Builder  ().  build  ();\n   // Створення адаптера\n   JsonAdapter  \u003C  SomeClass  > jsonAdapterRequest   =\n           moshi.  adapter  (SomeClass.class);\n   // Серіалізація, SomeClassInstance - екземпляр класу SomeClass\n   String   jsonRequest   =   jsonAdapterRequest.  toJson  (SomeClassInstance);\n  Те ж саме в Kotlin:     val   moshi   =   Moshi.  Builder  ()\n       .  add  (  KotlinJsonAdapterFactory  ()).  build  ()\n   // Створення адаптера\n   val   jsonAdapterRequest   =   moshi.  adapter  (SomeClass::  class  .java)\n   // Серіалізація, SomeClassInstance - екземпляр класу SomeClass\n   val   jsonRequest   =   jsonAdapterRequest.  toJson  (SomeClassInstance)\n  Для серіалізації необхідно створити об'єкт Moshi, адаптер і передати йому тип серіалізованого об'єкта. У цьому випадку це тип   Class .  Якщо потрібно серіалізувати складніший об'єкт, наприклад, колекцію, тип можна передати двома способами.   За допомогою методу   Types.newParameterizedType() , який створює новий параметризований тип.     JsonAdapter  \u003C  List  \u003C  SomeClass  >> jsonAdapterRequest   =   moshi.  adapter  (\n           Types.  newParameterizedType  (List.class, SomeClass.class)\n   );\n   За допомогою класу   TypeToken  бібліотеки Gson. Клас використовується для передачі інформації про типи під час виконання програми. Конструктор класу повертає представлений клас із заданого типу.     JsonAdapter  \u003C  List  \u003C  SomeClass  >>   jsonAdapterRequest   =\n           moshi.  adapter  (new   TypeToken  \u003C  List  \u003C  SomeClass  >>(){}.  getType  ());\n  Різниця між способами полягає в тому, що   TypeToken  є більш типобезпечним (typesafe), а   Types.newParameterizedType  більш ефективним.  Десеріалізація здійснюється аналогічним чином.   Java:     JsonAdapter  \u003C  SomeClass  > jsonAdapterResponse   =   \n           moshi.  adapter  (SomeClass.class);\n   // Десеріалізація\n   String   jsonResponse   =   jsonAdapterResponse.  fromJson  (receivedData);\n   Kotlin:     val   jsonAdapterResponse   =   moshi.  adapter  (SomeClass::  class  .java)\n   // Десеріалізація\n   val   jsonResponse   =   jsonAdapterResponse.  fromJson  (receivedData)\n  При серіалізації/десеріалізації Moshi може викликати різного роду виключення, наприклад, якщо десеріалізована строка не є рядком JSON або якщо строка не відповідає об'єкту, в який її намагаються перетворити.  Якщо серверна і клієнтська частини налаштовані правильно, то такого не повинно відбуватися. Однак все ж рекомендується обгортати операції Moshi в блок   try-catch .  Простий POST-запит  Щоб здійснити POST-запит, використовується метод   post()  класу   Request.Builder . Цей метод приймає   RequestBody , який додається до запиту.   POST-запит в Java:     MediaType   JSON   =   MediaType.  get  (  \"application/json; charset=utf-8\"  );\n   String   jsonRequest   =   \"Some request\"  ;\n   \n   OkHttpClient   client   =   new   OkHttpClient  ();\n   RequestBody   body   =   RequestBody.  create  (jsonRequest, JSON);\n   Request  .  Builder   requestBuilder   =   new   Request.  Builder  ().  url  (serverUrl).  post  (body);\n   Request   request   =   requestBuilder.  build  ();\n   \n   try   (  Response   response   =   client.  newCall  (request).  execute  ()) {\n       if   (  !  response.  isSuccessful  ()) {\n           throw   new   IOException  (  \"Запит до сервера не був успішним: \"   +\n                   response.  code  ()   +   \" \"   +   response.  message  ());\n       }\n       System.out.  println  (response.  body  ().  string  ());\n   }   catch   (  IOException   e  ) {\n       System.out.  println  (  \"Помилка підключення: \"   +   e);\n   }\n   POST-запит в Kotlin:     val   jsonRequest   =   \"some request\"\n   val   JSON   =   \"application/json; charset=utf-8\"  .  toMediaType  ()\n   \n   val   client   =   OkHttpClient  ()\n   val   body:   RequestBody   =   jsonRequest.  toRequestBody  (JSON)\n   val   request   =   Request.  Builder  ().  url  (serverUrl).  post  (body).  build  ()\n   \n   try   {\n       client.  newCall  (request).  execute  ().  use   { response   ->\n           if   (  !  response.isSuccessful) {\n               throw   IOException  (  \"Запит до сервера не був успішним:\"   +\n                       \"   ${  response.code  }   ${  response.message  }  \"  )\n           }\n           println  (response.body  !!  .  string  ())\n       }\n   }   catch   (e:   IOException  ) {\n       println  (  \"Помилка підключення:   $e  \"  )\n   }\n   Об'єкт   MediaType  необхідний для опису типу вмісту тіла запиту або відповіді. Зазвичай він використовується для встановлення заголовка \"Content-Type\" в HTTP-запиті.  Щоб отримати об'єкт   MediaType , можна використати один із статичних методів одноіменного класу:    MediaType.parse(String)  — створює новий екземпляр   MediaType  з вказаним типом вмісту та кодуванням. Функція повертає медіатип для рядка або   null , якщо рядок не є правильно сформованим медіатипом.   MediaType.get(String)  — працює аналогічно   MediaType.parse , але якщо рядок сформований неправильно, викликається виключення   IllegalArgumentException .  У Kotlin використовується метод   toMediaType()  об'єкта   String . Цей метод є аналогом   MediaType.get(String) .   RequestBody  — клас, який представляє тіло запиту. Екземпляр класу створюється за допомогою методу   create .   RequestBody.create(MediaType, String)  створює тіло запиту з вказаним вмістом та його типом. Метод має кілька реалізацій. Вміст можна передати у вигляді масиву байтів, файлу, рядка або об'єкта   okio.ByteString . Тип вмісту завжди вказується за допомогою об'єкта   MediaType . Цей об'єкт також встановлює заголовку \"Content-type\" відповідне значення, тому вручну встановлювати цей заголовок не потрібно.  Аналогом   RequestBody.create(MediaType, String)  в Kotlin є метод   toRequestBody(MediaType?)  об'єкта   String .  Особливості роботи з HTTPS  OkHttp намагається балансувати між двома задачами:    Підключення до максимально можливої кількості хостів . Сюди входять як сучасні хости, на яких використовуються останні версії boringssl, так і трохи застарілі хости, на яких використовуються старі версії OpenSSL.   Безпека з'єднання . Сюди входить перевірка віддаленого веб-сервера за допомогою сертифікатів і конфіденційність даних, що передаються за допомогою надійних шифрів.  При узгодженні з'єднання з HTTPS-сервером OkHttp повинен знати, які версії TLS і набори шифрів пропонувати. Для клієнта, який хоче максимізувати можливість підключення до різних серверів, це будуть застарілі версії TLS і слабкі за конструкцією набори шифрів. Для клієнта, який хоче максимізувати безпеку, це будуть тільки остання версія TLS і найсильніші набори шифрів.  Конкретні рішення по безпеці та з'єднанню реалізуються за допомогою   ConnectionSpec . OkHttp включає чотири вбудовані типи з'єднань:    RESTRICTED_TLS  - безпечна конфігурація, призначена для задоволення більш строгих вимог до відповідності.   MODERN_TLS  - безпечна конфігурація, що дозволяє підключатися до сучасних HTTPS-серверів.   COMPATIBLE_TLS  - безпечна конфігурація, яка підключається до безпечних, але менш сучасних серверів HTTPS.   CLEARTEXT  - небезпечна конфігурація, що використовується для URL-адресів http://.  За замовчуванням OkHttp буде намагатися встановити з'єднання   MODERN_TLS . Якщо з'єднання   MODERN_TLS  не вдасться, okhttp3 перемикнеться на інший тип з'єднання. Точний механізм відкату залежить від конкретної реалізації okhttp3 та конфігурації, встановленої розробниками.  Налаштувати конфігурацію можна наступним чином:     OkHttpClient   client   =   new   OkHttpClient.  Builder  ()\n       .  connectionSpecs  (Arrays.  asList  (\n           ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))\n       .  build  ()\n  В офіційній документації можна знайти додаткові способи роботи з HTTPS, такі як створення власної специфікації підключення, закріплення сертифіката та налаштування довірених сертифікатів.  Аутентифікація на сервері  Аутентифікацію на сервері можна реалізувати двома способами:    Вручну додати заголовок аутентифікації . Корисно, коли потрібна аутентифікація тільки для одного запиту. Для того, щоб додавати заголовок до всіх запитів клієнта, можна створити перехоплювач. Цей спосіб корисний, якщо у вас статичний ключ API або токен, який потрібно надсилати з кожним запитом.     val   client   =   OkHttpClient  ().  newBuilder  ().  addInterceptor   { chain   ->\n           val   originalRequest   =   chain.  request  ()\n   \n           val   builder   =   originalRequest.  newBuilder  ()\n                  .  header  (  \"Authorization\"  , Credentials.  basic  (  \"username\"  ,   \"password\"  ))\n           val   newRequest   =   builder.  build  ()\n           chain.  proceed  (newRequest)\n       }.  build  ()\n    Використовувати інтерфейс Authenticator  — корисно, коли необхідно динамічно аутентифікуватися або потрібна додаткова настройка процесу аутентифікації.  Інтерфейс дозволяє виконати або попередню аутентифікацію перед підключенням до сервера, або реактивну аутентифікацію після отримання відповіді від веб-сервера або проксі-сервера.  Розглянемо приклад реактивної аутентифікації. У такому випадку, якщо код стану відповіді рівний 401 (Unauthorized), OkHttp надсилає повторний запит, що містить заголовок \"Authorization\".  При цьому важливо зробити перевірку, чи була в початковому запиті спроба аутентифікації. Якщо так, то, ймовірно, подальші спроби будуть марними, і аутентифікатор має відмовитися від них.     OkHttpClient  .  Builder   client   =   new   OkHttpClient.  Builder  ();\n   client.  authenticator  ((route, response)   ->   {\n       if   (response.  request  ().  header  (  \"Authorization\"  )   !=   null  ) {\n           return   null  ;   // Зупинити спроби аутентифікації,\n           // оскільки у нас вже не вийшло це зробити\n       }\n       String   credential   =   Credentials.  basic  (  \"name\"  ,   \"password\"  );\n       return   response.  request  ().  newBuilder  ()\n               .  header  (  \"Authorization\"  , credential).  build  ();\n   });\n  Тут метод   authenticator  за допомогою лямбда-функції встановлює екземпляр інтерфейсу   Authenticator , який надає механізм для перевірки відповіді від сервера та повертає запит, що містить облікові дані клієнта. Метод   Credentials.basic  використовується для кодування імені користувача та пароля при базовій аутентифікації.  Приклад з ViewModel  MainViewModel.java     import   android.util.Log  ;\n   import   androidx.lifecycle.LiveData  ;\n   import   androidx.lifecycle.MutableLiveData  ;\n   import   androidx.lifecycle.ViewModel  ;\n   import   okhttp3.Call  ;\n   import   okhttp3.Callback  ;\n   import   okhttp3.OkHttpClient  ;\n   import   okhttp3.Request  ;\n   import   okhttp3.RequestBody  ;\n   import   okhttp3.Response  ;\n   \n   import   java.io.IOException  ;\n   \n   public   class   MainViewModel   extends   ViewModel   {\n   \n       private   static   final   String   TAG   =   \"MainViewModel\"  ;\n       private   static   final   String   BASE_URL   =   \"https://your-api-url.com\"  ;   // Замість цього вставте ваш URL\n       private   static   final   okhttp3  .  MediaType   JSON   =   okhttp3.MediaType.  parse  (  \"application/json; charset=utf-8\"  );\n   \n       private   final   MutableLiveData  \u003C  String  > _response   =   new   MutableLiveData  \u003C>();\n       public   LiveData  \u003C  String  > response   =   _response;\n   \n       private   final   OkHttpClient   client   =   new   OkHttpClient  ();\n   \n       public   void   getResponseFromServer  () {\n           String   jsonRequest   =   \"your request body\"  ;   // Тіло вашого запиту\n   \n           RequestBody   body   =   RequestBody.  create  (jsonRequest, JSON);\n           Request   request   =   new   Request.  Builder  ().  url  (BASE_URL).  post  (body).  build  ();\n   \n           client.  newCall  (request).  enqueue  (  new   Callback  () {\n               @  Override\n               public   void   onFailure  (  Call   call  ,   IOException   e  ) {\n                   Log.  d  (TAG,   \"Ошибка подключения: \"   +   e);\n               }\n   \n               @  Override\n               public   void   onResponse  (  Call   call  ,   Response   response  )   throws   IOException   {\n                   if   (  !  response.  isSuccessful  ()) {\n                       throw   new   IOException  (  \"Запрос к серверу не был успешен: \"   +\n                               response.  code  ()   +   \" \"   +   response.  message  ());\n                   }\n                   _response.  postValue  (response.  body  ().  string  ());\n               }\n           });\n       }\n   }\n  SomeApiService.java     import   okhttp3.Call  ;\n   import   okhttp3.Callback  ;\n   import   okhttp3.OkHttpClient  ;\n   import   okhttp3.Request  ;\n   import   okhttp3.RequestBody  ;\n   import   okhttp3.Response  ;\n   \n   import   java.io.IOException  ;\n   \n   public   class   SomeApiService   {\n   \n       private   static   final   String   BASE_URL   =   \"https://your-api-url.com\"  ;   // Замість цього вставте ваш URL\n       private   static   final   okhttp3  .  MediaType   JSON   =   okhttp3.MediaType.  parse  (  \"application/json; charset=utf-8\"  );\n   \n       private   final   OkHttpClient   client   =   new   OkHttpClient  ();\n   \n       public   interface   RequestCallback   {\n           void   onSuccess  (  String   response  );\n           void   onFailure  (  String   error  );\n       }\n   \n       public   void   makeRequest  (  final   RequestCallback   callback  ) {\n           String   jsonRequest   =   \"your request body\"  ;   // Тіло вашого запиту\n   \n           RequestBody   body   =   RequestBody.  create  (jsonRequest, JSON);\n           Request   request   =   new   Request.  Builder  ().  url  (BASE_URL).  post  (body).  build  ();\n   \n           client.  newCall  (request).  enqueue  (  new   Callback  () {\n               @  Override\n               public   void   onFailure  (  Call   call  ,   IOException   e  ) {\n                   callback.  onFailure  (e.  toString  ());\n               }\n   \n               @  Override\n               public   void   onResponse  (  Call   call  ,   Response   response  )   throws   IOException   {\n                   if   (  !  response.  isSuccessful  ()) {\n                       callback.  onFailure  (  \"Запрос к серверу не был успешен: \"   +\n                               response.  code  ()   +   \" \"   +   response.  message  ());\n                   }   else   {\n                       callback.  onSuccess  (response.  body  ().  string  ());\n                   }\n               }\n           });\n       }\n   }\n  SomeApi.java     public   class   SomeApi   {\n       public   static   final   SomeApiService   someService   =   new   SomeApiService  ();\n   }\n  MainViewModel.java (Оновлений для використання   SomeApi )     import   android.util.Log  ;\n   import   androidx.lifecycle.LiveData  ;\n   import   androidx.lifecycle.MutableLiveData  ;\n   import   androidx.lifecycle.ViewModel  ;\n   \n   public   class   MainViewModel   extends   ViewModel   {\n   \n       private   static   final   String   TAG   =   \"MainViewModel\"  ;\n   \n       private   final   MutableLiveData  \u003C  String  > _response   =   new   MutableLiveData  \u003C>();\n       public   LiveData  \u003C  String  > response   =   _response;\n   \n       public   void   getResponseFromApi  () {\n           SomeApi.someService.  makeRequest  (  new   SomeApiService.  RequestCallback  () {\n               @  Override\n               public   void   onSuccess  (  String   response) {\n                   _response.  postValue  (response);\n               }\n   \n               @  Override\n               public   void   onFailure  (  String   error) {\n                   Log.  d  (TAG,   \"Ошибка подключения: \"   +   error);\n               }\n           });\n       }\n   }\n  Висновок   OkHttp  - гнучка бібліотека, що виступає в ролі HTTP-клієнта.  На відміну від Retrofit налаштовувати клієнт, писати запити й обробляти відповіді необхідно вручну. Це одночасно і перевага, і недолік OkHttp. Недолік полягає в необхідності писати багато шаблонного коду. Перевага - можливість кастомізувати з'єднання.  Через слабку кастомізованість у деяких випадках Retrofit може не підійти, і без OkHttp не обійтися. Також завдяки кастомізації OkHttp можна підвищити продуктивність і зменшити використання пам'яті.  Приклад okHttp з MVVM  Цей приклад демонструє, як використовувати   MVVM ,   OkHttp ,   Moshi ,   ViewBinding  і   Android Data Binding  для отримання, додавання та видалення постів з   JSONPlaceholder .     dependencies {\n       // AndroidX (ViewBinding, DataBinding, RecyclerView)\n       implementation   'androidx.recyclerview:recyclerview:1.2.1'\n       implementation   'androidx.databinding:viewbinding:7.4.2'\n   \n       // Moshi (для парсингу JSON)\n       implementation   'com.squareup.moshi:moshi:1.13.0'\n       implementation   'com.squareup.moshi:moshi-kotlin:1.13.0'\n   \n       // OkHttp (для HTTP запитів)\n       implementation   'com.squareup.okhttp3:okhttp:4.10.0'\n   \n       // ViewModel & LiveData\n       implementation   'androidx.lifecycle:lifecycle-viewmodel-ktx:2.6.1'\n       implementation   'androidx.lifecycle:lifecycle-livedata-ktx:2.6.1'\n   \n       // AndroidX Lifecycle (для використання ViewModel)\n       implementation   'androidx.lifecycle:lifecycle-runtime-ktx:2.6.1'\n   }\n     android {\n       ...\n       viewBinding {\n           enabled   = true\n       }\n       dataBinding {\n           enabled   = true\n       }\n   }\n  1. Модель даних (Post.java)     import   com.squareup.moshi.Json  ;\n   \n   public   class   Post   {\n       @  Json  (  name   =   \"id\"  )\n       private   int   id;\n       @  Json  (  name   =   \"title\"  )\n       private   String   title;\n       @  Json  (  name   =   \"body\"  )\n       private   String   body;\n   \n       // Геттери та сеттери\n       public   int   getId  () {\n           return   id;\n       }\n   \n       public   void   setId  (  int   id  ) {\n           this  .id   =   id;\n       }\n   \n       public   String   getTitle  () {\n           return   title;\n       }\n   \n       public   void   setTitle  (  String   title  ) {\n           this  .title   =   title;\n       }\n   \n       public   String   getBody  () {\n           return   body;\n       }\n   \n       public   void   setBody  (  String   body  ) {\n           this  .body   =   body;\n       }\n   }\n  2. ViewModel (PostViewModel.java)     import   android.util.Log  ;\n   import   androidx.databinding.ObservableArrayList  ;\n   import   androidx.lifecycle.ViewModel  ;\n   import   okhttp3.Call  ;\n   import   okhttp3.Callback  ;\n   import   okhttp3.OkHttpClient  ;\n   import   okhttp3.Request  ;\n   import   okhttp3.Response  ;\n   import   com.squareup.moshi.Moshi  ;\n   import   com.squareup.moshi.Types  ;\n   import   java.io.IOException  ;\n   import   java.util.List  ;\n   \n   public   class   PostViewModel   extends   ViewModel   {\n   \n       private   static   final   String   TAG   =   \"PostViewModel\"  ;\n       private   static   final   String   BASE_URL   =   \"https://jsonplaceholder.typicode.com/posts\"  ;\n       private   static   final   String   ADD_URL   =   \"https://jsonplaceholder.typicode.com/posts\"  ;\n       private   final   ObservableArrayList  \u003C  Post  > posts   =   new   ObservableArrayList  \u003C>();\n       private   final   OkHttpClient   client   =   new   OkHttpClient  ();\n       private   final   Moshi   moshi   =   new   Moshi.  Builder  ().  build  ();\n       private   final   Types   type   =   Types.  newParameterizedType  (List.class, Post.class);\n   \n       // Метод для завантаження постів\n       public   ObservableArrayList  \u003C  Post  >   getPosts  () {\n           loadPosts  ();\n           return   posts;\n       }\n   \n       private   void   loadPosts  () {\n           Request   request   =   new   Request.  Builder  ().  url  (BASE_URL).  build  ();\n   \n           client.  newCall  (request).  enqueue  (  new   Callback  () {\n               @  Override\n               public   void   onFailure  (  Call   call  ,   IOException   e  ) {\n                   Log.  e  (TAG,   \"Error fetching posts: \"  , e);\n               }\n   \n               @  Override\n               public   void   onResponse  (  Call   call  ,   Response   response  )   throws   IOException   {\n                   if   (  !  response.  isSuccessful  ()) {\n                       Log.  e  (TAG,   \"Request failed with code: \"   +   response.  code  ());\n                       return  ;\n                   }\n   \n                   String   jsonResponse   =   response.  body  ().  string  ();\n                   List  \u003C  Post  > postList   =   moshi.  adapter  (type).  fromJson  (jsonResponse);\n                   if   (postList   !=   null  ) {\n                       posts.  clear  ();\n                       posts.  addAll  (postList);    // Оновлюємо ObservableArrayList\n                   }\n               }\n           });\n       }\n   \n       // Метод для додавання нового поста\n       public   void   addPost  (  Post   newPost  ) {\n           Request   request   =   new   Request.  Builder  ()\n                   .  url  (ADD_URL)\n                   .  post  (okhttp3.RequestBody.  create  (\n                           moshi.  adapter  (Post.class).  toJson  (newPost).  getBytes  ()))\n                   .  build  ();\n   \n           client.  newCall  (request).  enqueue  (  new   Callback  () {\n               @  Override\n               public   void   onFailure  (  Call   call  ,   IOException   e  ) {\n                   Log.  e  (TAG,   \"Error adding post: \"  , e);\n               }\n   \n               @  Override\n               public   void   onResponse  (  Call   call  ,   Response   response  )   throws   IOException   {\n                   if   (  !  response.  isSuccessful  ()) {\n                       Log.  e  (TAG,   \"Request failed with code: \"   +   response.  code  ());\n                       return  ;\n                   }\n   \n                   // Додано новий пост\n                   posts.  add  (newPost);\n               }\n           });\n       }\n   \n       // Метод для видалення поста\n       public   void   deletePost  (  Post   post  ) {\n           Request   request   =   new   Request.  Builder  ()\n                   .  url  (BASE_URL   +   \"/\"   +   post.  getId  ())\n                   .  delete  ()\n                   .  build  ();\n   \n           client.  newCall  (request).  enqueue  (  new   Callback  () {\n               @  Override\n               public   void   onFailure  (  Call   call  ,   IOException   e  ) {\n                   Log.  e  (TAG,   \"Error deleting post: \"  , e);\n               }\n   \n               @  Override\n               public   void   onResponse  (  Call   call  ,   Response   response  )   throws   IOException   {\n                   if   (  !  response.  isSuccessful  ()) {\n                       Log.  e  (TAG,   \"Request failed with code: \"   +   response.  code  ());\n                       return  ;\n                   }\n   \n                   // Видалено пост\n                   posts.  remove  (post);\n               }\n           });\n       }\n   }\n  3. Activity (MainActivity.java)     import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.Toast  ;\n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   androidx.lifecycle.ViewModelProvider  ;\n   import   androidx.recyclerview.widget.LinearLayoutManager  ;\n   import   androidx.recyclerview.widget.RecyclerView  ;\n   import   com.example.mvvmexample.databinding.ActivityMainBinding  ;\n   import   androidx.databinding.DataBindingUtil  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       private   PostViewModel   postViewModel;\n       private   PostAdapter   postAdapter;\n       private   ActivityMainBinding   binding;\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           binding   =   DataBindingUtil.  setContentView  (  this  , R.layout.activity_main);\n   \n           postViewModel   =   new   ViewModelProvider  (  this  ).  get  (PostViewModel.class);\n   \n           postAdapter   =   new   PostAdapter  (postViewModel);\n           binding.recyclerView.  setLayoutManager  (  new   LinearLayoutManager  (  this  ));\n           binding.recyclerView.  setAdapter  (postAdapter);\n   \n           // Спостерігаємо за ObservableArrayList\n           postViewModel.  getPosts  ().  addOnListChangedCallback  (  new   ObservableArrayList  .  OnListChangedCallback  \u003C  ObservableArrayList  \u003C  Post  >>() {\n               @  Override\n               public   void   onChanged  (  ObservableArrayList  \u003C  Post  >   sender  ) {\n                   postAdapter.  notifyDataSetChanged  ();\n               }\n   \n               @  Override\n               public   void   onItemRangeChanged  (  ObservableArrayList  \u003C  Post  >   sender  ,   int   positionStart  ,   int   itemCount  ) {\n                   postAdapter.  notifyItemRangeChanged  (positionStart, itemCount);\n               }\n   \n               @  Override\n               public   void   onItemRangeInserted  (  ObservableArrayList  \u003C  Post  >   sender  ,   int   positionStart  ,   int   itemCount  ) {\n                   postAdapter.  notifyItemRangeInserted  (positionStart, itemCount);\n               }\n   \n               @  Override\n               public   void   onItemRangeMoved  (  ObservableArrayList  \u003C  Post  >   sender  ,   int   fromPosition  ,   int   toPosition  ,   int   itemCount  ) {\n               }\n   \n               @  Override\n               public   void   onItemRangeRemoved  (  ObservableArrayList  \u003C  Post  >   sender  ,   int   positionStart  ,   int   itemCount  ) {\n                   postAdapter.  notifyItemRangeRemoved  (positionStart, itemCount);\n               }\n           });\n   \n           // Завантажуємо пости при запуску\n           postViewModel.  getPosts  ();\n   \n           binding.addPostButton.  setOnClickListener  (v   ->   {\n               Post   newPost   =   new   Post  ();\n               newPost.  setTitle  (  \"New Post\"  );\n               newPost.  setBody  (  \"This is a new post\"  );\n               postViewModel.  addPost  (newPost);\n           });\n       }\n   }\n  4. Адаптер для RecyclerView (PostAdapter.java)     import   android.view.LayoutInflater  ;\n   import   android.view.View  ;\n   import   android.view.ViewGroup  ;\n   import   androidx.databinding.DataBindingUtil  ;\n   import   androidx.recyclerview.widget.RecyclerView  ;\n   import   com.example.mvvmexample.R  ;\n   import   com.example.mvvmexample.databinding.ItemPostBinding  ;\n   \n   public   class   PostAdapter   extends   RecyclerView.Adapter  \u003C  PostAdapter  .  PostViewHolder  > {\n   \n       private   final   PostViewModel   postViewModel;\n   \n       public   PostAdapter  (  PostViewModel   postViewModel  ) {\n           this  .postViewModel   =   postViewModel;\n       }\n   \n       @  Override\n       public   PostViewHolder   onCreateViewHolder  (  ViewGroup   parent  ,   int   viewType  ) {\n           ItemPostBinding   binding   =   DataBindingUtil.  inflate  (\n                   LayoutInflater.  from  (parent.  getContext  ()),\n                   R.layout.item_post, parent,   false  );\n           return   new   PostViewHolder  (binding);\n       }\n   \n       @  Override\n       public   void   onBindViewHolder  (  PostViewHolder   holder  ,   int   position  ) {\n           Post   post   =   postViewModel.  getPosts  ().  get  (position);\n           holder.  bind  (post);\n       }\n   \n       @  Override\n       public   int   getItemCount  () {\n           return   postViewModel.  getPosts  ().  size  ();\n       }\n   \n       public   static   class   PostViewHolder   extends   RecyclerView.ViewHolder   {\n   \n           private   final   ItemPostBinding   binding;\n   \n           public   PostViewHolder  (  ItemPostBinding   binding  ) {\n               super  (binding.  getRoot  ());\n               this  .binding   =   binding;\n           }\n   \n           public   void   bind  (  Post   post  ) {\n               binding.  setPost  (post);\n               binding.  setViewModel  (postViewModel);\n               binding.  executePendingBindings  ();\n           }\n       }\n   }\n  5. Layout для Activity (activity_main.xml)     \u003C  layout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools  =  \"http://schemas.android.com/tools\"  >\n   \n       \u003C  LinearLayout\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"match_parent\"\n           android:orientation  =  \"vertical\"  >\n   \n           \u003C  androidx.recyclerview.widget.RecyclerView\n               android:id  =  \"@+id/recyclerView\"\n               android:layout_width  =  \"match_parent\"\n               android:layout_height  =  \"0dp\"\n               android:layout_weight  =  \"1\"   />\n   \n           \u003C  Button\n               android:id  =  \"@+id/addPostButton\"\n               android:layout_width  =  \"match_parent\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"Add Post\"   />\n       \u003C/  LinearLayout  >\n   \u003C/  layout  >\n  6. Layout для елемента списку (item_post.xml)     \u003C  layout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"  >\n   \n       \u003C  LinearLayout\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"wrap_content\"\n           android:orientation  =  \"vertical\"  >\n   \n           \u003C  TextView\n               android:id  =  \"@+id/title\"\n               android:layout_width  =  \"match_parent\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"@{post.title}\"   />\n   \n           \u003C  TextView\n               android:id  =  \"@+id/body\"\n               android:layout_width  =  \"match_parent\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"@{post.body}\"   />\n   \n           \u003C  Button\n               android:id  =  \"@+id/deleteButton\"\n               android:layout_width  =  \"match_parent\"\n               android:layout_height  =  \"wrap_content\"\n               android:text  =  \"Delete\"\n               android:onClick  =  \"@{() -> viewModel.deletePost(post)}\"   />\n       \u003C/  LinearLayout  >\n   \u003C/  layout  >\n  Цей код включає:   Заміна на    ObservableArrayList  для підтримки спостереження за змінами.  Використання   Moshi  для парсингу JSON.  Використання   ViewBinding  для доступу до елементів інтерфейсу.  Додавання нових постів через OkHttp.  Видалення постів через OkHttp.  Використання   Android Data Binding  для прив'язки даних.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":728,"path":729,"dir":667,"title":730,"description":731,"keywords":732,"body":737},"content:1.android:5.lesson5:5.retrofit.md","/android/lesson5/retrofit","Retrofit","Retrofit — це потужна бібліотека для Android і Java, яка спрощує взаємодію з REST API. Вона дозволяє вам легко працювати з HTTP-запитами, абстрагуючи низькорівневі деталі. Retrofit підтримує автоматичне перетворення JSON у Java-об'єкти за допомогою таких бібліотек, як Moshi, Gson або Jackson.",[733,734,735,736],"Залежності для Retrofit","Налаштування Retrofit","Використання Retrofit для CRUD-операцій з JsonPlaceholder","Структура проекту","  Retrofit   Retrofit  — це потужна бібліотека для Android і Java, яка спрощує взаємодію з REST API. Вона дозволяє вам легко працювати з HTTP-запитами, абстрагуючи низькорівневі деталі. Retrofit підтримує автоматичне перетворення JSON у Java-об'єкти за допомогою таких бібліотек, як   Moshi ,   Gson  або   Jackson .  У цій статті ми розглянемо основи використання Retrofit у Java, найкращі практики та кроки для налаштування і створення запитів до REST API.  Залежності для Retrofit  Перед тим як почати, потрібно додати необхідні залежності у вашому проекті.  1. Додавання залежностей до   build.gradle  У вашому файлі   build.gradle  додайте наступні залежності:     dependencies {\n       implementation   'com.squareup.retrofit2:retrofit:2.9.0'   // Основна бібліотека Retrofit\n       implementation   'com.squareup.retrofit2:converter-gson:2.9.0'   // Конвертер для Gson\n       implementation   'com.squareup.okhttp3:okhttp:4.9.0'   // OkHttp для роботи з HTTP\n       implementation   'com.squareup.moshi:moshi:1.12.0'   // Можна використовувати Moshi для серіалізації\n   }\n  Налаштування Retrofit  1. Створення інтерфейсу API  Перше, що потрібно зробити, це визначити інтерфейс, який буде описувати ваші HTTP-запити. Для кожного ендпоінта API ви створюєте відповідний метод, який позначається за допомогою анотацій, таких як   @GET ,   @POST ,   @PUT  тощо.  Ось приклад:     import   retrofit2.Call  ;\n   import   retrofit2.http.GET  ;\n   import   retrofit2.http.Query  ;\n   \n   public   interface   ApiService   {\n       @  GET  (  \"posts\"  )\n       Call  \u003C  List  \u003C  Post  >>   getPosts  ();\n   \n       @  GET  (  \"posts\"  )\n       Call  \u003C  List  \u003C  Post  >>   getPostsByUserId  (@  Query  (  \"userId\"  )   int   userId  );\n   }\n  2. Створення Retrofit об'єкта  Далі необхідно налаштувати Retrofit, вказавши базовий URL для вашого API та конвертер для обробки JSON. Використаємо Gson для конвертації JSON у Java-об'єкти:     import   retrofit2.Retrofit  ;\n   import   retrofit2.converter.gson.GsonConverterFactory  ;\n   \n   public   class   RetrofitClient   {\n       private   static   Retrofit   retrofit;\n   \n       public   static   Retrofit   getClient  () {\n           if   (retrofit   ==   null  ) {\n               retrofit   =   new   Retrofit.  Builder  ()\n                       .  baseUrl  (  \"https://jsonplaceholder.typicode.com/\"  )   // Базовий URL API\n                       .  addConverterFactory  (GsonConverterFactory.  create  ())   // Додаємо конвертер Gson\n                       .  build  ();\n           }\n           return   retrofit;\n       }\n   }\n  3. Використання Retrofit для виконання запитів  Тепер ми можемо використовувати Retrofit для виконання запитів до API. Ось приклад того, як отримати список постів:     import   retrofit2.Call  ;\n   import   retrofit2.Callback  ;\n   import   retrofit2.Response  ;\n   \n   public   class   Main   {\n       public   static   void   main  (  String  []   args  ) {\n           // Отримуємо інтерфейс API\n           ApiService   apiService   =   RetrofitClient.  getClient  ().  create  (ApiService.class);\n   \n           // Виконуємо асинхронний запит для отримання постів\n           Call  \u003C  List  \u003C  Post  >> call   =   apiService.  getPosts  ();\n           call.  enqueue  (  new   Callback  \u003C  List  \u003C  Post  >>() {\n               @  Override\n               public   void   onResponse  (  Call  \u003C  List  \u003C  Post  >>   call  ,   Response  \u003C  List  \u003C  Post  >>   response  ) {\n                   if   (response.  isSuccessful  ()) {\n                       List  \u003C  Post  > posts   =   response.  body  ();\n                       // Обробляємо список постів\n                       for   (  Post   post   :   posts) {\n                           System.out.  println  (post.  getTitle  ());\n                       }\n                   }   else   {\n                       System.out.  println  (  \"Запит не був успішним\"  );\n                   }\n               }\n   \n               @  Override\n               public   void   onFailure  (  Call  \u003C  List  \u003C  Post  >>   call  ,   Throwable   t  ) {\n                   t.  printStackTrace  ();\n               }\n           });\n       }\n   }\n  4. Синхронний запит  Якщо вам потрібно виконати запит синхронно (наприклад, в фоновому потоці), ви можете викликати метод   execute() :     try   {\n       Response  \u003C  List  \u003C  Post  >> response   =   call.  execute  ();\n       if   (response.  isSuccessful  ()) {\n           List  \u003C  Post  > posts   =   response.  body  ();\n           for   (  Post   post   :   posts) {\n               System.out.  println  (post.  getTitle  ());\n           }\n       }   else   {\n           System.out.  println  (  \"Запит не був успішним\"  );\n       }\n   }   catch   (  IOException   e  ) {\n       e.  printStackTrace  ();\n   }\n  5. Моделювання відповіді  Ваші відповіді від API можуть бути різними. У Retrofit для обробки відповіді використовується Java-класи. Наприклад, для API   https://jsonplaceholder.typicode.com/posts  ви можете створити клас   Post :     public   class   Post   {\n       private   int   userId;\n       private   int   id;\n       private   String   title;\n       private   String   body;\n   \n       // Гетери та сетери\n       public   int   getUserId  () {\n           return   userId;\n       }\n   \n       public   void   setUserId  (  int   userId  ) {\n           this  .userId   =   userId;\n       }\n   \n       public   int   getId  () {\n           return   id;\n       }\n   \n       public   void   setId  (  int   id  ) {\n           this  .id   =   id;\n       }\n   \n       public   String   getTitle  () {\n           return   title;\n       }\n   \n       public   void   setTitle  (  String   title  ) {\n           this  .title   =   title;\n       }\n   \n       public   String   getBody  () {\n           return   body;\n       }\n   \n       public   void   setBody  (  String   body  ) {\n           this  .body   =   body;\n       }\n   }\n  Використання Retrofit для CRUD-операцій з JsonPlaceholder  Додаємо необхідні залежності в ваш файл   build.gradle :     dependencies {\n       implementation   'com.squareup.retrofit2:retrofit:2.9.0'   // Основна бібліотека Retrofit\n       implementation   'com.squareup.retrofit2:converter-gson:2.9.0'   // Конвертер для Gson\n       implementation   'com.squareup.okhttp3:okhttp:4.9.0'   // OkHttp для роботи з HTTP\n       implementation   'com.squareup.moshi:moshi:1.12.0'   // Moshi для серіалізації (опційно)\n   }\n  Структура проекту    Моделі  — клас, який описує структуру поста.   API інтерфейс  — визначення HTTP-запитів.   Реалізація Retrofit  — налаштування Retrofit.   Діяльність або ViewModel  — обробка запитів і відповіді.  1. Створення моделі даних (Post.java)  Ми створимо клас   Post , що відображає дані поста.     public   class   Post   {\n       private   int   userId;\n       private   int   id;\n       private   String   title;\n       private   String   body;\n   \n       // Гетери та сетери\n       public   int   getUserId  () {\n           return   userId;\n       }\n   \n       public   void   setUserId  (  int   userId  ) {\n           this  .userId   =   userId;\n       }\n   \n       public   int   getId  () {\n           return   id;\n       }\n   \n       public   void   setId  (  int   id  ) {\n           this  .id   =   id;\n       }\n   \n       public   String   getTitle  () {\n           return   title;\n       }\n   \n       public   void   setTitle  (  String   title  ) {\n           this  .title   =   title;\n       }\n   \n       public   String   getBody  () {\n           return   body;\n       }\n   \n       public   void   setBody  (  String   body  ) {\n           this  .body   =   body;\n       }\n   }\n  2. Створення інтерфейсу API (ApiService.java)  Визначаємо інтерфейс для всіх CRUD-операцій:     import   retrofit2.Call  ;\n   import   retrofit2.http.Body  ;\n   import   retrofit2.http.DELETE  ;\n   import   retrofit2.http.GET  ;\n   import   retrofit2.http.PUT  ;\n   import   retrofit2.http.POST  ;\n   import   retrofit2.http.Path  ;\n   \n   import   java.util.List  ;\n   \n   public   interface   ApiService   {\n   \n       // Отримати список всіх постів\n       @  GET  (  \"posts\"  )\n       Call  \u003C  List  \u003C  Post  >>   getPosts  ();\n   \n       // Отримати пост за ID\n       @  GET  (  \"posts/{id}\"  )\n       Call  \u003C  Post  >   getPostById  (@  Path  (  \"id\"  )   int   id  );\n   \n       // Створити новий пост\n       @  POST  (  \"posts\"  )\n       Call  \u003C  Post  >   createPost  (@  Body   Post   post  );\n   \n       // Оновити існуючий пост\n       @  PUT  (  \"posts/{id}\"  )\n       Call  \u003C  Post  >   updatePost  (@  Path  (  \"id\"  )   int   id  , @  Body   Post   post  );\n   \n       // Видалити пост\n       @  DELETE  (  \"posts/{id}\"  )\n       Call  \u003C  Void  >   deletePost  (@  Path  (  \"id\"  )   int   id  );\n   }\n  3. Налаштування Retrofit (RetrofitClient.java)  Тепер налаштовуємо Retrofit:     import   retrofit2.Retrofit  ;\n   import   retrofit2.converter.gson.GsonConverterFactory  ;\n   \n   public   class   RetrofitClient   {\n       private   static   Retrofit   retrofit;\n       private   static   final   String   BASE_URL   =   \"https://jsonplaceholder.typicode.com/\"  ;\n   \n       public   static   Retrofit   getClient  () {\n           if   (retrofit   ==   null  ) {\n               retrofit   =   new   Retrofit.  Builder  ()\n                       .  baseUrl  (BASE_URL)\n                       .  addConverterFactory  (GsonConverterFactory.  create  ())   // Використовуємо Gson для конвертації\n                       .  build  ();\n           }\n           return   retrofit;\n       }\n   }\n  4. Створення класу для роботи з API (Main.java)  Давайте створимо клас, який буде використовувати інтерфейс   ApiService  для виконання CRUD-операцій:     import   retrofit2.Call  ;\n   import   retrofit2.Callback  ;\n   import   retrofit2.Response  ;\n   \n   import   java.io.IOException  ;\n   import   java.util.List  ;\n   \n   public   class   Main   {\n   \n       public   static   void   main  (  String  []   args  ) {\n           ApiService   apiService   =   RetrofitClient.  getClient  ().  create  (ApiService.class);\n   \n           // Операція GET: отримати всі пости\n           getAllPosts  (apiService);\n   \n           // Операція GET: отримати пост за ID\n           getPostById  (apiService,   1  );\n   \n           // Операція POST: створити новий пост\n           createPost  (apiService);\n   \n           // Операція PUT: оновити пост\n           updatePost  (apiService,   1  );\n   \n           // Операція DELETE: видалити пост\n           deletePost  (apiService,   1  );\n       }\n   \n       // Отримати всі пости\n       private   static   void   getAllPosts  (  ApiService   apiService  ) {\n           Call  \u003C  List  \u003C  Post  >> call   =   apiService.  getPosts  ();\n           call.  enqueue  (  new   Callback  \u003C  List  \u003C  Post  >>() {\n               @  Override\n               public   void   onResponse  (  Call  \u003C  List  \u003C  Post  >>   call  ,   Response  \u003C  List  \u003C  Post  >>   response  ) {\n                   if   (response.  isSuccessful  ()) {\n                       List  \u003C  Post  > posts   =   response.  body  ();\n                       posts.  forEach  (post   ->   System.out.  println  (post.  getTitle  ()));\n                   }   else   {\n                       System.out.  println  (  \"Запит не успішний!\"  );\n                   }\n               }\n   \n               @  Override\n               public   void   onFailure  (  Call  \u003C  List  \u003C  Post  >>   call  ,   Throwable   t  ) {\n                   t.  printStackTrace  ();\n               }\n           });\n       }\n   \n       // Отримати пост за ID\n       private   static   void   getPostById  (  ApiService   apiService  ,   int   postId  ) {\n           Call  \u003C  Post  > call   =   apiService.  getPostById  (postId);\n           call.  enqueue  (  new   Callback  \u003C  Post  >() {\n               @  Override\n               public   void   onResponse  (  Call  \u003C  Post  >   call  ,   Response  \u003C  Post  >   response  ) {\n                   if   (response.  isSuccessful  ()) {\n                       Post   post   =   response.  body  ();\n                       System.out.  println  (  \"Post Title: \"   +   post.  getTitle  ());\n                   }   else   {\n                       System.out.  println  (  \"Запит не успішний!\"  );\n                   }\n               }\n   \n               @  Override\n               public   void   onFailure  (  Call  \u003C  Post  >   call  ,   Throwable   t  ) {\n                   t.  printStackTrace  ();\n               }\n           });\n       }\n   \n       // Створити новий пост\n       private   static   void   createPost  (  ApiService   apiService  ) {\n           Post   post   =   new   Post  ();\n           post.  setUserId  (  1  );\n           post.  setTitle  (  \"New Post Title\"  );\n           post.  setBody  (  \"This is the body of the new post.\"  );\n   \n           Call  \u003C  Post  > call   =   apiService.  createPost  (post);\n           call.  enqueue  (  new   Callback  \u003C  Post  >() {\n               @  Override\n               public   void   onResponse  (  Call  \u003C  Post  >   call  ,   Response  \u003C  Post  >   response  ) {\n                   if   (response.  isSuccessful  ()) {\n                       Post   createdPost   =   response.  body  ();\n                       System.out.  println  (  \"Created Post: \"   +   createdPost.  getTitle  ());\n                   }   else   {\n                       System.out.  println  (  \"Запит не успішний!\"  );\n                   }\n               }\n   \n               @  Override\n               public   void   onFailure  (  Call  \u003C  Post  >   call  ,   Throwable   t  ) {\n                   t.  printStackTrace  ();\n               }\n           });\n       }\n   \n       // Оновити пост\n       private   static   void   updatePost  (  ApiService   apiService  ,   int   postId  ) {\n           Post   post   =   new   Post  ();\n           post.  setTitle  (  \"Updated Post Title\"  );\n           post.  setBody  (  \"This is the updated body.\"  );\n   \n           Call  \u003C  Post  > call   =   apiService.  updatePost  (postId, post);\n           call.  enqueue  (  new   Callback  \u003C  Post  >() {\n               @  Override\n               public   void   onResponse  (  Call  \u003C  Post  >   call  ,   Response  \u003C  Post  >   response  ) {\n                   if   (response.  isSuccessful  ()) {\n                       Post   updatedPost   =   response.  body  ();\n                       System.out.  println  (  \"Updated Post: \"   +   updatedPost.  getTitle  ());\n                   }   else   {\n                       System.out.  println  (  \"Запит не успішний!\"  );\n                   }\n               }\n   \n               @  Override\n               public   void   onFailure  (  Call  \u003C  Post  >   call  ,   Throwable   t  ) {\n                   t.  printStackTrace  ();\n               }\n           });\n       }\n   \n       // Видалити пост\n       private   static   void   deletePost  (  ApiService   apiService  ,   int   postId  ) {\n           Call  \u003C  Void  > call   =   apiService.  deletePost  (postId);\n           call.  enqueue  (  new   Callback  \u003C  Void  >() {\n               @  Override\n               public   void   onResponse  (  Call  \u003C  Void  >   call  ,   Response  \u003C  Void  >   response  ) {\n                   if   (response.  isSuccessful  ()) {\n                       System.out.  println  (  \"Post deleted successfully\"  );\n                   }   else   {\n                       System.out.  println  (  \"Запит не успішний!\"  );\n                   }\n               }\n   \n               @  Override\n               public   void   onFailure  (  Call  \u003C  Void  >   call  ,   Throwable   t  ) {\n                   t.  printStackTrace  ();\n               }\n           });\n       }\n   }\n    :video-player{src=\"https://www.youtube.com/watch?v=GPP4hOTthRg\"}\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":739,"path":740,"dir":667,"title":741,"description":742,"keywords":743,"body":748},"content:1.android:5.lesson5:6.working-with-video.md","/android/lesson5/working-with-video","Робота з відео","У стандартному наборі віджетів Android визначений клас VideoView, який дозволяє відтворювати відео.",[744,745,746,747],"Які типи відеофайлів можна використовувати?","Використання локального відео","MediaController","Відтворення файлу з інтернету","  Робота з відео  У стандартному наборі віджетів Android визначений клас   VideoView , який дозволяє відтворювати відео.  Які типи відеофайлів можна використовувати?  Android підтримує більшість поширених типів відеофайлів, зокрема:    3GPP  (.3gp)   WebM  (.webm)   Matroska  (.mkv)   MPEG-4  (.mp4)   VideoView  може працювати як із відеороликами, розміщеними на мобільному пристрої, так і з відеоматеріалами із мережі.  Використання локального відео  У даному прикладі використовується відеоролик, розміщений локально. Для цього додаємо відеофайл до проєкту.  Додавання відеофайлу до проєкту  Зазвичай відеоматеріали розміщують у папці   res/raw . За замовчуванням проєкт не містить такої папки, тому її потрібно створити.   Натисніть на папку   res  правою кнопкою миші.  У контекстному меню виберіть   New -> Android Resource Directory .    Потім у вікні, що з'явилося, як тип папки вкажемо   raw  (що також буде використовуватися як назва папки):    Після додавання папки   raw  скопіюємо в неї який-небудь відеофайл:    Тепер визначимо функціонал для його відтворення. Для цього у файлі   activity_main.xml  вкажемо такий код:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  Button\n           android:id  =  \"@+id/playButton\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Play\"\n           android:onClick  =  \"play\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/videoPlayer\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toLeftOf  =  \"@id/pauseButton\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n       \u003C  Button\n           android:id  =  \"@+id/pauseButton\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Pause\"\n           android:onClick  =  \"pause\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/videoPlayer\"\n           app:layout_constraintLeft_toRightOf  =  \"@id/playButton\"\n           app:layout_constraintRight_toLeftOf  =  \"@id/stopButton\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  />\n       \u003C  Button\n           android:id  =  \"@+id/stopButton\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Stop\"\n           android:onClick  =  \"stop\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/videoPlayer\"\n           app:layout_constraintLeft_toRightOf  =  \"@id/pauseButton\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n       \u003C  VideoView   android:id  =  \"@+id/videoPlayer\"\n           android:layout_height  =  \"0dp\"\n           android:layout_width  =  \"0dp\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/playButton\"  />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Для управління відтворенням відео тут визначено три кнопки: для запуску відео, для паузи та для його зупинки.  І також змінимо код   MainActivity :     package   com.example.mediaapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.net.Uri  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.VideoView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       VideoView   videoPlayer;\n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           videoPlayer   =   findViewById  (R.id.videoPlayer);\n           Uri   myVideoUri  =   Uri.  parse  (   \"android.resource://\"   +   getPackageName  ()   +   \"/\"   +   R.raw.cats);\n           videoPlayer.  setVideoURI  (myVideoUri);\n       }\n    \n       public   void   play  (  View   view  ){\n           videoPlayer.  start  ();\n       }\n       public   void   pause  (  View   view  ){\n           videoPlayer.  pause  ();\n       }\n       public   void   stop  (  View   view  ){\n           videoPlayer.  stopPlayback  ();\n           videoPlayer.  resume  ();\n       }\n   }\n  По-перше, щоб керувати потоком відтворення, нам потрібно отримати об'єкт VideoView:   videoPlayer = findViewById(R.id.videoPlayer);  Щоб вказати джерело відтворення, необхідний об'єкт Uri. У цьому випадку за допомогою виразу   Uri myVideoUri = Uri.parse(\"android.resource://\" + getPackageName() + \"/\" + R.raw.cats);  \nотримуємо адресу відеоролика всередині пакета застосунку.  Рядок URI має кілька частин: спочатку йде Uri-схема (  http://  або, як тут,   android.resource:// ), потім назва пакета, отримана через метод   getPackageName() , і далі безпосередньо назва ресурсу відео з папки   res/raw , що збігається з назвою файлу.  Потім цей Uri встановлюється у   videoPlayer :   videoPlayer.setVideoURI(myVideoUri);  Щоб керувати відеопотоком, обробники натискання кнопок викликають відповідну дію:     public   void   play  (  View   view){\n       videoPlayer.  start  ();\n   }\n   public   void   pause  (  View   view){\n       videoPlayer.  pause  ();\n   }\n   public   void   stop  (  View   view){\n       videoPlayer.  stopPlayback  ();\n       videoPlayer.  resume  ();\n   }\n   Метод   videoPlayer.start()  починає або продовжує відтворення.  Метод   videoPlayer.pause()  призупиняє відео.  Метод   videoPlayer.stopPlayback()  повністю зупиняє відео.  Метод   videoPlayer.resume()  дозволяє знову розпочати відтворення відео з початку після його повної зупинки.    MediaController  За допомогою класу   MediaController  ми можемо додати до   VideoView  додатково елементи керування. Для цього змінимо код   MainActivity :     package   com.example.mediaapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.net.Uri  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.VideoView  ;\n   import   android.widget.MediaController  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       VideoView   videoPlayer;\n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           videoPlayer   =   findViewById  (R.id.videoPlayer);\n           Uri   myVideoUri  =   Uri.  parse  (   \"android.resource://\"   +   getPackageName  ()   +   \"/\"   +   R.raw.cats);\n           videoPlayer.  setVideoURI  (myVideoUri);\n           MediaController   mediaController   =   new   MediaController  (  this  );\n           videoPlayer.  setMediaController  (mediaController);\n           mediaController.  setMediaPlayer  (videoPlayer);\n       }\n    \n       public   void   play  (  View   view  ){\n           videoPlayer.  start  ();\n       }\n       public   void   pause  (  View   view  ){\n           videoPlayer.  pause  ();\n       }\n       public   void   stop  (  View   view  ){\n           videoPlayer.  stopPlayback  ();\n           videoPlayer.  resume  ();\n       }\n   }\n  І якщо ми запустимо додатки, то під час торкання   VideoView  внизу з'являться інструменти для управління відео. У прицнипі тепер і кнопки, які ми створили раніше, не потрібні:    Відтворення файлу з інтернету   VideoView  підтримує відтворення файлу з інтернету. Але щоб це стало можливим, необхідно у файлі   AndroidManifest.xml  встановити дозвіл   android.permission.INTERNET , оскільки ми отримуємо дані з інтернету:     \u003C  uses-permission   android:name  =  \"android.permission.INTERNET\"   />\n  Далі змінимо клас   MainActivity :     package   com.example.mediaapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.VideoView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       VideoView   videoPlayer;\n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n           videoPlayer   =   findViewById  (R.id.videoPlayer);\n           videoPlayer.  setVideoPath  (  \"http://techslides.com/demos/sample-videos/small.mp4\"  );\n       }\n    \n       public   void   play  (  View   view  ){\n           videoPlayer.  start  ();\n       }\n       public   void   pause  (  View   view  ){\n           videoPlayer.  pause  ();\n       }\n       public   void   stop  (  View   view  ){\n           videoPlayer.  stopPlayback  ();\n           videoPlayer.  resume  ();\n       }\n   }\n  Тут нам треба в метод   videoPlayer.setVideoPath()  передати інтернет-адресу відтворюваного файлу.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":750,"path":751,"dir":667,"title":752,"description":753,"keywords":754,"body":755},"content:1.android:5.lesson5:7.working-with-audio.md","/android/lesson5/working-with-audio","Відтворення аудіо","По-перше, щоб керувати потоком відтворення, нам потрібно отримати об'єкт VideoView:videoPlayer = findViewById(R.id.videoPlayer);",[],"  Відтворення аудіо  По-перше, щоб керувати потоком відтворення, нам потрібно отримати об'єкт VideoView:   videoPlayer = findViewById(R.id.videoPlayer);  Щоб вказати джерело відтворення, необхідний об'єкт Uri. У цьому випадку за допомогою виразу   Uri myVideoUri = Uri.parse(\"android.resource://\" + getPackageName() + \"/\" + R.raw.cats);  \nотримуємо адресу відеоролика всередині пакета застосунку.  Рядок URI має кілька частин: спочатку йде Uri-схема (  http://  або, як тут,   android.resource:// ), потім назва пакета, отримана через метод   getPackageName() , і далі безпосередньо назва ресурсу відео з папки   res/raw , що збігається з назвою файлу.  Потім цей Uri встановлюється у   videoPlayer :   videoPlayer.setVideoURI(myVideoUri);  Щоб керувати відеопотоком, обробники натискання кнопок викликають відповідну дію:     public   void   play  (  View   view){\n       videoPlayer.  start  ();\n   }\n   public   void   pause  (  View   view){\n       videoPlayer.  pause  ();\n   }\n   public   void   stop  (  View   view){\n       videoPlayer.  stopPlayback  ();\n       videoPlayer.  resume  ();\n   }\n   Метод   videoPlayer.start()  починає або продовжує відтворення.  Метод   videoPlayer.pause()  призупиняє відео.  Метод   videoPlayer.stopPlayback()  повністю зупиняє відео.  Метод   videoPlayer.resume()  дозволяє знову розпочати відтворення відео з початку після його повної зупинки.   \nПотім у вікні, що з'явилося, як тип папки вкажемо   raw  (що також буде використовуватися як назва папки):\n  \nІ скопіюємо в неї який-небудь аудіо-файл.\n  \nДля управління аудіопотоком визначимо у файлі   activity_main.xml  три кнопки:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n       \u003C  Button\n           android:id  =  \"@+id/playButton\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Play\"\n           android:onClick  =  \"play\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toLeftOf  =  \"@id/pauseButton\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n       \u003C  Button\n           android:id  =  \"@+id/pauseButton\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Pause\"\n           android:onClick  =  \"pause\"\n           app:layout_constraintLeft_toRightOf  =  \"@id/playButton\"\n           app:layout_constraintRight_toLeftOf  =  \"@id/stopButton\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  />\n       \u003C  Button\n           android:id  =  \"@+id/stopButton\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Stop\"\n           android:onClick  =  \"stop\"\n           app:layout_constraintLeft_toRightOf  =  \"@id/pauseButton\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  І змінимо код класу   MainActivity :     package   com.example.mediaapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.media.MediaPlayer  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.Button  ;\n   import   android.widget.Toast  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       MediaPlayer   mPlayer;\n       Button   playButton, pauseButton, stopButton;\n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           mPlayer  =   MediaPlayer.  create  (  this  , R.raw.music);\n           mPlayer.  setOnCompletionListener  (  new   MediaPlayer.  OnCompletionListener  () {\n               @  Override\n               public   void   onCompletion  (  MediaPlayer   mp) {\n                   stopPlay  ();\n               }\n           });\n           playButton   =   findViewById  (R.id.playButton);\n           pauseButton   =   findViewById  (R.id.pauseButton);\n           stopButton   =   findViewById  (R.id.stopButton);\n    \n           pauseButton.  setEnabled  (  false  );\n           stopButton.  setEnabled  (  false  );\n       }\n       private   void   stopPlay  (){\n           mPlayer.  stop  ();\n           pauseButton.  setEnabled  (  false  );\n           stopButton.  setEnabled  (  false  );\n           try   {\n               mPlayer.  prepare  ();\n               mPlayer.  seekTo  (  0  );\n               playButton.  setEnabled  (  true  );\n           }\n           catch   (  Throwable   t  ) {\n               Toast.  makeText  (  this  , t.  getMessage  (), Toast.LENGTH_SHORT).  show  ();\n           }\n       }\n       public   void   play  (  View   view  ){\n    \n           mPlayer.  start  ();\n           playButton.  setEnabled  (  false  );\n           pauseButton.  setEnabled  (  true  );\n           stopButton.  setEnabled  (  true  );\n       }\n       public   void   pause  (  View   view  ){\n    \n           mPlayer.  pause  ();\n           playButton.  setEnabled  (  true  );\n           pauseButton.  setEnabled  (  false  );\n           stopButton.  setEnabled  (  true  );\n       }\n       public   void   stop  (  View   view  ){\n           stopPlay  ();\n       }\n       @  Override\n       public   void   onDestroy  () {\n           super  .  onDestroy  ();\n           if   (mPlayer.  isPlaying  ()) {\n               stopPlay  ();\n           }\n       }\n   }\n  Обробник кожної кнопки, окрім виклику певного методу у   MediaPlayer , також перемикає доступність кнопок.  Якщо запуск і призупинення відтворення не викликають особливих складнощів, то під час обробки повної зупинки відтворення ми можемо зіткнутися з низкою труднощів. Зокрема, коли ми виходимо із застосунку — повністю закриваємо його через диспетчер застосунків або натискаємо кнопку \"Назад\", то для поточного   Activity  викликається метод   onDestroy , активність знищується, але   MediaPlayer  продовжує працювати. Якщо ми повернемося до застосунку, активність буде створена заново, але за допомогою кнопок ми не зможемо керувати відтворенням.  Тому в цьому випадку перевизначаємо метод   onDestroy , у якому завершуємо відтворення:\n  \nДодамо до відтворення індикатор гучності. Для цього у файлі   activity_main.xml  визначимо   SeekBar :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n       \u003C  Button\n           android:id  =  \"@+id/playButton\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Play\"\n           android:onClick  =  \"play\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toLeftOf  =  \"@id/pauseButton\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/volumeControl\"   />\n       \u003C  Button\n           android:id  =  \"@+id/pauseButton\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Pause\"\n           android:onClick  =  \"pause\"\n           app:layout_constraintLeft_toRightOf  =  \"@id/playButton\"\n           app:layout_constraintRight_toLeftOf  =  \"@id/stopButton\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  />\n       \u003C  Button\n           android:id  =  \"@+id/stopButton\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Stop\"\n           android:onClick  =  \"stop\"\n           app:layout_constraintLeft_toRightOf  =  \"@id/pauseButton\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n       \u003C  SeekBar\n           android:id  =  \"@+id/volumeControl\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_marginTop  =  \"32dp\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/playButton\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"   />\n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  І далі змінимо код класу   MainActivity :     package   com.example.mediaapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.content.Context  ;\n   import   android.media.AudioManager  ;\n   import   android.media.MediaPlayer  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.Button  ;\n   import   android.widget.SeekBar  ;\n   import   android.widget.Toast  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       MediaPlayer   mPlayer;\n       Button   playButton, pauseButton, stopButton;\n       SeekBar   volumeControl;\n       AudioManager   audioManager;\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           mPlayer  =  MediaPlayer.  create  (  this  , R.raw.music);\n           mPlayer.  setOnCompletionListener  (  new   MediaPlayer.  OnCompletionListener  () {\n               @  Override\n               public   void   onCompletion  (  MediaPlayer   mp) {\n                   stopPlay  ();\n               }\n           });\n           playButton   =   findViewById  (R.id.playButton);\n           pauseButton   =   findViewById  (R.id.pauseButton);\n           stopButton   =   findViewById  (R.id.stopButton);\n    \n           audioManager   =   (AudioManager)   getSystemService  (Context.AUDIO_SERVICE);\n           int   maxVolume   =   audioManager.  getStreamMaxVolume  (AudioManager.STREAM_MUSIC);\n           int   curValue   =   audioManager.  getStreamVolume  (AudioManager.STREAM_MUSIC);\n    \n           volumeControl   =   findViewById  (R.id.volumeControl);\n           volumeControl.  setMax  (maxVolume);\n           volumeControl.  setProgress  (curValue);\n           volumeControl.  setOnSeekBarChangeListener  (  new   SeekBar.  OnSeekBarChangeListener  () {\n               @  Override\n               public   void   onProgressChanged  (  SeekBar   seekBar,   int   progress,   boolean   fromUser) {\n                   audioManager.  setStreamVolume  (AudioManager.STREAM_MUSIC, progress,   0  );\n               }\n               @  Override\n               public   void   onStartTrackingTouch  (  SeekBar   seekBar) {\n    \n               }\n               @  Override\n               public   void   onStopTrackingTouch  (  SeekBar   seekBar) {\n    \n               }\n           });\n    \n           pauseButton.  setEnabled  (  false  );\n           stopButton.  setEnabled  (  false  );\n       }\n       private   void   stopPlay  (){\n           mPlayer.  stop  ();\n           pauseButton.  setEnabled  (  false  );\n           stopButton.  setEnabled  (  false  );\n           try   {\n               mPlayer.  prepare  ();\n               mPlayer.  seekTo  (  0  );\n               playButton.  setEnabled  (  true  );\n           }\n           catch   (  Throwable   t  ) {\n               Toast.  makeText  (  this  , t.  getMessage  (), Toast.LENGTH_SHORT).  show  ();\n           }\n       }\n    \n       public   void   play  (  View   view  ){\n    \n           mPlayer.  start  ();\n           playButton.  setEnabled  (  false  );\n           pauseButton.  setEnabled  (  true  );\n           stopButton.  setEnabled  (  true  );\n       }\n       public   void   pause  (  View   view  ){\n    \n           mPlayer.  pause  ();\n           playButton.  setEnabled  (  true  );\n           pauseButton.  setEnabled  (  false  );\n           stopButton.  setEnabled  (  true  );\n       }\n       public   void   stop  (  View   view  ){\n           stopPlay  ();\n       }\n       @  Override\n       public   void   onDestroy  () {\n           super  .  onDestroy  ();\n           if   (mPlayer.  isPlaying  ()) {\n               stopPlay  ();\n           }\n       }\n   }\n  Для керування гучністю звуку застосовується клас   AudioManager . А за допомогою виклику   audioManager.setStreamVolume(AudioManager.STREAM_MUSIC, progress, 0);  як другий параметр можна передати потрібне значення гучності.    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":757,"path":758,"dir":667,"title":759,"description":760,"keywords":761,"body":763},"content:1.android:5.lesson5:8.saving-the-application-state.md","/android/lesson5/saving-the-application-state","Збереження стану програми","В одній із попередніх тем був розглянутий життєвий цикл Activity у застосунку на Android, де після створення Activity викликався метод onRestoreInstanceState, який відновлював її стан, а перед завершенням роботи викликався метод onSaveInstanceState, який зберігав стан Activity. Обидва ці методи як параметр приймають об'єкт Bundle, який зберігає стан Activity:",[762],"У яких ситуаціях доречно використовувати ці методи?","  Збереження стану програми  В одній із попередніх тем був розглянутий життєвий цикл   Activity  у застосунку на Android, де після створення   Activity  викликався метод   onRestoreInstanceState , який відновлював її стан, а перед завершенням роботи викликався метод   onSaveInstanceState , який зберігав стан   Activity . Обидва ці методи як параметр приймають об'єкт   Bundle , який зберігає стан   Activity :     protected   void   onRestoreInstanceState  (  Bundle   saveInstanceState);\n   protected   void   onSaveInstanceState  (  Bundle   saveInstanceState);\n  У яких ситуаціях доречно використовувати ці методи?  Банальна ситуація — переворот екрана та перехід від портретної орієнтації до альбомної та навпаки. Якщо, наприклад, графічний інтерфейс містить текстове поле для виводу   TextView , і ми програмно змінюємо його текст, то після зміни орієнтації екрана його текст може зникнути.  Крім того, якщо ми використовуємо глобальні змінні, то при зміні орієнтації екрана їхні значення можуть бути скинуті до значень за замовчуванням.  Щоб точніше зрозуміти проблему, з якою ми можемо зіткнутися, розглянемо приклад. Змінимо файл   activity_main  таким чином:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"   >\n    \n       \u003C  EditText\n           android:id  =  \"@+id/nameBox\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:hint  =  \"Впишіть ім'я\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/saveButton\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n       \u003C  Button\n           android:id  =  \"@+id/saveButton\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Зберегти\"\n           android:onClick  =  \"saveName\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/nameView\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/nameBox\"  />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/nameView\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"18sp\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/getButton\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/saveButton\"  />\n       \u003C  Button\n           android:id  =  \"@+id/getButton\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Отримати ім'я\"\n           android:onClick  =  \"getName\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/nameView\"  />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Тут визначено поле   EditText , у яке вводимо ім'я. І також визначено кнопку для його збереження.  Далі для виведення збереженого імені призначене поле   TextView , а для отримання збереженого імені - друга кнопка.  Тепер змінимо клас   MainActivity :     package   com.example.settingsapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.EditText  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       String   name   =  \"undefined\"  ;\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n    \n       public   void   saveName  (  View   view  ) {\n    \n           // отримуємо введене ім'я\n           EditText   nameBox   =   findViewById  (R.id.nameBox);\n           name   =   nameBox.  getText  ().  toString  ();\n       }\n       public   void   getName  (  View   view  ) {\n    \n           // отримуємо збережене ім'я\n           TextView   nameView   =   findViewById  (R.id.nameView);\n           nameView.  setText  (name);\n       }\n   }\n  Для зберігання імені в програмі визначено змінну name. Під час натискання на першу кнопку зберігаємо текст з   EditText  у змінну   name , а під час натискання на другу кнопку - назад отримуємо текст зі змінної   name  у поле   TextView .  Запустимо додаток, введемо якесь ім'я, збережемо і отримаємо його в   TextView :\n  \nАле якщо ми перейдемо до альбомного режиму, то TextView виявиться порожнім, незважаючи на те, що в нього начебто вже отримали потрібне значення:\n  \nІ навіть якщо ми спробуємо заново отримати значення зі змінної name, то ми побачимо, що вона обнулилася:\n  \nЩоб уникнути подібних ситуацій якраз і слід зберігати та відновлювати стан activity. Для цього змінимо код   MainActivity :     package   com.example.settingsapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.EditText  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       String   name   =  \"undefined\"  ;\n       final   static   String   nameVariableKey   =   \"NAME_VARIABLE\"  ;\n       TextView   nameView;\n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           nameView   =   findViewById  (R.id.nameView);\n       }\n    \n       // збереження стану\n       @  Override\n       protected   void   onSaveInstanceState  (  Bundle   outState  ) {\n    \n           outState.  putString  (nameVariableKey, name);\n           super  .  onSaveInstanceState  (outState);\n       }\n       // отримання раніше збереженого стану\n       @  Override\n       protected   void   onRestoreInstanceState  (  Bundle   savedInstanceState  ) {\n           super  .  onRestoreInstanceState  (savedInstanceState);\n    \n           name   =   savedInstanceState.  getString  (nameVariableKey);\n           nameView.  setText  (name);\n       }\n       public   void   saveName  (  View   view  ) {\n    \n           // отримуємо введене ім'я\n           EditText   nameBox   =   findViewById  (R.id.nameBox);\n           //  зберігаємо його у змінну name\n           name   =   nameBox.  getText  ().  toString  ();\n       }\n       public   void   getName  (  View   view  ) {\n    \n           //  виводимо збережене ім'я\n           nameView.  setText  (name);\n       }\n   }\n  У методі   onSaveInstanceState()  зберігаємо стан. Для цього викликаємо у параметра   Bundle  метод   putString(key, value) , перший параметр якого — це ключ, а другий — значення збережених даних. У цьому випадку ми зберігаємо рядок, тому викликаємо метод   putString() . Для збереження об'єктів інших типів даних ми можемо викликати відповідні методи:    put() : універсальний метод, який додає значення типу   Object . Відповідно, поле отримання це значення потрібно перетворити до потрібного типу.   putString() : додає об'єкт типу   String .   putInt() : додає значення типу   int .   putByte() : додає значення типу   byte .   putChar() : додає значення типу   char .   putShort() : додає значення типу   short .   putLong() : додає значення типу   long .   putFloat() : додає значення типу   float .   putDouble() : додає значення типу   double .   putBoolean() : додає значення типу   boolean .   putCharArray() : додає масив об'єктів типу   char .   putIntArray() : додає масив об'єктів типу   int .   putFloatArray() : додає масив об'єктів типу   float .   putSerializable() : додає об'єкт інтерфейсу   Serializable .   putParcelable() : додає об'єкт типу   Parcelable .  Кожен такий метод також в якості першого параметра приймає ключ, а в якості другого — значення.  У методі   onRestoreInstanceState()  відбувається зворотний процес — за допомогою методу   getString(key)  за ключем отримуємо збережену строку. Відповідно, для отримання даних інших типів ми можемо використовувати аналогічні методи:    get() : універсальний метод, який повертає значення типу   Object . Відповідно, поле отримання це значення потрібно перетворити до потрібного типу.   getString() : повертає об'єкт типу   String .   getInt() : повертає значення типу   int .   getByte() : повертає значення типу   byte .   getChar() : повертає значення типу   char .   getShort() : повертає значення типу   short .   getLong() : повертає значення типу   long .   getFloat() : повертає значення типу   float .   getDouble() : повертає значення типу   double .   getBoolean() : повертає значення типу   boolean .   getCharArray() : повертає масив об'єктів типу   char .   getIntArray() : повертає масив об'єктів типу   int .   getFloatArray() : повертає масив об'єктів типу   float .   getSerializable() : повертає об'єкт інтерфейсу   Serializable .   getParcelable() : повертає об'єкт типу   Parcelable .  Для прикладу розглянемо збереження-отримання складніших даних. Наприклад, об'єктів певного класу. Нехай у нас є клас   User :     package   com.example.settingsapp  ;\n    \n   import   java.io.Serializable  ;\n    \n   public   class   User   implements   Serializable   {\n    \n       private   String   name;\n       private   int   age;\n    \n       public   User  (  String   name  ,   int   age  ){\n           this  .name   =   name;\n           this  .age   =   age;\n       }\n    \n       public   String   getName  () {\n           return   name;\n       }\n    \n       public   void   setName  (  String   name  ) {\n           this  .name   =   name;\n       }\n    \n       public   int   getAge  () {\n           return   age;\n       }\n    \n       public   void   setAge  (  int   age  ) {\n           this  .age   =   age;\n       }\n   }\n  Клас   User  реалізує інтерфейс   Serializable , тому ми можемо зберегти його об'єкти за допомогою методу   putSerializable() , а отримати за допомогою методу   getSerializable() .  Нехай у нас буде наступний інтерфейс в   activity_main.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"   >\n    \n       \u003C  EditText\n           android:id  =  \"@+id/nameBox\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:hint  =  \"Введіть ім'я\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/yearBox\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n       \u003C  EditText\n           android:id  =  \"@+id/yearBox\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:hint  =  \"Введіть вік\"\n           android:inputType  =  \"numberDecimal\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/saveButton\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n       \u003C  Button\n           android:id  =  \"@+id/saveButton\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Зберегти\"\n           android:onClick  =  \"saveData\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/dataView\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/yearBox\"  />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/dataView\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"18sp\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/getButton\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/saveButton\"  />\n       \u003C  Button\n           android:id  =  \"@+id/getButton\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Отримати дані\"\n           android:onClick  =  \"getData\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/dataView\"  />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Тут визначено два поля введення для імені та віку відповідно.  У класі   MainActivity  пропишемо логіку збереження та отримання даних:     package   com.example.settingsapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.EditText  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       User   user   =   new   User  (  \"undefined\"  ,   0  );\n       final   static   String   userVariableKey   =   \"USER_VARIABLE\"  ;\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n    \n       // збереження стану\n       @  Override\n       protected   void   onSaveInstanceState  (  Bundle   outState  ) {\n    \n           outState.  putSerializable  (userVariableKey, user);\n           super  .  onSaveInstanceState  (outState);\n       }\n       // отримання раніше збереженого стану\n       @  Override\n       protected   void   onRestoreInstanceState  (  Bundle   savedInstanceState  ) {\n           super  .  onRestoreInstanceState  (savedInstanceState);\n           // получаем объект User в переменную\n           user   =   (User)savedInstanceState.  getSerializable  (userVariableKey);\n           TextView   dataView   =   findViewById  (R.id.dataView);\n           dataView.  setText  (  \"Name: \"   +   user.  getName  ()   +   \" Age: \"   +   user.  getAge  ());\n       }\n       public   void   saveData  (  View   view  ) {\n    \n           // отримуємо введені дані\n           EditText   nameBox   =   findViewById  (R.id.nameBox);\n           EditText   yearBox   =   findViewById  (R.id.yearBox);\n           String   name   =   nameBox.  getText  ().  toString  ();\n           int   age   =   0  ;    // значення за замовчуванням, якщо користувач ввів некоректні дані\n           try  {\n               age   =   Integer.  parseInt  (yearBox.  getText  ().  toString  ());\n           }\n           catch   (  NumberFormatException   ex  ){}\n           user   =   new   User  (name, age);\n       }\n       public   void   getData  (  View   view  ) {\n    \n           // отримуємо збережені дані\n           TextView   dataView   =   findViewById  (R.id.dataView);\n           dataView.  setText  (  \"Name: \"   +   user.  getName  ()   +   \" Age: \"   +   user.  getAge  ());\n       }\n   }\n  Тут також зберігаємо дані у змінну   User , яка попередньо ініціалізована деякими даними за замовчуванням. А під час натискання на кнопку отримання отримаємо дані зі змінної і передаємо їх для виведення в текстове поле.    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":765,"path":766,"dir":667,"title":767,"description":768,"keywords":769,"body":772},"content:1.android:5.lesson5:9.shared-preferences-settings.md","/android/lesson5/shared-preferences-settings","Створення та отримання налаштувань SharedPreferences","Нерідко додатку потрібно зберігати невеликі шматки даних для подальшого використання, наприклад, дані про користувача, налаштування конфігурації тощо. Для цього в Android існує концепція Preferences або налаштувань. Налаштування являють собою групу пар ключ-значення, які використовуються додатком.",[770,771],"Загальні налаштування","Приватні налаштування","  Створення та отримання налаштувань SharedPreferences  Нерідко додатку потрібно зберігати невеликі шматки даних для подальшого використання, наприклад, дані про користувача, налаштування конфігурації тощо. Для цього в Android існує концепція   Preferences  або налаштувань. Налаштування являють собою групу пар ключ-значення, які використовуються додатком.  Як значення можуть виступати дані наступних типів:   Boolean ,   Float ,   Integer ,   Long ,   String , набір рядків.  Налаштування є загальними для всіх activity в додатку, але також можуть бути і налаштування безпосередньо для окремих activity.  Налаштування зберігаються в xml-файлах у незашифрованому вигляді в локальному сховищі. Вони невидимі, тому для простого користувача недоступні.  При роботі з налаштуваннями слід враховувати наступні моменти. Оскільки вони зберігаються в незашифрованому вигляді, не рекомендується зберігати в них чутливі дані типу паролів чи номерів кредитних карток. Крім того, вони представляють дані, асоційовані з додатком, і через панель управління додатком в Налаштуваннях ОС користувач може видалити ці дані.  Загальні налаштування  Для роботи з розділеними налаштуваннями в класі Activity (точніше в його базовому класі   Context ) є метод   getSharedPreferences() :     import   android.content.SharedPreferences  ;\n    \n   //...........................\n    \n   SharedPreferences   settings   =   getSharedPreferences  (  \"PreferencesName\"  , MODE_PRIVATE);\n  Перший параметр методу вказує на назву налаштувань. В даному випадку назва -   \"PreferencesName\" . Якщо налаштувань з таким ім'ям немає, вони створюються при виклику цього методу. Другий параметр вказує на режим доступу. В даному випадку режим описано константою   MODE_PRIVATE .  Клас   android.content.SharedPreferences  надає низку методів для управління налаштуваннями:    contains(String key) : повертає   true , якщо в налаштуваннях збережено значення з ключем   key   getAll() : повертає всі збережені в налаштуваннях значення   getBoolean(String key, boolean defValue) : повертає з налаштувань значення типу Boolean, яке має ключ   key . Якщо елемент з таким ключем не знайдено, повертається значення   defValue , передане другим параметром   getFloat(String key, float defValue) : повертає значення типу float з ключем   key . Якщо елемент з таким ключем не знайдено, повертається значення   defValue   getInt(String key, int defValue) : повертає значення типу int з ключем   key   getLong(String key, long defValue) : повертає значення типу long з ключем   key   getString(String key, String defValue) : повертає рядкове значення з ключем   key   getStringSet(String key, Set\u003CString> defValues) : повертає масив рядків з ключем   key   edit() : повертає об'єкт   SharedPreferences.Editor , який використовується для редагування налаштувань  Для управління налаштуваннями використовується об'єкт класу   SharedPreferences.Editor , який повертається методом   edit() . Він визначає наступні методи:    clear() : видаляє всі налаштування   remove(String key) : видаляє з налаштувань значення з ключем   key   putBoolean(String key, boolean value) : додає в налаштування значення типу boolean з ключем   key   putFloat(String key, float value) : додає в налаштування значення типу float з ключем   key   putInt(String key, int value) : додає в налаштування значення типу int з ключем   key   putLong(String key, long value) : додає в налаштування значення типу long з ключем   key   putString(String key, String value) : додає в налаштування рядок з ключем   key   putStringSet(String key, Set\u003CString> values) : додає в налаштування масив рядків   commit() : підтверджує всі зміни в налаштуваннях   apply() : також, як і метод   commit() , підтверджує всі зміни в налаштуваннях, однак змінений об'єкт   SharedPreferences  спочатку зберігається в тимчасовій пам'яті, і лише потім в результаті асинхронної операції записується на мобільний пристрій  Розглянемо приклад збереження й отримання налаштувань у застосунку. Визначимо у файлі   activity_main .xml наступний користувацький інтерфейс:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"   >\n    \n       \u003C  EditText\n           android:id  =  \"@+id/nameBox\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:hint  =  \"Введіть ім'я\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/saveButton\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n       \u003C  Button\n           android:id  =  \"@+id/saveButton\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Зберегти\"\n           android:onClick  =  \"saveName\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/nameView\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/nameBox\"  />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/nameView\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"18sp\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/getButton\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/saveButton\"  />\n       \u003C  Button\n           android:id  =  \"@+id/getButton\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Отримати ім'я\"\n           android:onClick  =  \"getName\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/nameView\"  />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  На екрані будуть дві кнопки - для збереження і для виведення раніше збереженого значення, а також поле для введення і текстове поля для виведення збереженого налаштування.  Визначимо методи обробники кнопок у класі   MainActivity :     package   com.example.settingsapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.content.SharedPreferences  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.EditText  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       private   static   final   String   PREFS_FILE   =   \"Account\"  ;\n       private   static   final   String   PREF_NAME   =   \"Name\"  ;\n       SharedPreferences   settings;\n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n           settings   =   getSharedPreferences  (PREFS_FILE, MODE_PRIVATE);\n       }\n    \n       public   void   saveName  (  View   view  ) {\n           // отримуємо введене ім'я\n           EditText   nameBox   =   findViewById  (R.id.nameBox);\n           String   name   =   nameBox.  getText  ().  toString  ();\n           // зберігаємо його в налаштуваннях\n           SharedPreferences  .  Editor   prefEditor   =   settings.  edit  ();\n           prefEditor.  putString  (PREF_NAME, name);\n           prefEditor.  apply  ();\n       }\n    \n       public   void   getName  (  View   view  ) {\n           // отримуємо збережене ім'я\n           TextView   nameView   =   findViewById  (R.id.nameView);\n           String   name   =   settings.  getString  (PREF_NAME,   \"не визначено\"  );\n           nameView.  setText  (name);\n       }\n   }\n  За відсутності налаштувань під час спроби їх отримати, додаток виведе значення за замовчуванням:\n  \nТепер збережемо і виведемо заново збережене значення:\n  \nНерідко виникає завдання автоматично зберігати дані, що вводяться, при виході користувача з activity. Для цього ми можемо перевизначити метод   onPause :     package   com.example.settingsapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.content.SharedPreferences  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.EditText  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       private   static   final   String   PREFS_FILE   =   \"Account\"  ;\n       private   static   final   String   PREF_NAME   =   \"Name\"  ;\n       EditText   nameBox;\n       SharedPreferences   settings;\n       SharedPreferences  .  Editor   prefEditor;\n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           nameBox   =   findViewById  (R.id.nameBox);\n           settings   =   getSharedPreferences  (PREFS_FILE, MODE_PRIVATE);\n    \n           // отримуємо налаштування\n           String   name   =   settings.  getString  (PREF_NAME,  \"\"  );\n           nameBox.  setText  (name);\n       }\n    \n       @  Override\n       protected   void   onPause  (){\n           super  .  onPause  ();\n    \n           String   name   =   nameBox.  getText  ().  toString  ();\n           // зберігаємо в налаштуваннях\n           prefEditor   =   settings.  edit  ();\n           prefEditor.  putString  (PREF_NAME, name);\n           prefEditor.  apply  ();\n       }\n    \n       public   void   saveName  (  View   view  ) {\n    \n       }\n    \n       public   void   getName  (  View   view  ) {\n    \n       }\n   }\n  Приватні налаштування  Окрім загальних налаштувань, кожна   activity  може використовувати приватні налаштування, до яких доступ з інших   activity  буде неможливий. Для отримання налаштувань рівня   activity  використовується метод   getPreferences(MODE_PRIVATE) :     import   android.content.SharedPreferences  ;\n   //........................\n   SharedPreferences   settings   =   getPreferences  (MODE_PRIVATE);\n  Тобто, на відміну від загальних налаштувань, тут не використовується назва групи налаштувань в якості першого параметра, як в методі   getSharedPreferences() . Однак вся решта робота по додаванню, отриманню та зміненню налаштувань буде аналогічна роботі з загальними налаштуваннями.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":774,"path":775,"dir":667,"title":776,"description":777,"keywords":778,"body":780},"content:1.android:5.lesson5:10.preference-fragment-compat.md","/android/lesson5/preference-fragment-compat","PreferenceFragmentCompat","Для спрощення роботи з групою налаштувань Android надає спеціальний тип фрагмента - PreferenceFragmentCompat. Розглянемо як її використовувати.",[779],"Налаштування в Android","  PreferenceFragmentCompat  Для спрощення роботи з групою налаштувань Android надає спеціальний тип фрагмента -   PreferenceFragmentCompat . Розглянемо як її використовувати.  Створимо новий проєкт і спочатку визначимо у файлі   build.gradle  потрібні залежності для роботи з   PreferenceFragmentCompat :     implementation   \"androidx.fragment:fragment:1.3.6\"\n   implementation   \"androidx.preference:preference:1.1.1\"\n  Для визначення налаштувань додамо в папку res підпапку xml.    Потім у папку res/xml додамо новий файл, який назвемо   settings.xml . І змінимо його таким чином.     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  PreferenceScreen   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"  >\n       \u003C  EditTextPreference\n           android:key  =  \"login\"\n           android:summary  =  \"Введіть логін\"\n           android:title  =  \"Логін\"   />\n       \u003C  CheckBoxPreference\n           android:key  =  \"enabled\"\n           android:summary  =  \"Відображати логін\"\n           android:title  =  \"Відображати\"   />\n   \u003C/  PreferenceScreen  >\n  Налаштування в Android  В кореневому елементі   PreferenceScreen  встановлюються елементи   EditTextPreference  і   CheckBoxPreference . Через кожен з цих елементів ми можемо взаємодіяти з певною налаштуванням.  Взагалі в даному випадку ми можемо використовувати ряд різних типів налаштувань:    EditTextPreference : використовується елемент   EditText  для введення текстового значення.   CheckBoxPreference : використовується елемент   CheckBox  для встановлення логічних значень   true  або   false .   SwitchPreference : використовується елемент   Switch  для встановлення логічних значень   true  або   false  (\"on\" і \"off\").   RingtonePreference : використовує діалогове вікно для встановлення рінгтону зі списку рінгтонів для встановлення логічних значень   true  або   false .   ListPreference : використовує список для вибору одного з попередньо визначених значень.   MultiSelectListPreference : також використовує список для вибору значень, але дозволяє вибирати кілька елементів.  Для кожного елемента налаштування необхідно визначити, як мінімум, три атрибути:    android:key : встановлює ключ налаштування в   SharedPreferences .   android:title : назва налаштування для користувача.   android:summary : короткий опис цього налаштування для користувача.  Далі додамо новий клас Java, який назвемо   SettingsFragment :  Фрагмент   SettingsFragment  успадковується від класу   PreferenceFragmentCompat . У його методі   onCreatePreferences  викликається метод   addPreferencesFromResource() , до якого передається   id  ресурсу xml з налаштуваннями (у цьому випадку раніше визначений ресурс   R.xml.settings ).  І тепер додамо в проєкт спеціальну activity для встановлення налаштувань. Назвемо її   SettingsActivity . У підсумку проєкт матиме такий вигляд:\n   У файлі layout для   SettingsActivity  -   activity_settings.xml  пропишемо такий інтерфейс:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.fragment.app.FragmentContainerView\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:id  =  \"@+id/settings_container\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"   />\n  Тут визначено   FragmentContainerView  з   id = settings_container  - саме той елемент, у який завантажуватиметься фрагмент   SettingsFragment .  У коді   SettingsActivity  визначимо завантаження фрагмента:     package   com.example.settingsapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.os.Bundle  ;\n    \n   public   class   SettingsActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_settings);\n    \n           getSupportFragmentManager  ()\n                   .  beginTransaction  ()\n                   .  replace  (R.id.settings_container,   new   SettingsFragment  ())\n                   .  commit  ();\n       }\n   }\n   SettingsActivity  як розмітку інтерфейсу використовуватиме ресурс   R.layout.activity_settings .  Під час запуску   SettingsActivity  завантажуватиме фрагмент   SettingsFragment  в елемент з   id.settings_container .  Далі перейдемо до головної activity -   MainActivity . У файлі   activity_main.xml  визначимо текстове поле і кнопку:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"   >\n    \n       \u003C  TextView\n           android:id  =  \"@+id/settingsText\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"18sp\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/settingsButton\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n       \u003C  Button\n           android:id  =  \"@+id/settingsButton\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Налаштування\"\n           android:onClick  =  \"setPrefs\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/settingsText\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  І змінимо клас   MainActivity :     package   com.example.settingsapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   androidx.preference.PreferenceManager  ;\n    \n   import   android.content.Intent  ;\n   import   android.content.SharedPreferences  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       TextView   settingsText;\n       boolean   enabled;\n       String   login;\n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           settingsText   =   findViewById  (R.id.settingsText);\n       }\n    \n       @  Override\n       public   void   onResume  () {\n           super  .  onResume  ();\n           SharedPreferences   prefs  =   PreferenceManager.  getDefaultSharedPreferences  (  this  );\n           enabled   =   prefs.  getBoolean  (  \"enabled\"  ,   false  );\n           login   =   prefs.  getString  (  \"login\"  ,   \"не встановлено\"  );\n           settingsText.  setText  (login);\n           if  (enabled)\n               settingsText.  setVisibility  (View.VISIBLE);\n           else\n               settingsText.  setVisibility  (View.INVISIBLE);\n       }\n    \n       public   void   setPrefs  (  View   view  ){\n           Intent   intent   =   new   Intent  (  this  , SettingsActivity.class);\n           startActivity  (intent);\n       }\n   }\n  У методі   onResume()  отримуємо всі налаштування. Якщо налаштування   enabled  дорівнює   true , то відображаємо текстове поле з логіном.  У методі   setPrefs() , який спрацьовує при натисканні на кнопку, виконується перехід до   SettingsActivity .  Під час першого запуску налаштувань не буде, і логін не відображатиметься. Перейдемо на сторінку налаштувань і встановимо там логін і ввімкнемо його відображення, а потім повернемося на головну activity:\n  \nПри цьому вручну нам нічого не треба зберігати, всі налаштування автоматично зберігаються функціоналом   PreferenceFragmentCompat .  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":782,"path":783,"dir":667,"title":784,"description":785,"keywords":786,"body":788},"content:1.android:5.lesson5:11.work-with-files-1.md","/android/lesson5/work-with-files-1","Читання та збереження файлів","Робота з налаштуваннями рівня activity і програми дозволяє зберігати невеликі дані окремих типів (string, int), але для роботи з більшими масивами даних, такими як графічні файли, файли мультимедіа тощо, нам доведеться звертатися до файлової системи.",[787],"Основні характеристики:","  Читання та збереження файлів  Робота з налаштуваннями рівня activity і програми дозволяє зберігати невеликі дані окремих типів (string, int), але для роботи з більшими масивами даних, такими як графічні файли, файли мультимедіа тощо, нам доведеться звертатися до файлової системи.  ОС Android побудована на основі Linux. Цей факт знаходить своє відображення в роботі з файлами. Так, у шляхах до файлів в Linux використовується коса риска   / , а не зворотна риска   \\  (як у Windows). А всі назви файлів і каталогів є чутливими до регістру, тобто \"data\" — це не те ж саме, що і \"Data\".  Програма Android зберігає свої дані в каталозі   /data/data/\u003Cназва_пакета>/  і, як правило, відносно цього каталогу буде йти робота.  Для роботи з файлами абстрактний клас   android.content.Context  визначає низку методів:    boolean deleteFile (String name) : видаляє певний файл.   String   fileList () : отримує всі файли, які містяться в підкаталозі   /files  каталогу програми.   File getCacheDir() : отримує посилання на підкаталог   cache  в каталозі програми.   File getDir(String dirName, int mode) : отримує посилання на підкаталог в каталозі програми, якщо такого підкаталога немає, то він створюється.   File getExternalCacheDir() : отримує посилання на папку   /cache  зовнішньої файлової системи пристрою.   File getExternalFilesDir(String type) : отримує посилання на каталог   /files  зовнішньої файлової системи пристрою.   File getFileStreamPath(String filename) : повертає абсолютний шлях до файлу в файловій системі.   FileInputStream openFileInput(String filename) : відкриває файл для читання.   FileOutputStream openFileOutput (String name, int mode) : відкриває файл для запису.  Усі файли, які створюються і редагуються в програмі, зазвичай зберігаються в підкаталозі   /files  в каталозі програми.  Для безпосереднього читання і запису файлів застосовуються також стандартні класи Java з пакету   java.io .  Отже, застосуємо функціонал читання-запису файлів у додатку. Нехай у нас буде така примітивна розмітка layout:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  EditText\n           android:id  =  \"@+id/editor\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           android:textSize  =  \"18sp\"\n           android:gravity  =  \"start\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/save_text\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n       \u003C  Button\n           android:id  =  \"@+id/save_text\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n    \n           android:onClick  =  \"saveText\"\n           android:text  =  \"Сохранить\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/text\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/editor\"   />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/text\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           android:gravity  =  \"start\"\n           android:textSize  =  \"18sp\"\n    \n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintBottom_toTopOf  =  \"@+id/open_text\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/save_text\"   />\n       \u003C  Button\n           android:id  =  \"@+id/open_text\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:onClick  =  \"openText\"\n           android:text  =  \"Открыть\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/text\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Поле   EditText  призначене для введення тексту, а   TextView  - для виведення раніше збереженого тексту. Для збереження і відновлення тексту додано дві кнопки.  Тепер у коді Activity пропишемо обробники кнопок зі збереженням і читанням файлу:     package   com.example.filesapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.EditText  ;\n   import   android.widget.TextView  ;\n   import   android.widget.Toast  ;\n   \n   import   java.io.FileInputStream  ;\n   import   java.io.FileOutputStream  ;\n   import   java.io.IOException  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       private   static   final   String   FILE_NAME   =   \"content.txt\"  ;\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n   \n       // Збереження тексту у файл\n       public   void   saveText  (  View   view  ) {\n           EditText   editor   =   findViewById  (R.id.editor);\n           String   text   =   editor.  getText  ().  toString  ();\n   \n           // Використовуємо try-with-resources для автоматичного закриття потоку\n           try   (  FileOutputStream   fos   =   openFileOutput  (FILE_NAME, MODE_PRIVATE)) {\n               fos.  write  (text.  getBytes  ());\n               showToast  (  \"Файл збережено\"  );\n           }   catch   (  IOException   e  ) {\n               showToast  (  \"Помилка при збереженні: \"   +   e.  getMessage  ());\n           }\n       }\n   \n       // Відкриття тексту з файлу\n       public   void   openText  (  View   view  ) {\n           TextView   textView   =   findViewById  (R.id.text);\n   \n           // Використовуємо try-with-resources для автоматичного закриття потоку\n           try   (  FileInputStream   fin   =   openFileInput  (FILE_NAME)) {\n               byte  [] bytes   =   new   byte  [fin.  available  ()];\n               fin.  read  (bytes);\n               String   text   =   new   String  (bytes);\n               textView.  setText  (text);\n           }   catch   (  IOException   e  ) {\n               showToast  (  \"Помилка при відкритті: \"   +   e.  getMessage  ());\n           }\n       }\n   \n       // Метод для відображення повідомлень Toast\n       private   void   showToast  (  String   message  ) {\n           Toast.  makeText  (  this  , message, Toast.LENGTH_SHORT).  show  ();\n       }\n   }\n  варіант 2:     package   com.example.filesapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.EditText  ;\n   import   android.widget.TextView  ;\n   import   android.widget.Toast  ;\n   \n   import   java.io.BufferedReader  ;\n   import   java.io.BufferedWriter  ;\n   import   java.io.FileInputStream  ;\n   import   java.io.FileOutputStream  ;\n   import   java.io.FileReader  ;\n   import   java.io.FileWriter  ;\n   import   java.io.IOException  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       private   static   final   String   FILE_NAME   =   \"content.txt\"  ;\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n   \n       // Збереження тексту у файл з використанням BufferedWriter\n       public   void   saveText  (  View   view  ) {\n           EditText   editor   =   findViewById  (R.id.editor);\n           String   text   =   editor.  getText  ().  toString  ();\n   \n           // Використовуємо try-with-resources для автоматичного закриття потоку\n           try   (  BufferedWriter   writer   =   new   BufferedWriter  (  new   FileWriter  (  getFileStreamPath  (FILE_NAME)))) {\n               writer.  write  (text);\n               showToast  (  \"Файл збережено\"  );\n           }   catch   (  IOException   e  ) {\n               showToast  (  \"Помилка при збереженні: \"   +   e.  getMessage  ());\n           }\n       }\n   \n       // Відкриття тексту з файлу з використанням BufferedReader\n       public   void   openText  (  View   view  ) {\n           TextView   textView   =   findViewById  (R.id.text);\n           StringBuilder   stringBuilder   =   new   StringBuilder  ();\n   \n           // Використовуємо try-with-resources для автоматичного закриття потоку\n           try   (  BufferedReader   reader   =   new   BufferedReader  (  new   FileReader  (  getFileStreamPath  (FILE_NAME)))) {\n               String   line;\n               while   ((line   =   reader.  readLine  ())   !=   null  ) {\n                   stringBuilder.  append  (line).  append  (  \"  \\n  \"  );\n               }\n               textView.  setText  (stringBuilder.  toString  ());\n           }   catch   (  IOException   e  ) {\n               showToast  (  \"Помилка при відкритті: \"   +   e.  getMessage  ());\n           }\n       }\n   \n       // Метод для відображення повідомлень Toast\n       private   void   showToast  (  String   message  ) {\n           Toast.  makeText  (  this  , message, Toast.LENGTH_SHORT).  show  ();\n       }\n   }\n  варіант №3     package   com.example.filesapp  ;\n   \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.EditText  ;\n   import   android.widget.TextView  ;\n   import   android.widget.Toast  ;\n   \n   import   java.io.IOException  ;\n   import   java.nio.file.Files  ;\n   import   java.nio.file.Path  ;\n   import   java.nio.file.Paths  ;\n   import   java.nio.charset.StandardCharsets  ;\n   \n   public   class   MainActivity   extends   AppCompatActivity   {\n   \n       private   static   final   String   FILE_NAME   =   \"content.txt\"  ;\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n   \n       // Збереження тексту у файл з використанням NIO (Java NIO)\n       public   void   saveText  (  View   view  ) {\n           EditText   editor   =   findViewById  (R.id.editor);\n           String   text   =   editor.  getText  ().  toString  ();\n   \n           // Створюємо шлях до файлу\n           Path   path   =   getFileStreamPath  (FILE_NAME).  toPath  ();\n   \n           try   {\n               // Записуємо текст у файл, використовуючи NIO (вказуємо кодування)\n               Files.  write  (path, text.  getBytes  (StandardCharsets.UTF_8));\n               showToast  (  \"Файл збережено\"  );\n           }   catch   (  IOException   e  ) {\n               showToast  (  \"Помилка при збереженні: \"   +   e.  getMessage  ());\n           }\n       }\n   \n       // Відкриття тексту з файлу з використанням NIO (Java NIO)\n       public   void   openText  (  View   view  ) {\n           TextView   textView   =   findViewById  (R.id.text);\n   \n           // Створюємо шлях до файлу\n           Path   path   =   getFileStreamPath  (FILE_NAME).  toPath  ();\n   \n           try   {\n               // Зчитуємо вміст файлу в рядок за допомогою NIO\n               String   content   =   new   String  (Files.  readAllBytes  (path), StandardCharsets.UTF_8);\n               textView.  setText  (content);\n           }   catch   (  IOException   e  ) {\n               showToast  (  \"Помилка при відкритті: \"   +   e.  getMessage  ());\n           }\n       }\n   \n       // Метод для відображення повідомлень Toast\n       private   void   showToast  (  String   message  ) {\n           Toast.  makeText  (  this  , message, Toast.LENGTH_SHORT).  show  ();\n       }\n   }\n  При натисканні на кнопку збереження буде створюватися потік виводу:     FileOutputStream   fos   =   openFileOutput  (FILE_NAME, MODE_PRIVATE);\n  У цьому випадку введений текст буде зберігатися у файл   \"content.txt\" . При цьому буде використовуватися режим   MODE_PRIVATE .  Система дозволяє створювати файли з двома різними режимами:    MODE_PRIVATE : файли можуть бути доступні тільки власнику програми (режим за замовчуванням).   MODE_APPEND : дані можуть бути додані в кінець файлу.  Тому в даному випадку, якщо файл \"content.txt\" вже існує, він буде перезаписаний. Якщо ж потрібно було б дописати в файл, тоді слід використовувати режим   MODE_APPEND :     FileOutputStream   fos   =   openFileOutput  (FILE_NAME, MODE_APPEND);\n  Для читання файлу застосовується потік вводу:     FileInputStream   fin   =   openFileInput  (FILE_NAME);\n  У підсумку після натискання кнопки збереження весь текст буде збережено у файлі   /data/data/назва_пакета/files/content.txt   Де фізично знаходиться створений файл? Щоб побачити його на під'єднаному пристрої перейдемо в Android Stud у меню до пункту   View -> Tool Windows -> Device File Explorer  \nПісля цього відкриється вікно Device File Explorer для перегляду файлової системи пристрою. І в папці   data/data/[назва_пакета_додатка]/files  ми зможемо знайти збережений файл.\n   Методи   openFileOutput  та   openFileInput  — це методи Android, що дозволяють працювати з файлами, які зберігаються в внутрішньому сховищі додатку. Це частина специфічного API для роботи з файлами в Android. Вони використовуються для збереження та зчитування даних, що зберігаються тільки для поточного додатка, і вони не доступні іншим додаткам або користувачам.  Основні характеристики:   Внутрішнє сховище (Internal Storage):\n   Файли, створені за допомогою цих методів, зберігаються в приватній частині внутрішнього сховища вашого додатку. Це означає, що тільки ваш додаток має доступ до цих файлів.  Вони не доступні іншим додаткам або користувачам.  Файли, збережені через ці методи, не видимі в системному файловому менеджері.  Автоматичне керування простором:\n   Android автоматично видаляє ці файли, коли додаток видаляється з пристрою.  Це зручно для зберігання даних, які не потребують постійного доступу або синхронізації з іншими додатками.  Використання для зберігання невеликих даних:\n   Ці методи зазвичай використовуються для збереження невеликих файлів, таких як налаштування, журнали або тимчасові файли, які не вимагають доступу ззовні.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":790,"path":791,"dir":667,"title":792,"description":793,"keywords":794,"body":795},"content:1.android:5.lesson5:12.work-with-files-2.md","/android/lesson5/work-with-files-2","Розміщення файлів у зовнішньому сховищі","У минулій темі ми розглянули збереження і читання файлів з каталогу додатка. За замовчуванням такі файли доступні тільки самому додатку. Однак ми можемо поміщати та працювати з файлами із зовнішнього сховища додатка. Це також дасть змогу іншим програмам відкривати ці файли та за потреби змінювати.",[],"  Розміщення файлів у зовнішньому сховищі  У минулій темі ми розглянули збереження і читання файлів з каталогу додатка. За замовчуванням такі файли доступні тільки самому додатку. Однак ми можемо поміщати та працювати з файлами із зовнішнього сховища додатка. Це також дасть змогу іншим програмам відкривати ці файли та за потреби змінювати.  Весь механізм роботи з файлами буде таким самим, як і під час роботи   зі сховищем додатка . Ключовою відмінністю тут буде отримання і використання шляху до зовнішнього сховища через метод   getExternalFilesDir()  класу   Context .  Отже, нехай у файлі   activity_main.xml  буде така ж розмітка інтерфейсу:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  EditText\n           android:id  =  \"@+id/editor\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           android:textSize  =  \"18sp\"\n           android:gravity  =  \"start\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/save_text\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n       \u003C  Button\n           android:id  =  \"@+id/save_text\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n    \n           android:onClick  =  \"saveText\"\n           android:text  =  \"Зберегти\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/text\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/editor\"   />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/text\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           android:gravity  =  \"start\"\n           android:textSize  =  \"18sp\"\n    \n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintBottom_toTopOf  =  \"@+id/open_text\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/save_text\"   />\n       \u003C  Button\n           android:id  =  \"@+id/open_text\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:onClick  =  \"openText\"\n           android:text  =  \"Відкрити\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/text\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  А код класу   MainActivity  матиме такий вигляд:     package   com.example.filesapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.EditText  ;\n   import   android.widget.TextView  ;\n   import   android.widget.Toast  ;\n    \n   import   java.io.File  ;\n   import   java.io.FileInputStream  ;\n   import   java.io.FileOutputStream  ;\n   import   java.io.IOException  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       private   final   static   String   FILE_NAME   =   \"document.txt\"  ;\n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n       private   File   getExternalPath  () {\n           return   new   File  (  getExternalFilesDir  (  null  ), FILE_NAME);\n       }\n       // збереження файлу\n       public   void   saveText  (  View   view  ){\n    \n           try  (  FileOutputStream   fos   =   new   FileOutputStream  (  getExternalPath  ())) {\n               EditText   textBox   =   findViewById  (R.id.editor);\n               String   text   =   textBox.  getText  ().  toString  ();\n               fos.  write  (text.  getBytes  ());\n               Toast.  makeText  (  this  ,   \"Файл сохранен\"  , Toast.LENGTH_SHORT).  show  ();\n           }\n           catch  (  IOException   ex  ) {\n    \n               Toast.  makeText  (  this  , ex.  getMessage  (), Toast.LENGTH_SHORT).  show  ();\n           }\n       }\n       // відкриття файлу\n       public   void   openText  (  View   view  ){\n            \n           TextView   textView   =   findViewById  (R.id.text);\n           File   file   =   getExternalPath  ();\n           // якщо файл не існує, вихід із методу\n           if  (  !  file.  exists  ())   return  ;\n           try  (  FileInputStream   fin   =    new   FileInputStream  (file)) {\n               byte  [] bytes   =   new   byte  [fin.  available  ()];\n               fin.  read  (bytes);\n               String   text   =   new   String   (bytes);\n               textView.  setText  (text);\n           }\n           catch  (  IOException   ex  ) {\n    \n               Toast.  makeText  (  this  , ex.  getMessage  (), Toast.LENGTH_SHORT).  show  ();\n           }\n       }\n   }\n  За допомогою виразу   getExternalFilesDir(null)  отримуємо доступ до папки додатка в зовнішньому сховищі та встановлюємо об'єкт файлу:     private   File   getExternalPath  () {\n       return   new   File  (  getExternalFilesDir  (  null  ), FILE_NAME);\n   }\n  Як параметр передається тип папки, але в цьому випадку він нам не важливий, тому передається значення   null  Усі інші дії щодо запису/читання файлу будуть такими ж, як і в попередній темі у випадку з роботою з локальною папкою файлу.\n  \nІ після операції запису на смартфоні через   Device File Explorer  ми зможемо побачити створений файл у папці   storage/self/primary/Android/data/[назва_пакета]/files :\n   html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":797,"path":798,"dir":667,"title":799,"description":800,"keywords":801,"body":809},"content:1.android:5.lesson5:13.media-store.md","/android/lesson5/media-store","MediaStore в Android","MediaStore — це системний інтерфейс Android, що дозволяє працювати з медіа-файлами на пристрої, такими як зображення, аудіо та відео. Він забезпечує доступ до медіа-контенту, що зберігається в зовнішньому або внутрішньому сховищі, а також дозволяє додавати нові медіа-файли в ці сховища.",[802,803,804,805,806,807,808],"Основи MediaStore","Доступ до медіа через MediaStore","Аудіо","Відео","Додавання зображень у MediaStore","Дозволи","Scoped Storage (Android 10 і вище)","  MediaStore в Android   MediaStore  — це системний інтерфейс Android, що дозволяє працювати з медіа-файлами на пристрої, такими як зображення, аудіо та відео. Він забезпечує доступ до медіа-контенту, що зберігається в зовнішньому або внутрішньому сховищі, а також дозволяє додавати нові медіа-файли в ці сховища.  Основи MediaStore  В Android MediaStore дозволяє вам взаємодіяти з медіа-файлами в кількох основних категоріях:    Зображення  — всі типи зображень, що зберігаються на пристрої.   Аудіо  — музика, звукові записи та інші аудіофайли.   Відео  — відеофайли.  Основні компоненти MediaStore:    MediaStore.Images : для роботи із зображеннями.   MediaStore.Audio : для роботи з аудіофайлами.   MediaStore.Video : для роботи з відеофайлами.  Підготовка до роботи з MediaStore  Для роботи з   MediaStore  на Android 10 (API рівень 29) і вище необхідно враховувати нові обмеження, такі як   Scoped Storage , яке обмежує доступ додатків до файлової системи пристрою. Це змушує використовувати спеціальні API для доступу до медіа-файлів.  Доступ до медіа через MediaStore  Зображення  Щоб отримати доступ до зображень, збережених на пристрої, можна використовувати   MediaStore.Images.Media.EXTERNAL_CONTENT_URI .  Отримання зображень із зовнішнього сховища:     public   void   getImages  () {\n       Uri   imageUri   =   MediaStore.Images.Media.EXTERNAL_CONTENT_URI;\n       String  [] projection   =   {MediaStore.Images.Media._ID, MediaStore.Images.Media.DISPLAY_NAME};\n       \n       // Використовуємо ContentResolver для отримання зображень\n       Cursor   cursor   =   getContentResolver  ().  query  (imageUri, projection,   null  ,   null  ,   null  );\n       \n       if   (cursor   !=   null  ) {\n           while   (cursor.  moveToNext  ()) {\n               int   idIndex   =   cursor.  getColumnIndex  (MediaStore.Images.Media._ID);\n               int   nameIndex   =   cursor.  getColumnIndex  (MediaStore.Images.Media.DISPLAY_NAME);\n               \n               String   id   =   cursor.  getString  (idIndex);\n               String   name   =   cursor.  getString  (nameIndex);\n               \n               // Тут можна обробляти інформацію про зображення\n               Log.  d  (  \"Image Info\"  ,   \"ID: \"   +   id   +   \" Name: \"   +   name);\n           }\n           cursor.  close  ();\n       }\n   }\n  Аудіо  Для роботи з аудіофайлами можна використовувати   MediaStore.Audio.Media.EXTERNAL_CONTENT_URI .  Отримання аудіофайлів:     public   void   getAudio  () {\n       Uri   audioUri   =   MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;\n       String  [] projection   =   {MediaStore.Audio.Media._ID, MediaStore.Audio.Media.DISPLAY_NAME};\n       \n       // Отримуємо дані про аудіофайли\n       Cursor   cursor   =   getContentResolver  ().  query  (audioUri, projection,   null  ,   null  ,   null  );\n       \n       if   (cursor   !=   null  ) {\n           while   (cursor.  moveToNext  ()) {\n               int   idIndex   =   cursor.  getColumnIndex  (MediaStore.Audio.Media._ID);\n               int   nameIndex   =   cursor.  getColumnIndex  (MediaStore.Audio.Media.DISPLAY_NAME);\n               \n               String   id   =   cursor.  getString  (idIndex);\n               String   name   =   cursor.  getString  (nameIndex);\n               \n               // Тут можна обробляти інформацію про аудіофайл\n               Log.  d  (  \"Audio Info\"  ,   \"ID: \"   +   id   +   \" Name: \"   +   name);\n           }\n           cursor.  close  ();\n       }\n   }\n  Відео  Для роботи з відеофайлами використовуємо   MediaStore.Video.Media.EXTERNAL_CONTENT_URI .  Отримання відеофайлів:     public   void   getVideo  () {\n       Uri   videoUri   =   MediaStore.Video.Media.EXTERNAL_CONTENT_URI;\n       String  [] projection   =   {MediaStore.Video.Media._ID, MediaStore.Video.Media.DISPLAY_NAME};\n       \n       // Отримуємо дані про відеофайли\n       Cursor   cursor   =   getContentResolver  ().  query  (videoUri, projection,   null  ,   null  ,   null  );\n       \n       if   (cursor   !=   null  ) {\n           while   (cursor.  moveToNext  ()) {\n               int   idIndex   =   cursor.  getColumnIndex  (MediaStore.Video.Media._ID);\n               int   nameIndex   =   cursor.  getColumnIndex  (MediaStore.Video.Media.DISPLAY_NAME);\n               \n               String   id   =   cursor.  getString  (idIndex);\n               String   name   =   cursor.  getString  (nameIndex);\n               \n               // Тут можна обробляти інформацію про відеофайл\n               Log.  d  (  \"Video Info\"  ,   \"ID: \"   +   id   +   \" Name: \"   +   name);\n           }\n           cursor.  close  ();\n       }\n   }\n  Додавання зображень у MediaStore  Щоб додати нове зображення до   MediaStore , можна використати методи класу   ContentResolver .  Додавання зображення:     public   void   addImageToGallery  (  File   imageFile) {\n       ContentValues   values   =   new   ContentValues  ();\n       values.  put  (MediaStore.Images.Media.TITLE, imageFile.  getName  ());\n       values.  put  (MediaStore.Images.Media.DISPLAY_NAME, imageFile.  getName  ());\n       values.  put  (MediaStore.Images.Media.MIME_TYPE,   \"image/jpeg\"  );\n       values.  put  (MediaStore.Images.Media.RELATIVE_PATH, Environment.DIRECTORY_PICTURES);\n   \n       Uri   uri   =   getContentResolver  ().  insert  (MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);\n       \n       try   (  OutputStream   outStream   =   getContentResolver  ().  openOutputStream  (uri)) {\n           FileInputStream   inStream   =   new   FileInputStream  (imageFile);\n           byte  [] buffer   =   new   byte  [  1024  ];\n           int   length;\n           while   ((length   =   inStream.  read  (buffer))   >   0  ) {\n               outStream.  write  (buffer,   0  , length);\n           }\n           inStream.  close  ();\n       }   catch   (  IOException   e  ) {\n           Log.  e  (  \"MediaStore\"  ,   \"Error writing file to MediaStore\"  , e);\n       }\n   }\n  Дозволи  Для доступу до медіа-файлів з зовнішнього сховища потрібно додавати дозволи у файл   AndroidManifest.xml . Наприклад, для Android 9 (API рівень 28) і нижче:     \u003C  uses-permission   android:name  =  \"android.permission.READ_EXTERNAL_STORAGE\"   />\n   \u003C  uses-permission   android:name  =  \"android.permission.WRITE_EXTERNAL_STORAGE\"   />\n  Scoped Storage (Android 10 і вище)  У Android 10 і вище, доступ до файлової системи став більш обмеженим через   Scoped Storage , що обмежує додаткам доступ до даних в системних каталогах.   Для зображень, аудіо та відео, збережених у публічному доступі (наприклад, в папці   Pictures ,   Music ,   Movies ), доступ можна отримати через   MediaStore .  Для доступу до більш специфічних файлів, наприклад, фотографій або відео, створених додатком, використовуються інші API, такі як   Storage Access Framework  (SAF).\nВажливі моменти:  Для запису нових медіа-файлів, таких як зображення чи відео, через   MediaStore , ваш додаток не потребує доступу до всього зовнішнього сховища, що забезпечує більшу безпеку.  Якщо ви хочете доступ до файлів, які зберігаються в інших частинах файлової системи або створені іншим додатком, вам може знадобитись запит дозволу через   Storage Access Framework  (SAF).  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":811,"path":812,"dir":813,"title":814,"description":7,"keywords":815,"body":817},"content:1.android:6.lesson6:1.intro-in-sqlite.md","/android/lesson6/intro-in-sqlite","lesson6","Підключення до бази даних SQLite",[816],"Створення та відкриття бази даних","  Підключення до бази даних SQLite    В Android є вбудована підтримка однієї з поширених систем керування базами даних - SQLite. Для цього в пакеті   android.database.sqlite  визначено набір класів, які дозволяють працювати з базами даних SQLite. І кожен додаток може створити свою базу даних.  Щоб використовувати SQLite в Android, потрібно створити базу даних за допомогою виразу на мові SQL. Після цього база даних буде зберігатися в каталозі додатка за шляхом:   DATA/data/[Назва_додатка]/databases/[Назва_файла_бази_даних]\n  ОС Android за замовчуванням вже містить ряд вбудованих баз даних SQLite, які використовуються стандартними програмами - для списку контактів, для зберігання фотографій з камери, музичних альбомів тощо.  Основну функціональність по роботі з базами даних надає пакет   android.database . Функціональність безпосередньо для роботи з SQLite знаходиться в пакеті   android.database.sqlite .  База даних в SQLite представлена класом   android.database.sqlite.SQLiteDatabase . Він дозволяє виконувати запити до бази даних, виконувати з нею різні маніпуляції.  Клас   android.database.sqlite.SQLiteCursor  надає запит і дозволяє повертати набір рядків, які відповідають цьому запиту.  Клас   android.database.sqlite.SQLiteQueryBuilder  дозволяє створювати SQL-запити.  Самі SQL-вирази представлені класом   android.database.sqlite.SQLiteStatement , які дозволяють з допомогою плейсхолдерів вставляти в вирази динамічні дані.  Клас   android.database.sqlite.SQLiteOpenHelper  дозволяє створити базу даних з усіма таблицями, якщо їх ще не існує.  В SQLite застосовується наступна система типів даних:    INTEGER : представляє ціле число, аналог типу   int  в Java   REAL : представляє число з плаваючою точкою, аналог   float  та   double  в Java   TEXT : представляє набір символів, аналог   String  та   char  в Java   BLOB : представляє масив бінарних даних, наприклад, зображення, аналог типу   int  в Java  Збережені дані повинні відповідати відповідним типам у Java.  Створення та відкриття бази даних  Для створення або відкриття нової бази даних з коду   Activity  в Android ми можемо викликати метод   openOrCreateDatabase() . Цей метод може приймати три параметри:   назва для бази даних  числове значення, яке визначає режим роботи (як правило, у вигляді константи   MODE_PRIVATE )  необов'язковий параметр у вигляді об'єкта   SQLiteDatabase.CursorFactory , який представляє фабрику створення курсора для роботи з базою даних  Наприклад, створення бази даних   app.db :     SQLiteDatabase   db   =   getBaseContext  ().  openOrCreateDatabase  (  \"app.db\"  , MODE_PRIVATE,   null  );\n  Для виконання запиту до бази даних можна використовувати метод   execSQL  класу   SQLiteDatabase . В цей метод передається SQL-вираз. Наприклад, створення в базі даних таблиці   users :     SQLiteDatabase   db   =   getBaseContext  ().  openOrCreateDatabase  (  \"app.db\"  , MODE_PRIVATE,   null  );\n   db.  execSQL  (  \"CREATE TABLE IF NOT EXISTS users (name TEXT, age INTEGER)\"  );\n  Якщо нам треба не просто виконати вираз, а й отримати з бази даних якісь дані, то використовується метод   rawQuery() . Цей метод як параметр приймає SQL-вираз, а також набір значень для виразу SQL. Наприклад, отримання всіх об'єктів з бази даних:     SQLiteDatabase   db   =   getBaseContext  ().  openOrCreateDatabase  (  \"app.db\"  , MODE_PRIVATE,   null  );\n   db.  execSQL  (  \"CREATE TABLE IF NOT EXISTS users (name TEXT, age INTEGER)\"  );\n   Cursor   query   =   db.  rawQuery  (  \"SELECT * FROM users;\"  ,   null  );\n   if  (query.  moveToFirst  ()){\n        \n       String   name   =   query.  getString  (  0  );\n       int   age   =   query.  getInt  (  1  );\n   }\n  Метод   db.rawQuery()  повертає об'єкт   Cursor , за допомогою якого ми можемо витягнути отримані дані.  Можлива ситуація, коли в базі даних не буде об'єктів, і для цього методом   query.moveToFirst()  намагаємося переміститися до першого об'єкта, отриманого з бази даних. Якщо цей метод поверне значення   false , це означає, що запит не отримав жодних даних з бази даних.  Тепер для роботи з базою даних створимо найпростіший додаток. Для цього створимо новий проект.  У файлі   activity_main.xml  визначимо найпростіший графічний інтерфейс:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"   >\n    \n       \u003C  Button\n           android:id  =  \"@+id/button\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Click\"\n           android:onClick  =  \"onClick\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/textView\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           />\n       \u003C  TextView\n           android:id  =  \"@+id/textView\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"22sp\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/button\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"  />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  А в класі   MainActivity  визначимо взаємодію з базою даних:     package   com.example.sqliteapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.database.Cursor  ;\n   import   android.database.sqlite.SQLiteDatabase  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n       public   void   onClick  (  View   view  ){\n           SQLiteDatabase   db   =   getBaseContext  ().  openOrCreateDatabase  (  \"app.db\"  , MODE_PRIVATE,   null  );\n           db.  execSQL  (  \"CREATE TABLE IF NOT EXISTS users (name TEXT, age INTEGER, UNIQUE(name))\"  );\n           db.  execSQL  (  \"INSERT OR IGNORE INTO users VALUES ('Tom Smith', 23), ('John Dow', 31);\"  );\n    \n           Cursor   query   =   db.  rawQuery  (  \"SELECT * FROM users;\"  ,   null  );\n           TextView   textView   =   findViewById  (R.id.textView);\n           textView.  setText  (  \"\"  );\n           while  (query.  moveToNext  ()){\n               String   name   =   query.  getString  (  0  );\n               int   age   =   query.  getInt  (  1  );\n               textView.  append  (  \"Name: \"   +   name   +   \" Age: \"   +   age   +   \"  \\n  \"  );\n           }\n           query.  close  ();\n           db.  close  ();\n       }\n   }\n  По натисканню на кнопку тут спочатку створюється в базі даних   app.db  нова таблиця   users , а потім в неї додаються два об'єкти в базу даних за допомогою SQL-виразу   INSERT .  Далі з допомогою виразу   SELECT  отримуємо всіх доданих користувачів з бази даних у вигляді курсора   Cursor .  Викликом   query.moveToNext()  переміщаємося в циклі   while  послідовно по всіх об'єктах.  Для отримання даних з курсора застосовуються методи   query.getString(0)  та   query.getInt(1) . У дужках в методи передається номер стовпця, з якого ми отримуємо дані. Наприклад, вище ми додали спочатку ім'я користувача у вигляді рядка, а потім вік у вигляді числа. Тому нульовим стовпцем буде рядкове значення, яке отримуємо за допомогою методу   getString() , а наступним - першим стовпцем буде числове значення, для якого застосовується метод   getInt() .  Після завершення роботи з курсором і базою даних ми закриваємо всі пов'язані об'єкти:     query.  close  ();\n   db.  close  ();\n  Якщо ми не закриємо курсор, то можемо зіткнутися з проблемою витоку пам'яті.  І якщо ми звернемося до додатка, то після натискання на кнопку в текстове поле буде виведено додані дані:\n   html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":819,"path":820,"dir":813,"title":821,"description":822,"keywords":823,"body":826},"content:1.android:6.lesson6:2.data-select.md","/android/lesson6/data-select","SQLiteOpenHelper і SimpleCursorAdapter, отримання даних із SQLite","В попередній темі було розглянуто, як підключатися до бази даних SQLite та виконувати запити. Тепер рухаємося далі і створимо повністю інтерфейс для роботи з базою даних.",[824,825],"Отримання даних і Cursor","CursorAdapter","  SQLiteOpenHelper і SimpleCursorAdapter, отримання даних із SQLite  В попередній темі було розглянуто, як підключатися до бази даних SQLite та виконувати запити. Тепер рухаємося далі і створимо повністю інтерфейс для роботи з базою даних.  Отже, створимо новий проєкт.  Для спрощення роботи з базами даних SQLite в Android часто використовується клас   SQLiteOpenHelper . Для використання необхідно створити клас-наслідник від   SQLiteOpenHelper , перевизначивши як мінімум два його методи:    onCreate() : викликається при спробі доступу до бази даних, але коли ще ця база даних не створена   onUpgrade() : викликається, коли необхідне оновлення схеми бази даних. Тут можна пересоздати раніше створену базу даних в   onCreate() , встановивши відповідні правила перетворення від старої БД до нової  Тому додамо в проєкт, у ту ж папку, де знаходиться клас   MainActivity , новий клас   DatabaseHelper :\n      package   com.example.sqliteapp  ;\n    \n   import   android.database.sqlite.SQLiteOpenHelper  ;\n   import   android.database.sqlite.SQLiteDatabase  ;\n   import   android.content.Context  ;\n    \n   public   class   DatabaseHelper   extends   SQLiteOpenHelper   {\n       private   static   final   String   DATABASE_NAME   =   \"userstore.db\"  ;   // назва бд\n       private   static   final   int   SCHEMA   =   1  ;   // версія бази даних\n       static   final   String   TABLE   =   \"users\"  ;   // назва таблиці в бд\n       // назви стовпців\n       public   static   final   String   COLUMN_ID   =   \"_id\"  ;\n       public   static   final   String   COLUMN_NAME   =   \"name\"  ;\n       public   static   final   String   COLUMN_YEAR   =   \"year\"  ;\n    \n       public   DatabaseHelper  (  Context   context  ) {\n           super  (context, DATABASE_NAME,   null  , SCHEMA);\n       }\n    \n       @  Override\n       public   void   onCreate  (  SQLiteDatabase   db  ) {\n    \n           db.  execSQL  (  \"CREATE TABLE users (\"   +   COLUMN_ID\n                   +   \" INTEGER PRIMARY KEY AUTOINCREMENT,\"   +   COLUMN_NAME\n                   +   \" TEXT, \"   +   COLUMN_YEAR   +   \" INTEGER);\"  );\n           // додавання початкових даних\n           db.  execSQL  (  \"INSERT INTO \"  +   TABLE   +  \" (\"   +   COLUMN_NAME\n                   +   \", \"   +   COLUMN_YEAR    +   \") VALUES ('Том Смит', 1981);\"  );\n       }\n       @  Override\n       public   void   onUpgrade  (  SQLiteDatabase   db  ,   int   oldVersion  ,    int   newVersion  ) {\n           db.  execSQL  (  \"DROP TABLE IF EXISTS \"   +   TABLE);\n           onCreate  (db);\n       }\n   }\n  Якщо база даних відсутня або її версія (яка задається в змінній   SCHEMA ) вища за поточну, то спрацьовує метод   onCreate() .  Для виконання запитів до бази даних нам знадобиться об'єкт   SQLiteDatabase , який представляє базу даних. Метод   onCreate()  отримує як параметр базу даних додатку.  Для виконання запитів до SQLite використовується метод   execSQL() . Він приймає SQL-вираз   CREATE TABLE , який створює таблицю. Тут також, при необхідності, ми можемо виконати й інші запити, наприклад, додати якісь початкові дані. Так, у цьому випадку за допомогою того ж методу та виразу SQL   INSERT  додається один об'єкт у таблицю.  У методі   onUpgrade()  відбувається оновлення схеми БД. У цьому випадку для прикладу використано примітивний підхід з видаленням попередньої бази даних за допомогою SQL-виразу   DROP  та наступним її створенням. Але в реальності, якщо вам буде необхідно зберегти дані, цей метод може включати складнішу логіку - додавання нових стовпців, видалення непотрібних, додавання додаткових даних тощо.  Далі визначимо у файлі   activity_main.xml  таку розмітку:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"\n       android:padding  =  \"16dp\"  >\n    \n       \u003C  TextView\n           android:id  =  \"@+id/header\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"18sp\"\n           app:layout_constraintBottom_toTopOf  =  \"@+id/list\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           />\n       \u003C  ListView\n           android:id  =  \"@+id/list\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/header\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"  />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Тут визначено список   ListView , для відображення отриманих даних, із заголовком, який виводитиме число отриманих об'єктів.  І змінимо код класу   MainActivity  таким чином:     package   com.example.sqliteapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   android.widget.SimpleCursorAdapter  ;\n   import   android.database.Cursor  ;\n   import   android.database.sqlite.SQLiteDatabase  ;\n   import   android.os.Bundle  ;\n   import   android.widget.ListView  ;\n   import   android.widget.TextView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       ListView   userList;\n       TextView   header;\n       DatabaseHelper   databaseHelper;\n       SQLiteDatabase   db;\n       Cursor   userCursor;\n       SimpleCursorAdapter   userAdapter;\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           header   =   findViewById  (R.id.header);\n           userList   =   findViewById  (R.id.list);\n    \n           databaseHelper   =   new   DatabaseHelper  (  getApplicationContext  ());\n       }\n       @  Override\n       public   void   onResume  () {\n           super  .  onResume  ();\n           // відкриваємо підключення\n           db   =   databaseHelper.  getReadableDatabase  ();\n    \n           // отримуємо дані з бд у вигляді курсора\n           userCursor   =    db.  rawQuery  (  \"select * from \"  +   DatabaseHelper.TABLE,   null  );\n           // визначаємо, які стовпці з курсору будуть виводитися в ListView\n           String  [] headers   =   new   String  [] {DatabaseHelper.COLUMN_NAME, DatabaseHelper.COLUMN_YEAR};\n           // створюємо адаптер, передаємо в нього курсор\n           userAdapter   =   new   SimpleCursorAdapter  (  this  , android.R.layout.two_line_list_item,\n                   userCursor, headers,   new   int  [] {android.R.id.text1, android.R.id.text2},   0  );\n           header.  setText  (  \"Знайдено елементів: \"   +    userCursor.  getCount  ());\n           userList.  setAdapter  (userAdapter);\n       }\n    \n       @  Override\n       public   void   onDestroy  (){\n           super  .  onDestroy  ();\n           // Закриваємо підключення і курсор\n           db.  close  ();\n           userCursor.  close  ();\n       }\n   }\n  В методі   onCreate()  відбувається створення об'єкта   SQLiteOpenHelper . Ініціалізація об'єктів для роботи з базою даних відбувається в методі   onResume() , який спрацьовує після методу   onCreate() .  Щоб отримати об'єкт бази даних, треба використовувати метод   getReadableDatabase()  (отримання бази даних для читання) або   getWritableDatabase() . Оскільки в даному випадку ми будемо лише зчитувати дані з БД, то скористаємося першим методом:     db   =   sqlHelper.  getReadableDatabase  ();\n  Отримання даних і Cursor  Android надає різні способи для здійснення запитів до об'єкта   SQLiteDatabase . У більшості випадків ми можемо використовувати метод   rawQuery() , який приймає два параметри: SQL-вираз   SELECT  та додатковий параметр, що задає параметри запиту.  Після виконання запиту   rawQuery()  повертає об'єкт   Cursor , який зберігає результат виконання SQL-запиту:     userCursor   =    db.  rawQuery  (  \"select * from \"  +   DatabaseHelper.TABLE,   null  );\n  Клас   Cursor  пропонує ряд методів для керування вибіркою, зокрема:    getCount() : отримує кількість витягнутих з бази даних об'єктів  Методи   moveToFirst()  і   moveToNext()  дозволяють переходити до першого та наступного елементів вибірки. Метод   isAfterLast()  дозволяє перевірити, чи досягнуто кінець вибірки.  Методи   get*(columnIndex)  (наприклад,   getLong() ,   getString() ) дозволяють по індексу стовпця звертатися до даного стовпця поточного рядка.  CursorAdapter  Додатково для керування курсором в Android є клас   CursorAdapter . Він дозволяє адаптувати отриманий за допомогою курсора набір до відображення в спискових елементах на зразок   ListView . Як правило, при роботі з курсором використовується підклас   CursorAdapter  —   SimpleCursorAdapter . Хоча можна використовувати й інші адаптери, наприклад,   ArrayAdapter .     userAdapter   =   new   SimpleCursorAdapter  (  this  , android.R.layout.two_line_list_item,\n                   userCursor, headers,   new   int  []{android.R.id.text1, android.R.id.text2},   0  );\n   userList.  setAdapter  (userAdapter);\n  Конструктор класу   SimpleCursorAdapter  приймає шість параметрів:   Першим параметром виступає контекст, з яким асоціюється адаптер, наприклад, поточна activity.  Другий параметр — ресурс розмітки інтерфейсу, який буде використовуватися для відображення результатів вибірки.  Третій параметр — курсор.  Четвертий параметр — список стовпців з вибірки, які будуть відображатися в розмітці інтерфейсу.  П'ятий параметр — елементи всередині ресурсу розмітки, які будуть відображати значення стовпців з четвертого параметра.  Шостий параметр — флаги, що задають поведінку адаптера.  При використанні   CursorAdapter  і його підкласів слід враховувати, що вибірка курсора повинна включати цілочисельний стовпець з назвою   _id , який має бути унікальним для кожного елемента вибірки. Значення цього стовпця при натисканні на елемент списку потім передається в метод обробки   onListItemClick() , завдяки чому ми можемо по id ідентифікувати натиснутий елемент.  У даному випадку у нас перший стовпець якраз називається \"_id\".  Після завершення роботи з курсором він має бути закритий методом   close() .  Також треба враховувати, що якщо ми використовуємо курсор у   SimpleCursorAdapter , то не можемо використовувати метод   close() , поки не завершим використання   SimpleCursorAdapter . Тому метод   cursor  більш доцільно викликати в методі   onDestroy()  фрагмента або activity.  І якщо ми запустимо додаток, то побачимо список з одного доданого елемента:\n   html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":828,"path":829,"dir":813,"title":830,"description":831,"keywords":832,"body":834},"content:1.android:6.lesson6:3.crud.md","/android/lesson6/crud","Додавання, видалення та оновлення даних у SQLite","Продовжимо роботу з проєктом із минулої теми, де ми отримуємо дані. Тепер додамо в нього стандартну CRUD-логіку (створення, оновлення, видалення).",[833],"ContentValues","  Додавання, видалення та оновлення даних у SQLite  Продовжимо роботу з проєктом із минулої теми, де ми отримуємо дані. Тепер додамо в нього стандартну CRUD-логіку (створення, оновлення, видалення).  Щоб не нагромаджувати форму з головною activity, всі інші дії по роботі з даними відбуватимуться на іншому екрані. Додамо в проєкт новий клас activity, який назвемо   UserActivity :\n   У файлі   activity_user.xml  визначимо універсальну форму для додавання/оновлення/видалення даних:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n       \u003C  EditText\n           android:id  =  \"@+id/name\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:hint  =  \"Введіть ім'я\"\n           app:layout_constraintBottom_toTopOf  =  \"@+id/year\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"   />\n       \u003C  EditText\n           android:id  =  \"@+id/year\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:hint  =  \"Введіть рік народження\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/name\"\n           app:layout_constraintBottom_toTopOf  =  \"@+id/saveButton\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"   />\n       \u003C  Button\n           android:id  =  \"@+id/saveButton\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Зберегти\"\n           android:onClick  =  \"save\"\n           app:layout_constraintHorizontal_weight  =  \"1\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/year\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toLeftOf  =  \"@+id/deleteButton\"\n           />\n       \u003C  Button\n           android:id  =  \"@+id/deleteButton\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Видалити\"\n           android:onClick  =  \"delete\"\n           app:layout_constraintHorizontal_weight  =  \"1\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/year\"\n           app:layout_constraintLeft_toRightOf  =  \"@+id/saveButton\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           />\n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  І також змінимо код   UserActivity :     package   com.example.sqliteapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.content.ContentValues  ;\n   import   android.content.Intent  ;\n   import   android.database.Cursor  ;\n   import   android.database.sqlite.SQLiteDatabase  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.Button  ;\n   import   android.widget.EditText  ;\n    \n   public   class   UserActivity   extends   AppCompatActivity   {\n    \n       EditText   nameBox;\n       EditText   yearBox;\n       Button   delButton;\n       Button   saveButton;\n    \n       DatabaseHelper   sqlHelper;\n       SQLiteDatabase   db;\n       Cursor   userCursor;\n       long   userId   =   0  ;\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_user);\n    \n           nameBox   =   findViewById  (R.id.name);\n           yearBox   =   findViewById  (R.id.year);\n           delButton   =   findViewById  (R.id.deleteButton);\n           saveButton   =   findViewById  (R.id.saveButton);\n    \n           sqlHelper   =   new   DatabaseHelper  (  this  );\n           db   =   sqlHelper.  getWritableDatabase  ();\n    \n           Bundle   extras   =   getIntent  ().  getExtras  ();\n           if   (extras   !=   null  ) {\n               userId   =   extras.  getLong  (  \"id\"  );\n           }\n           // якщо 0, то додавання\n           if   (userId   >   0  ) {\n               // отримуємо елемент за id із бд\n               userCursor   =   db.  rawQuery  (  \"select * from \"   +   DatabaseHelper.TABLE   +   \" where \"   +\n                       DatabaseHelper.COLUMN_ID   +   \"=?\"  ,   new   String  []{String.  valueOf  (userId)});\n               userCursor.  moveToFirst  ();\n               nameBox.  setText  (userCursor.  getString  (  1  ));\n               yearBox.  setText  (String.  valueOf  (userCursor.  getInt  (  2  )));\n               userCursor.  close  ();\n           }   else   {\n               // приховуємо кнопку видалення\n               delButton.  setVisibility  (View.GONE);\n           }\n       }\n    \n       public   void   save  (  View   view  ) {\n           ContentValues   cv   =   new   ContentValues  ();\n           cv.  put  (DatabaseHelper.COLUMN_NAME, nameBox.  getText  ().  toString  ());\n           cv.  put  (DatabaseHelper.COLUMN_YEAR, Integer.  parseInt  (yearBox.  getText  ().  toString  ()));\n    \n           if   (userId   >   0  ) {\n               db.  update  (DatabaseHelper.TABLE, cv, DatabaseHelper.COLUMN_ID   +   \"=\"   +   userId,   null  );\n           }   else   {\n               db.  insert  (DatabaseHelper.TABLE,   null  , cv);\n           }\n           goHome  ();\n       }\n   \n       public   void   delete  (  View   view  ) {\n           db.  delete  (DatabaseHelper.TABLE,   \"_id = ?\"  ,   new   String  []{String.  valueOf  (userId)});\n           goHome  ();\n       }\n   \n       private   void   goHome  () {\n           // закрываем подключение\n           db.  close  ();\n           // переход к главной activity\n           Intent   intent   =   new   Intent  (  this  , MainActivity.class);\n           intent.  addFlags  (Intent.FLAG_ACTIVITY_CLEAR_TOP   |   Intent.FLAG_ACTIVITY_SINGLE_TOP);\n           startActivity  (intent);\n       }\n   }\n  Під час оновлення або видалення об'єкта зі списку з головної activity в   UserActivity  передаватиметься   id  об'єкта:     long   userId  =  0  ;\n   //.................\n   Bundle   extras   =   getIntent  ().  getExtras  ();\n   if   (extras   !=   null  ) {\n       userId   =   extras.  getLong  (  \"id\"  );\n   }\n  Якщо з   MainActivity  не було передано   id , то встановлюємо його значення   0 , отже, у нас буде додавання, а не редагування/видалення  Якщо   id  визначено, то отримуємо за ним із бази даних об'єкт для редагування/видалення:     if   (id   \u003C   0  ) {\n            \n       userCursor   =   db.  rawQuery  (  \"select * from \"   +   DatabaseHelper.TABLE   +   \" where \"   +\n               DatabaseHelper.COLUMN_ID   +   \"=?\"  ,   new   String  []{String.  valueOf  (id)});\n       userCursor.  moveToFirst  ();\n       nameBox.  setText  (userCursor.  getString  (  1  ));\n       yearBox.  setText  (String.  valueOf  (userCursor.  getInt  (  2  )));\n       userCursor.  close  ();\n   }\n  Інакше просто приховуємо кнопку видалення.  Для виконання операцій по вставці, оновленню та видаленню даних   SQLiteDatabase  має методи   insert() ,   update()  і   delete() . Ці методи викликаються в обробниках кнопок:     db.  delete  (DatabaseHelper.TABLE,   \"_id = ?\"  ,   new   String  []{String.  valueOf  (id)});\n  У метод   delete()  передається назва таблиці, а також стовпець, за яким відбувається видалення, і його значення. Як критерій можна вибрати кілька стовпців, тому третім параметром йде масив. Знак питання   ?  позначає параметр, замість якого підставляється значення з третього параметра.  ContentValues  Для додавання або оновлення нам треба створити об'єкт   ContentValues . Цей об'єкт представляє собою словник, який містить набір пар \"ключ-значення\". Для додавання в цей словник нового об'єкта застосовується метод   put . Перший параметр методу — це ключ, а другий — значення, наприклад:     ContentValues   cv   =   new   ContentValues  ();\n   cv.  put  (  \"NAME\"  ,   \"Tom\"  );\n   cv.  put  (  \"YEAR\"  ,   30  );\n  Як значення в метод   put  можна передавати рядки, цілі числа, числа з плаваючою точкою.  У цьому ж випадку додаються введені в текстові поля значення:     ContentValues   cv   =   new   ContentValues  ();\n   cv.  put  (DatabaseHelper.COLUMN_NAME, nameBox.  getText  ().  toString  ());\n   cv.  put  (DatabaseHelper.COLUMN_YEAR, Integer.  parseInt  (yearBox.  getText  ().  toString  ()));\n  При оновленні в метод   update()  передається назва таблиці, об'єкт   ContentValues  та критерій, за яким відбувається оновлення (в даному випадку стовпець   id ):     db.  update  (DatabaseHelper.TABLE, cv, DatabaseHelper.COLUMN_ID   +   \"=\"   +   userId,   null  );\n  Метод   insert()  приймає назву таблиці, об'єкт   ContentValues  з додаваними значеннями. Другий параметр є необов'язковим: він передає стовпець, у який треба додати значення   NULL :     db.  insert  (DatabaseHelper.TABLE,   null  , cv);\n  Замість цих методів, як у попередній темі, можна використовувати метод   execSQL()  з точним вказуванням виконуваного SQL-виразу. Водночас методи   delete/insert/update  мають перевагу — вони повертають   id  зміненої записи, за яким ми можемо дізнатися про успішність операції, або   -1  у разі невдалої операції:     long   result   =   db.  insert  (DatabaseHelper.TABLE,   null  , cv);\n   if  (result   >   0  ){\n    \n       // дії\n   }\n  Після кожної операції виконується метод   goHome() , який повертає на головну activity.  Після цього нам треба виправити код   MainActivity , щоб вона ініціювала виконання коду в   UserActivity . Для цього змінимо код   activity_main.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  Button\n           android:id  =  \"@+id/addButton\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"18sp\"\n           android:text  =  \"Додати\"\n           android:onClick  =  \"add\"\n           app:layout_constraintBottom_toTopOf  =  \"@+id/list\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           />\n       \u003C  ListView\n           android:id  =  \"@+id/list\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/addButton\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"  />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  У цьому випадку було додано кнопку для виклику   UserActivity .  І також змінимо код класу   MainActivity :     package   com.example.sqliteapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.content.Intent  ;\n   import   android.view.View  ;\n   import   android.widget.AdapterView  ;\n   import   android.widget.SimpleCursorAdapter  ;\n   import   android.database.Cursor  ;\n   import   android.database.sqlite.SQLiteDatabase  ;\n   import   android.os.Bundle  ;\n   import   android.widget.ListView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       ListView   userList;\n       DatabaseHelper   databaseHelper;\n       SQLiteDatabase   db;\n       Cursor   userCursor;\n       SimpleCursorAdapter   userAdapter;\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           userList   =   findViewById  (R.id.list);\n           userList.  setOnItemClickListener  (  new   AdapterView.  OnItemClickListener  () {\n               @  Override\n               public   void   onItemClick  (  AdapterView  \u003C?>   parent,   View   view,   int   position,   long   id) {\n                   Intent   intent   =   new   Intent  (  getApplicationContext  (), UserActivity.class);\n                   intent.  putExtra  (  \"id\"  , id);\n                   startActivity  (intent);\n               }\n           });\n    \n           databaseHelper   =   new   DatabaseHelper  (  getApplicationContext  ());\n       }\n    \n       @  Override\n       public   void   onResume  () {\n           super  .  onResume  ();\n           // відкриваємо підключення\n           db   =   databaseHelper.  getReadableDatabase  ();\n    \n           // отримуємо дані з бд у вигляді курсора\n           userCursor   =   db.  rawQuery  (  \"select * from \"   +   DatabaseHelper.TABLE,   null  );\n           // визначаємо, які стовпці з курсору будуть виводитися в ListView\n           String  [] headers   =   new   String  []{DatabaseHelper.COLUMN_NAME, DatabaseHelper.COLUMN_YEAR};\n           // створюємо адаптер, передаємо в нього курсор\n           userAdapter   =   new   SimpleCursorAdapter  (  this  , android.R.layout.two_line_list_item,\n                   userCursor, headers,   new   int  []{android.R.id.text1, android.R.id.text2},   0  );\n           userList.  setAdapter  (userAdapter);\n       }\n    \n       // після натискання на кнопку запускаємо UserActivity для додавання даних\n       public   void   add  (  View   view  ) {\n           Intent   intent   =   new   Intent  (  this  , UserActivity.class);\n           startActivity  (intent);\n       }\n    \n       @  Override\n       public   void   onDestroy  () {\n           super  .  onDestroy  ();\n           // Закриваємо підключення і курсор\n           db.  close  ();\n           userCursor.  close  ();\n       }\n   }\n  При натисканні на кнопку запускається   UserActivity , при цьому не передається жодного   id , тобто в   UserActivity    id  буде рівним нулю, що означає, що буде виконуватися додавання даних:     public   void   add  (  View   view){\n       Intent   intent   =   new   Intent  (  this  , UserActivity.class);\n       startActivity  (intent);\n   }\n  Інша ситуація виникає при обробнику натискання на елемент списку — при натисканні також запускається   UserActivity , але тепер передається   id  вибраної запису:     public   void   onItemClick  (  AdapterView  \u003C?>   parent,   View   view,   int   position,   long   id) {\n       Intent   intent   =   new   Intent  (  getApplicationContext  (), UserActivity.class);\n       intent.  putExtra  (  \"id\"  , id);\n       startActivity  (intent);\n   }\n  Запустимо додаток і натиснемо на кнопку, яка повинна перенаправляти на   UserActivity :    Під час натискання в   MainActivity  на елемент списку цей елемент потрапить на   UserActivity , де його можна буде видалити або підредагувати:    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":836,"path":837,"dir":813,"title":838,"description":839,"keywords":840,"body":841},"content:1.android:6.lesson6:4.existing-db.md","/android/lesson6/existing-db","Використання наявної БД SQLite","Крім створення нової бази даних ми також можемо використовувати вже наявну. Це може бути більш переважним, тому що в цьому випадку база даних додатка вже міститиме всю необхідну інформацію.",[],"  Використання наявної БД SQLite  Крім створення нової бази даних ми також можемо використовувати вже наявну. Це може бути більш переважним, тому що в цьому випадку база даних додатка вже міститиме всю необхідну інформацію.  Візьмемо проєкт, створений у попередній темі, де ми мали   MainActivity , що виводила список об'єктів, і   UserActivity , що давала змогу додавати, редагувати та видаляти об'єкти з БД.\n   Для початку створимо базу даних SQLite. У цьому нам може допомогти такий інструмент як Sqlitebrowser. Він безкоштовний і доступний для різних операційних систем за адресою   https://sqlitebrowser.org/ . Хоча можна використовувати й інші способи для створення початкової БД. Краще -   tableplus .  Sqlitebrowser представляє графічний інтерфейс для створення бази даних і визначення в ній усіх необхідних таблиць:\n  \nЯк видно на скріншоті, я визначаю таблицю   users  із трьома полями:   _id ,   name ,   age . Загальна команда на створення таблиці буде такою:     CREATE   TABLE   `  users  ` (\n       `_id`     INTEGER   NOT NULL   PRIMARY KEY   AUTOINCREMENT   UNIQUE  ,\n       `name`    TEXT   NOT NULL  ,\n       `year`    INTEGER   NOT NULL\n   );\n  Там же в програмі додамо кілька елементів у створену таблицю:\n   Після створення таблиці додамо в проєкт в Android Studio папку assets, а в папку   assets  - щойно створену базу даних. Для цього перейдемо до повного визначення проєкту, натиснемо на папку main правою кнопкою миші і в меню виберемо   New -> Directory :\n  \nПотім у віконці, що з'явилося, виберемо пункт   src\\main\\assets  і натиснемо на Enter для її додавання в проєкт:\n  \nІ потім скопіюємо в неї нашу базу даних:\n  \nУ моєму випадку база даних називається   \"cityinfo.db\" .  Змінимо код   DatabaseHelper  таким чином:     package   com.example.sqliteapp  ;\n    \n   import   android.database.SQLException  ;\n   import   android.database.sqlite.SQLiteOpenHelper  ;\n   import   android.database.sqlite.SQLiteDatabase  ;\n   import   android.content.Context  ;\n   import   android.util.Log  ;\n    \n   import   java.io.File  ;\n   import   java.io.FileOutputStream  ;\n   import   java.io.IOException  ;\n   import   java.io.InputStream  ;\n   import   java.io.OutputStream  ;\n    \n   class   DatabaseHelper   extends   SQLiteOpenHelper   {\n       private   static   String   DB_PATH;   // повний шлях до бази даних\n       private   static   String   DB_NAME   =   \"cityinfo.db\"  ;\n       private   static   final   int   SCHEMA   =   1  ;   // версія бази даних\n       static   final   String   TABLE   =   \"users\"  ;   // назва таблиці в бд\n       // назви стовпців\n       static   final   String   COLUMN_ID   =   \"_id\"  ;\n       static   final   String   COLUMN_NAME   =   \"name\"  ;\n       static   final   String   COLUMN_YEAR   =   \"year\"  ;\n   \n       private   Context   myContext;\n    \n       DatabaseHelper  (  Context   context  ) {\n           super  (context, DB_NAME,   null  , SCHEMA);\n           this  .myContext  =  context;\n           DB_PATH   =  context.  getFilesDir  ().  getPath  ()   +   DB_NAME;\n       }\n    \n       @  Override\n       public   void   onCreate  (  SQLiteDatabase   db  ) { }\n   \n       @  Override\n       public   void   onUpgrade  (  SQLiteDatabase   db  ,   int   oldVersion  ,    int   newVersion  ) { }\n    \n       void   create_db  (){\n    \n           File   file   =   new   File  (DB_PATH);\n           if   (  !  file.  exists  ()) {\n               // отримуємо локальну бд як потік\n               try  (  InputStream   myInput   =   myContext.  getAssets  ().  open  (DB_NAME);\n                   // Відкриваємо порожню бд\n                   OutputStream   myOutput   =   new   FileOutputStream  (DB_PATH)) {\n    \n                   // побайтово копіюємо дані\n                   byte  [] buffer   =   new   byte  [  1024  ];\n                   int   length;\n                   while   ((length   =   myInput.  read  (buffer))   >   0  ) {\n                       myOutput.  write  (buffer,   0  , length);\n                   }\n                   myOutput.  flush  ();\n               }\n               catch  (  IOException   ex  ){\n                   Log.  d  (  \"DatabaseHelper\"  , ex.  getMessage  ());\n               }\n           }\n       }\n       public   SQLiteDatabase   open  ()  throws   SQLException   {\n    \n           return   SQLiteDatabase.  openDatabase  (DB_PATH,   null  , SQLiteDatabase.OPEN_READWRITE);\n       }\n   }\n  За замовчуванням база даних буде розміщуватися у зовнішньому сховищі, виділеному для додатку в папці   /data/data/[назва_пакета]/databases/ , і щоб отримати повний шлях до бази даних, у конструкторі використовується вираз:     DB_PATH   =   context.  getFilesDir  ().  getPath  ()   +   DB_NAME;\n  Метод   onCreate()  нам не потрібен, оскільки нам не потрібно створення вбудованої бази даних. Замість цього тут визначений додатковий метод   create_db() , мета якого — копіювання бази даних з папки   assets  в те місце, яке вказано в змінній   DB_PATH .  Окрім того, тут також визначений метод відкриття бази даних   open()  за допомогою методу   SQLiteDatabase.openDatabase() .  Новий спосіб організації підключення змінить використання   DatabaseHelper  в activity. Так, оновимо клас   MainActivity :     package   com.example.sqliteapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.content.Intent  ;\n   import   android.view.View  ;\n   import   android.widget.AdapterView  ;\n   import   android.widget.SimpleCursorAdapter  ;\n   import   android.database.Cursor  ;\n   import   android.database.sqlite.SQLiteDatabase  ;\n   import   android.os.Bundle  ;\n   import   android.widget.ListView  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       ListView   userList;\n       DatabaseHelper   databaseHelper;\n       SQLiteDatabase   db;\n       Cursor   userCursor;\n       SimpleCursorAdapter   userAdapter;\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           userList   =   findViewById  (R.id.list);\n           userList.  setOnItemClickListener  (  new   AdapterView.  OnItemClickListener  () {\n               @  Override\n               public   void   onItemClick  (  AdapterView  \u003C?>   parent,   View   view,   int   position,   long   id) {\n                   Intent   intent   =   new   Intent  (  getApplicationContext  (), UserActivity.class);\n                   intent.  putExtra  (  \"id\"  , id);\n                   startActivity  (intent);\n               }\n           });\n    \n           databaseHelper   =   new   DatabaseHelper  (  getApplicationContext  ());\n           // створюємо базу даних\n           databaseHelper.  create_db  ();\n       }\n    \n       @  Override\n       public   void   onResume  () {\n           super  .  onResume  ();\n           // відкриваємо підключення\n           db   =   databaseHelper.  open  ();\n           // отримуємо дані з бд у вигляді курсора\n           userCursor   =   db.  rawQuery  (  \"select * from \"   +   DatabaseHelper.TABLE,   null  );\n           // визначаємо, які стовпці з курсору будуть виводитися в ListView\n           String  [] headers   =   new   String  []{DatabaseHelper.COLUMN_NAME, DatabaseHelper.COLUMN_YEAR};\n           // створюємо адаптер, передаємо в нього курсор\n           userAdapter   =   new   SimpleCursorAdapter  (  this  , android.R.layout.two_line_list_item,\n                   userCursor, headers,   new   int  []{android.R.id.text1, android.R.id.text2},   0  );\n           userList.  setAdapter  (userAdapter);\n       }\n    \n       // по нажатию на кнопку запускаем UserActivity для добавления данных\n       public   void   add  (  View   view  ) {\n           Intent   intent   =   new   Intent  (  this  , UserActivity.class);\n           startActivity  (intent);\n       }\n    \n       @  Override\n       public   void   onDestroy  () {\n           super  .  onDestroy  ();\n           // Закрываем подключение и курсор\n           db.  close  ();\n           userCursor.  close  ();\n       }\n   }\n  І також змінимо клас   UserActivity :     package   com.example.sqliteapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.content.ContentValues  ;\n   import   android.content.Intent  ;\n   import   android.database.Cursor  ;\n   import   android.database.sqlite.SQLiteDatabase  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n   import   android.widget.Button  ;\n   import   android.widget.EditText  ;\n    \n   public   class   UserActivity   extends   AppCompatActivity   {\n    \n       EditText   nameBox;\n       EditText   yearBox;\n       Button   delButton;\n       Button   saveButton;\n    \n       DatabaseHelper   sqlHelper;\n       SQLiteDatabase   db;\n       Cursor   userCursor;\n       long   userId   =   0  ;\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_user);\n    \n           nameBox   =   findViewById  (R.id.name);\n           yearBox   =   findViewById  (R.id.year);\n           delButton   =   findViewById  (R.id.deleteButton);\n           saveButton   =   findViewById  (R.id.saveButton);\n    \n           sqlHelper   =   new   DatabaseHelper  (  this  );\n           db   =   sqlHelper.  open  ();\n    \n           Bundle   extras   =   getIntent  ().  getExtras  ();\n           if   (extras   !=   null  ) {\n               userId   =   extras.  getLong  (  \"id\"  );\n           }\n           // якщо 0, то додавання\n           if   (userId   >   0  ) {\n               // отримуємо елемент за id із бд\n               userCursor   =   db.  rawQuery  (  \"select * from \"   +   DatabaseHelper.TABLE   +   \" where \"   +\n                       DatabaseHelper.COLUMN_ID   +   \"=?\"  ,   new   String  []{String.  valueOf  (userId)});\n               userCursor.  moveToFirst  ();\n               nameBox.  setText  (userCursor.  getString  (  1  ));\n               yearBox.  setText  (String.  valueOf  (userCursor.  getInt  (  2  )));\n               userCursor.  close  ();\n           }   else   {\n               // приховуємо кнопку видалення\n               delButton.  setVisibility  (View.GONE);\n           }\n       }\n   \n       public   void   save  (  View   view  ){\n           ContentValues   cv   =   new   ContentValues  ();\n           cv.  put  (DatabaseHelper.COLUMN_NAME, nameBox.  getText  ().  toString  ());\n           cv.  put  (DatabaseHelper.COLUMN_YEAR, Integer.  parseInt  (yearBox.  getText  ().  toString  ()));\n    \n           if   (userId   >   0  ) {\n               db.  update  (DatabaseHelper.TABLE, cv, DatabaseHelper.COLUMN_ID   +   \"=\"   +   userId,   null  );\n           }   else   {\n               db.  insert  (DatabaseHelper.TABLE,   null  , cv);\n           }\n           goHome  ();\n       }\n   \n       public   void   delete  (  View   view  ){\n           db.  delete  (DatabaseHelper.TABLE,   \"_id = ?\"  ,   new   String  []{String.  valueOf  (userId)});\n           goHome  ();\n       }\n   \n       private   void   goHome  (){\n           // закриваємо підключення\n           db.  close  ();\n           // переход к главной activity\n           Intent   intent   =   new   Intent  (  this  , MainActivity.class);\n           intent.  addFlags  (Intent.FLAG_ACTIVITY_CLEAR_TOP   |   Intent.FLAG_ACTIVITY_SINGLE_TOP);\n           startActivity  (intent);\n       }\n   }\n  Уся інша робота з даними буде тією ж, щоб і в минулих темах:\n   html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":843,"path":844,"dir":813,"title":845,"description":846,"keywords":847,"body":848},"content:1.android:6.lesson6:5.search.md","/android/lesson6/search","Динамічний пошук по базі даних SQLite","Розглянемо, як ми можемо створити в додатку на Android динамічний пошук за базою даних SQLite.",[],"  Динамічний пошук по базі даних SQLite  Розглянемо, як ми можемо створити в додатку на Android динамічний пошук за базою даних SQLite.  Отже, створимо новий проєкт із порожньою   MainActivity . Для цього проєкту візьмемо базу даних із минулої теми (або створимо нову). Ця база даних називається   cityinfo  і має одну таблицю   users  з трьома полями   _id ,   name ,   age :     CREATE   TABLE   `  users  ` (\n       `_id`     INTEGER   NOT NULL   PRIMARY KEY   AUTOINCREMENT   UNIQUE  ,\n       `name`    TEXT   NOT NULL  ,\n       `year`    INTEGER   NOT NULL\n   );\n   \nІ також додамо в проєкт в Android Studio папку   assets , а в папку   assets  - щойно створену базу даних:\n   У моєму випадку база даних називається   \"cityinfo.db\" .  Як показано вище на скріншоті, додавши в проєкт в одну папку з   MainActivity  новий клас   DatabaseHelper :     package   com.example.livesearchapp  ;\n    \n   import   android.database.SQLException  ;\n   import   android.database.sqlite.SQLiteOpenHelper  ;\n   import   android.database.sqlite.SQLiteDatabase  ;\n   import   android.content.Context  ;\n   import   android.util.Log  ;\n    \n   import   java.io.File  ;\n   import   java.io.FileOutputStream  ;\n   import   java.io.IOException  ;\n   import   java.io.InputStream  ;\n   import   java.io.OutputStream  ;\n    \n   class   DatabaseHelper   extends   SQLiteOpenHelper   {\n       private   static   String   DB_PATH;   // повний шлях до бази даних\n       private   static   String   DB_NAME   =   \"cityinfo.db\"  ;\n       private   static   final   int   SCHEMA   =   1  ;   // версія бази даних\n       static   final   String   TABLE   =   \"users\"  ;   // назва таблиці в бд\n       // назви стовпців\n       static   final   String   COLUMN_ID   =   \"_id\"  ;\n       static   final   String   COLUMN_NAME   =   \"name\"  ;\n       static   final   String   COLUMN_YEAR   =   \"year\"  ;\n       private   Context   myContext;\n    \n       DatabaseHelper  (  Context   context  ) {\n           super  (context, DB_NAME,   null  , SCHEMA);\n           this  .myContext  =  context;\n           DB_PATH   =  context.  getFilesDir  ().  getPath  ()   +   DB_NAME;\n       }\n    \n       @  Override\n       public   void   onCreate  (  SQLiteDatabase   db  ) { }\n   \n       @  Override\n       public   void   onUpgrade  (  SQLiteDatabase   db  ,   int   oldVersion  ,    int   newVersion  ) { }\n    \n       void   create_db  () {\n           File   file   =   new   File  (DB_PATH);\n   \n           if   (  !  file.  exists  ()) {\n               // отримуємо локальну бд як потік\n               try  (  InputStream   myInput   =   myContext.  getAssets  ().  open  (DB_NAME);\n                   // Відкриваємо порожню бд\n                   OutputStream   myOutput   =   new   FileOutputStream  (DB_PATH)) {\n    \n                   // побайтово копіюємо дані\n                   byte  [] buffer   =   new   byte  [  1024  ];\n                   int   length;\n                   while   ((length   =   myInput.  read  (buffer))   >   0  ) {\n                       myOutput.  write  (buffer,   0  , length);\n                   }\n                   myOutput.  flush  ();\n               }\n               catch  (  IOException   ex  ){\n                   Log.  d  (  \"DatabaseHelper\"  , ex.  getMessage  ());\n               }\n           }\n       }\n       public   SQLiteDatabase   open  ()  throws   SQLException   {\n    \n           return   SQLiteDatabase.  openDatabase  (DB_PATH,   null  , SQLiteDatabase.OPEN_READWRITE);\n       }\n   }\n  Перейдемо до файлу   activity_main.xml , який визначає візуальний інтерфейс, і змінимо його таким чином:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"   >\n    \n       \u003C  EditText   android:id  =  \"@+id/userFilter\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:hint  =  \"Пошук\"\n           app:layout_constraintBottom_toTopOf  =  \"@+id/userList\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n       \u003C  ListView\n           android:id  =  \"@+id/userList\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/userFilter\"\n           />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Отже, у нас буде елемент   ListView  для відображення списку і текстове поле для фільтрації.  Тепер змінимо код   MainActivity :     package   com.example.livesearchapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.database.Cursor  ;\n   import   android.database.SQLException  ;\n   import   android.database.sqlite.SQLiteDatabase  ;\n   import   android.os.Bundle  ;\n   import   android.text.Editable  ;\n   import   android.text.TextWatcher  ;\n   import   android.widget.EditText  ;\n   import   android.widget.FilterQueryProvider  ;\n   import   android.widget.ListView  ;\n   import   android.widget.SimpleCursorAdapter  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       DatabaseHelper   sqlHelper;\n       SQLiteDatabase   db;\n       Cursor   userCursor;\n       SimpleCursorAdapter   userAdapter;\n       ListView   userList;\n       EditText   userFilter;\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n           userList   =   (ListView)  findViewById  (R.id.userList);\n           userFilter   =   (EditText)  findViewById  (R.id.userFilter);\n    \n           sqlHelper   =   new   DatabaseHelper  (  getApplicationContext  ());\n           // створюємо базу даних\n           sqlHelper.  create_db  ();\n       }\n       @  Override\n       public   void   onResume  () {\n           super  .  onResume  ();\n           try   {\n               db   =   sqlHelper.  open  ();\n               userCursor   =   db.  rawQuery  (  \"select * from \"   +   DatabaseHelper.TABLE,   null  );\n               String  [] headers   =   new   String  []{DatabaseHelper.COLUMN_NAME, DatabaseHelper.COLUMN_YEAR};\n               userAdapter   =   new   SimpleCursorAdapter  (  this  , android.R.layout.two_line_list_item,\n                       userCursor, headers,   new   int  []{android.R.id.text1, android.R.id.text2},   0  );\n    \n               // якщо в текстовому полі є текст, виконуємо фільтрацію\n               // ця перевірка потрібна під час переходу від однієї орієнтації екрана до іншої\n               if  (  !  userFilter.  getText  ().  toString  ().  isEmpty  ())\n                   userAdapter.  getFilter  ().  filter  (userFilter.  getText  ().  toString  ());\n    \n               // установка слухача зміни тексту\n               userFilter.  addTextChangedListener  (  new   TextWatcher  () {\n    \n                   public   void   afterTextChanged  (  Editable   s  ) { }\n    \n                   public   void   beforeTextChanged  (  CharSequence   s  ,   int   start  ,   int   count  ,   int   after  ) { }\n                   // у разі зміни тексту виконуємо фільтрацію\n                   public   void   onTextChanged  (  CharSequence   s  ,   int   start  ,   int   before  ,   int   count  ) {\n    \n                       userAdapter.  getFilter  ().  filter  (s.  toString  ());\n                   }\n               });\n    \n               // встановлюємо провайдер фільтрації\n               userAdapter.  setFilterQueryProvider  (  new   FilterQueryProvider  () {\n                   @  Override\n                   public   Cursor   runQuery  (  CharSequence   constraint  ) {\n    \n                       if   (constraint   ==   null   ||   constraint.  length  ()   ==   0  ) {\n    \n                           return   db.  rawQuery  (  \"select * from \"   +   DatabaseHelper.TABLE,   null  );\n                       }\n                       else   {\n                           return   db.  rawQuery  (  \"select * from \"   +   DatabaseHelper.TABLE   +   \" where \"   +\n                                   DatabaseHelper.COLUMN_NAME   +   \" like ?\"  ,   new   String  []{  \"%\"   +   constraint.  toString  ()   +   \"%\"  });\n                       }\n                   }\n               });\n    \n               userList.  setAdapter  (userAdapter);\n           }\n           catch   (  SQLException   ex  ){}\n       }\n       @  Override\n       public   void   onDestroy  (){\n           super  .  onDestroy  ();\n           // Закриваємо підключення і курсор\n           db.  close  ();\n           userCursor.  close  ();\n       }\n   }\n  Перш за все, треба відзначити, що для фільтрації даних в адаптері, нам потрібно отримати фільтр адаптера, а у цього фільтра виконати метод   filter() :     userAdapter.  getFilter  ().  filter  (s.  toString  ());\n  В цей метод   filter()  передається ключ пошуку.  Для текстового поля ми можемо відслідковувати зміни вмісту за допомогою слухача:     userFilter.  addTextChangedListener  (  new   TextWatcher  () {\n   \n       public   void   afterTextChanged  (  Editable   s  ) {\n       }\n   \n       public   void   beforeTextChanged  (  CharSequence   s  ,   int   start  ,   int   count  ,   int   after  ) {\n       }\n       // при зміні тексту виконуємо фільтрацію\n       public   void   onTextChanged  (  CharSequence   s  ,   int   start  ,   int   before  ,   int   count  ) {\n   \n           userAdapter.  getFilter  ().  filter  (s.  toString  ());\n       }\n   });\n  В слухачі   TextWatcher  в методі   onTextChanged  якраз і викликається метод   filter() , в який передається введена користувачем у текстове поле послідовність символів.  Сам виклик методу   filter()  мало на що впливає. Нам треба ще визначити провайдера фільтрації адаптера, який і буде інкапсулювати реальну логіку фільтрації:     userAdapter.  setFilterQueryProvider  (  new   FilterQueryProvider  () {\n       @  Override\n       public   Cursor   runQuery  (  CharSequence   constraint  ) {\n   \n           if   (constraint   ==   null   ||   constraint.  length  ()   ==   0  ) {\n   \n               return   db.  rawQuery  (  \"select * from \"   +   DatabaseHelper.TABLE,   null  );\n           }\n           else   {\n               return   db.  rawQuery  (  \"select * from \"   +   DatabaseHelper.TABLE   +   \" where \"   +\n                   DatabaseHelper.COLUMN_NAME   +   \" like ?\"  ,   new   String  []{  \"%\"   +   constraint.  toString  ()   +   \"%\"  });\n               }\n       }\n   });\n  Сутність цього провайдера полягає в виконанні SQL-виразів до БД, а саме конструкцій   select from  і   select from where like . Дані прості вирази виконують реєстрозалежну фільтрацію. В результаті адаптер отримує відфільтровані дані.  Слід також відзначити наступний код:     if  (  !  userFilter.  getText  ().  toString  ().  isEmpty  ())\n       userAdapter.  getFilter  ().  filter  (userFilter.  getText  ().  toString  ());\n  Цей код потрібен нам при зміні орієнтації (наприклад, з портретної на альбомну). І якщо орієнтація пристрою змінена, але в текстовому полі все ж є якийсь текст-фільтр, то виконується фільтрація. Інакше фільтрація не виконується.  І після запуску ми зможемо насолодитися фільтрацією даних:    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":850,"path":851,"dir":813,"title":852,"description":7,"keywords":853,"body":858},"content:1.android:6.lesson6:6.repository.md","/android/lesson6/repository","Repository патерн в Android (без фреймворків)",[621,854,855,856,857],"Крок 1: Створення SQLite допоміжного класу","Крок 2: Створення моделі даних","Крок 3: Реалізація Repository патерну","Крок 4: Використання Repository в Activity","  Repository патерн в Android (без фреймворків)  Вступ  В Android розробці Repository патерн є важливим елементом архітектури, який дозволяє абстрагувати доступ до даних. Він дозволяє централізувати логіку доступу до бази даних, знижуючи залежність від конкретної реалізації джерела даних (наприклад, SQLite). Це дозволяє легше тестувати та підтримувати додаток.  Крок 1: Створення SQLite допоміжного класу  Перед тим як створювати сам Repository, необхідно налаштувати доступ до бази даних за допомогою SQLite.  Створення класу для роботи з базою даних     public   class   DatabaseHelper   extends   SQLiteOpenHelper   {\n   \n       private   static   final   String   DATABASE_NAME   =   \"my_database\"  ;\n       private   static   final   int   DATABASE_VERSION   =   1  ;\n   \n       public   static   final   String   TABLE_NAME   =   \"users\"  ;\n       public   static   final   String   COLUMN_ID   =   \"id\"  ;\n       public   static   final   String   COLUMN_NAME   =   \"name\"  ;\n       public   static   final   String   COLUMN_AGE   =   \"age\"  ;\n   \n       public   DatabaseHelper  (  Context   context  ) {\n           super  (context, DATABASE_NAME,   null  , DATABASE_VERSION);\n       }\n   \n       @  Override\n       public   void   onCreate  (  SQLiteDatabase   db  ) {\n           String   createTableQuery   =   \"CREATE TABLE \"   +   TABLE_NAME   +   \" (\"   +\n                   COLUMN_ID   +   \" INTEGER PRIMARY KEY AUTOINCREMENT, \"   +\n                   COLUMN_NAME   +   \" TEXT, \"   +\n                   COLUMN_AGE   +   \" INTEGER)\"  ;\n           db.  execSQL  (createTableQuery);\n       }\n   \n       @  Override\n       public   void   onUpgrade  (  SQLiteDatabase   db  ,   int   oldVersion  ,   int   newVersion  ) {\n           db.  execSQL  (  \"DROP TABLE IF EXISTS \"   +   TABLE_NAME);\n           onCreate  (db);\n       }\n   }\n  Тут ми створюємо допоміжний клас   DatabaseHelper , який успадковується від   SQLiteOpenHelper . Він визначає методи для створення та оновлення бази даних.  Крок 2: Створення моделі даних  Модель даних представляє собою об'єкт, який буде зберігати дані з таблиці.     public   class   User   {\n       private   long   id;\n       private   String   name;\n       private   int   age;\n   \n       public   User  (  long   id  ,   String   name  ,   int   age  ) {\n           this  .id   =   id;\n           this  .name   =   name;\n           this  .age   =   age;\n       }\n   \n       // Геттери та сеттери\n       public   long   getId  () {\n           return   id;\n       }\n   \n       public   void   setId  (  long   id  ) {\n           this  .id   =   id;\n       }\n   \n       public   String   getName  () {\n           return   name;\n       }\n   \n       public   void   setName  (  String   name  ) {\n           this  .name   =   name;\n       }\n   \n       public   int   getAge  () {\n           return   age;\n       }\n   \n       public   void   setAge  (  int   age  ) {\n           this  .age   =   age;\n       }\n   }\n  У нашій моделі   User  є три поля:   id ,   name  і   age , які відповідають колонкам таблиці в базі даних.  Крок 3: Реалізація Repository патерну  Тепер ми можемо створити сам Repository, який буде виконувати CRUD операції (створення, читання, оновлення, видалення) з базою даних.     public   class   UserRepository   {\n   \n       private   SQLiteDatabase   database;\n       private   DatabaseHelper   dbHelper;\n   \n       public   UserRepository  (  Context   context  ) {\n           dbHelper   =   new   DatabaseHelper  (context);\n       }\n   \n       // Встановлення з'єднання з базою даних\n       private   void   open  () {\n           database   =   dbHelper.  getWritableDatabase  ();\n       }\n   \n       // Закриття з'єднання з базою даних\n       private   void   close  () {\n           dbHelper.  close  ();\n       }\n   \n       // Додавання користувача\n       public   void   addUser  (  User   user  ) {\n           open  ();\n   \n           ContentValues   values   =   new   ContentValues  ();\n           values.  put  (DatabaseHelper.COLUMN_NAME, user.  getName  ());\n           values.  put  (DatabaseHelper.COLUMN_AGE, user.  getAge  ());\n   \n           database.  insert  (DatabaseHelper.TABLE_NAME,   null  , values);\n           close  ();\n       }\n   \n       // Отримання користувача за id\n       public   User   getUser  (  long   id  ) {\n           open  ();\n   \n           Cursor   cursor   =   database.  query  (\n                   DatabaseHelper.TABLE_NAME,\n                   null  , \n                   DatabaseHelper.COLUMN_ID   +   \" = ?\"  , \n                   new   String  []{String.  valueOf  (id)},\n                   null  ,   null  ,   null\n           );\n   \n           User   user   =   null  ;\n           if   (cursor   !=   null   &&   cursor.  moveToFirst  ()) {\n               String   name   =   cursor.  getString  (cursor.  getColumnIndex  (DatabaseHelper.COLUMN_NAME));\n               int   age   =   cursor.  getInt  (cursor.  getColumnIndex  (DatabaseHelper.COLUMN_AGE));\n               user   =   new   User  (id, name, age);\n               cursor.  close  ();\n           }\n   \n           close  ();\n           return   user;\n       }\n   \n       // Оновлення користувача\n       public   void   updateUser  (  User   user  ) {\n           open  ();\n   \n           ContentValues   values   =   new   ContentValues  ();\n           values.  put  (DatabaseHelper.COLUMN_NAME, user.  getName  ());\n           values.  put  (DatabaseHelper.COLUMN_AGE, user.  getAge  ());\n   \n           database.  update  (\n                   DatabaseHelper.TABLE_NAME,\n                   values,\n                   DatabaseHelper.COLUMN_ID   +   \" = ?\"  ,\n                   new   String  []{String.  valueOf  (user.  getId  ())}\n           );\n           close  ();\n       }\n   \n       // Видалення користувача\n       public   void   deleteUser  (  long   id  ) {\n           open  ();\n   \n           database.  delete  (\n                   DatabaseHelper.TABLE_NAME,\n                   DatabaseHelper.COLUMN_ID   +   \" = ?\"  ,\n                   new   String  []{String.  valueOf  (id)}\n           );\n   \n           close  ();\n       }\n   }\n  У класі   UserRepository  ми реалізуємо методи для додавання, отримання, оновлення та видалення користувачів. Ми також відкриваємо та закриваємо з'єднання з базою даних у кожному методі, щоб забезпечити ефективне використання ресурсів.  Крок 4: Використання Repository в Activity  Тепер ми можемо використовувати наш Repository для взаємодії з даними в Activity або іншій компоненці Android.     public   class   MainActivity   extends   AppCompatActivity   {\n   \n       private   UserRepository   userRepository;\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n   \n           userRepository   =   new   UserRepository  (  this  );\n   \n           // Створення нового користувача\n           User   newUser   =   new   User  (  0  ,   \"John Doe\"  ,   30  );\n           userRepository.  addUser  (newUser);\n   \n           // Отримання користувача\n           User   user   =   userRepository.  getUser  (  1  );\n           if   (user   !=   null  ) {\n               Log.  d  (  \"MainActivity\"  ,   \"User: \"   +   user.  getName  ()   +   \", Age: \"   +   user.  getAge  ());\n           }\n   \n           // Оновлення користувача\n           if   (user   !=   null  ) {\n               user.  setAge  (  31  );\n               userRepository.  updateUser  (user);\n           }\n   \n           // Видалення користувача\n           if   (user   !=   null  ) {\n               userRepository.  deleteUser  (user.  getId  ());\n           }\n       }\n   }\n  У   MainActivity  ми створюємо екземпляр   UserRepository , використовуємо його методи для додавання, отримання, оновлення та видалення користувачів із бази даних.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":860,"path":861,"dir":862,"title":863,"description":864,"keywords":865,"body":871},"content:1.android:7.lesson7:1.basic.md","/android/lesson7/basic","lesson7","Основи Room","Бібліотека Room надає нам зручну обгортку для роботи з базою даних SQLite. У цьому уроці розглянемо основи. Як підключити до проєкту. Як отримувати, вставляти, оновлювати та видаляти дані.",[866,867,868,869,870],"Entity","Dao","Database","Практика","UI потік","  Основи Room  Бібліотека Room надає нам зручну обгортку для роботи з базою даних SQLite. У цьому уроці розглянемо основи. Як підключити до проєкту. Як отримувати, вставляти, оновлювати та видаляти дані.  Бібліотека персистентності Room надає рівень абстракції над SQLite, щоб забезпечити вільний доступ до бази даних, використовуючи при цьому всю потужність SQLite. Зокрема, Room надає наступні переваги:   Перевірка SQL-запитів під час компіляції.  Зручні анотації, які мінімізують повторюваний і схильний до помилок шаблонний код.  Спрощені шляхи міграції баз даних.  З огляду на ці міркування, ми наполегливо рекомендуємо вам використовувати Room замість прямого використання API SQLite. (цитата із документації гугл про андроїд room   doc )     dependencies   {\n       val   room_version   =   \"2.6.1\"\n   \n       implementation  (  \"androidx.room:room-runtime:  $room_version  \"  )\n   \n       // If this project uses any Kotlin source, use Kotlin Symbol Processing (KSP)\n       // See Add the KSP plugin to your project\n       ksp  (  \"androidx.room:room-compiler:  $room_version  \"  )\n   \n       // If this project only uses Java source, use the Java annotationProcessor\n       // No additional plugins are necessary\n       annotationProcessor  (  \"androidx.room:room-compiler:  $room_version  \"  )\n   \n       // optional - Kotlin Extensions and Coroutines support for Room\n       implementation  (  \"androidx.room:room-ktx:  $room_version  \"  )\n   \n       // optional - RxJava2 support for Room\n       implementation  (  \"androidx.room:room-rxjava2:  $room_version  \"  )\n   \n       // optional - RxJava3 support for Room\n       implementation  (  \"androidx.room:room-rxjava3:  $room_version  \"  )\n   \n       // optional - Guava support for Room, including Optional and ListenableFuture\n       implementation  (  \"androidx.room:room-guava:  $room_version  \"  )\n   \n       // optional - Test helpers\n       testImplementation  (  \"androidx.room:room-testing:  $room_version  \"  )\n   \n       // optional - Paging 3 Integration\n       implementation  (  \"androidx.room:room-paging:  $room_version  \"  )\n   }\n  Room має три основні компоненти:   Entity ,   Dao  і   Database . Розглянемо їх на невеликому прикладі, в якому будемо створювати базу даних для зберігання даних щодо   співробітників  (англ. -   employee ).  Entity  Анотацією   Entity  необхідно позначити об'єкт, який ми хочемо зберігати в базі даних. Для цього створимо клас   Employee , який буде представляти дані співробітника: id, ім'я, зарплата:     @  Entity\n   public   class   Employee   {\n   \n      @  PrimaryKey\n      public   long   id;\n   \n      public   String   name;\n   \n      public   int   salary;\n   }\n  Клас позначається анотацією   Entity . Об'єкти класу   Employee  будуть використовуватися при роботі з базою даних. Наприклад, ми будемо отримувати їх від бази при запитах даних і відправляти їх у базу при вставці даних.  Цей самий клас   Employee  буде використано для створення таблиці в базі.   Як ім'я таблиці буде використано ім'я класу . А поля таблиці будуть створені відповідно до полів класу.  Анотацією   PrimaryKey  ми позначаємо поле, яке буде ключем у таблиці.  Dao  В об'єкті   Dao  ми будемо описувати методи для роботи з базою даних. Нам потрібні будуть методи для отримання списку співробітників і для додавання/зміни/видалення співробітників.  Описуємо їх в інтерфейсі з анотацією   Dao .     @  Dao\n   public   interface   EmployeeDao   {\n   \n      @  Query  (  \"SELECT * FROM employee\"  )\n      List  \u003C  Employee  >   getAll  ();\n   \n      @  Query  (  \"SELECT * FROM employee WHERE id = :id\"  )\n      Employee   getById  (  long   id  );\n   \n      @  Insert\n      void   insert  (  Employee   employee  );\n   \n      @  Update\n      void   update  (  Employee   employee  );\n   \n      @  Delete\n      void   delete  (  Employee   employee  );\n   \n   }\n  Методи   getAll  і   getById  дають змогу отримати повний список співробітників або конкретного співробітника за   id . В анотації   Query  нам необхідно прописати відповідні SQL-запити, які будуть використані для отримання даних.  Зверніть увагу, що як ім'я таблиці ми використовуємо   employee . Нагадаю, що ім'я таблиці дорівнює імені   Entity  класу, тобто   Employee , але в SQLite не важливий регістр в іменах таблиць, тому можемо писати   employee .  Для вставки/оновлення/видалення використовуються методи insert/update/delete з відповідними анотаціями. Тут жодні запити вказувати не потрібно. Назви методів можуть бути будь-якими. Головне - анотації.  Database  Анотацією   Database  позначаємо основний клас по роботі з базою даних. Цей клас має бути абстрактним і успадковувати   RoomDatabase .     @  Database  (  entities   =   {Employee.class},   version   =   1  )\n   public   abstract   class   AppDatabase   extends   RoomDatabase   {\n      public   abstract   EmployeeDao   employeeDao  ();\n   }\n  У параметрах анотації   Database  вказуємо, які   Entity  будуть використовуватися, і версію бази. Для кожного   Entity  класу зі списку   entities  буде створено таблицю.  У   Database  класі необхідно описати абстрактні методи для отримання Dao об'єктів, які вам знадобляться.  Практика  Усі необхідні для роботи об'єкти створено. Давайте подивимося, як використовувати їх для роботи з базою даних.   Database  об'єкт - це стартова точка. Його створення виглядає так:     AppDatabase   db   =    Room.  databaseBuilder  (  getApplicationContext  (),\n           AppDatabase.class,   \"database\"  ).  build  ();\n  Використовуємо   Application Context , а також вказуємо   AppDatabase  клас і ім'я файлу для бази.  Враховуйте, що під час виклику цього коду Room щоразу створюватиме новий екземпляр AppDatabase. Ці екземпляри дуже важкі і рекомендується використовувати один екземпляр для всіх ваших операцій. Тому вам необхідно подбати про   синглтон  для цього об'єкта. Це можна зробити за допомогою Dagger (будем вчити на наступних зустрічах), наприклад.  Якщо ви не використовуєте Dagger (або інший DI механізм), то можна використовувати   Application  клас для створення і зберігання   AppDatabase :     public   class   App   extends   Application   {\n   \n       public   static   App   instance;\n   \n       private   AppDatabase   database;\n   \n       @  Override\n       public   void   onCreate  () {\n           super  .  onCreate  ();\n           instance   =   this  ;\n           database   =   Room.  databaseBuilder  (  this  , AppDatabase.class,   \"database\"  )\n                   .  build  ();\n       }\n   \n       public   static   App   getInstance  () {\n           return   instance;\n       }\n   \n       public   AppDatabase   getDatabase  () {\n           return   database;\n       }\n   }\n  Не забудьте додати   App  клас у маніфест     \u003C  manifest   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       package  =  \"com.example.myapp\"  >\n   \n       \u003C  application\n           android:name  =  \".App\"\n           android:icon  =  \"@mipmap/ic_launcher\"\n           android:label  =  \"@string/app_name\"  >\n           \u003C!-- Інші параметри додатку -->\n   \n           \u003C  activity   android:name  =  \".MainActivity\"  >\n               \u003C!-- Інші параметри активності -->\n           \u003C/  activity  >\n       \u003C/  application  >\n   \n   \u003C/  manifest  >\n  У коді отримання бази матиме такий вигляд:     AppDatabase   db   =   App.  getInstance  ().  getDatabase  ();\n  З   Database  об'єкта отримуємо   Dao .     EmployeeDao   employeeDao   =   db.  employeeDao  ();\n  Тепер ми можемо працювати з   Employee  об'єктами. Але ці операції мають виконуватися не в UI потоці. Інакше ми отримаємо   Exception .  Додавання нового співробітника в базу буде виглядати так:     Employee   employee   =   new   Employee  ();\n   employee.id   =   1  ;\n   employee.name   =   \"John Smith\"  ;\n   employee.salary   =   10000  ;\n   \n   employeeDao.  insert  (employee);\n  Метод   getAll  поверне нам усіх співробітників у   List\u003CEmployee>     List  \u003C  Employee  > employees   =   employeeDao.  getAll  ();\n  Отримання співробітника за   id :     Employee   employee   =   employeeDao.  getById  (  1  );\n  Оновлення даних по співробітнику.     employee.salary   =   20000  ;\n   employeeDao.  update  (employee);\n  Room шукатиме в таблиці запис за ключовим полем, тобто за   id . Якщо в об'єкті   employee  не заповнене поле   id , то за замовчуванням у нашому прикладі воно дорівнюватиме нулю, і Room просто не знайде такого співробітника (якщо, звісно, у вас немає запису з   id = 0 ).  Видалення співробітника     employeeDao.  delete  (employee);\n  Аналогічно оновленню, Room шукатиме запис за ключовим полем, тобто за   id  Давайте для прикладу додамо ще один тип об'єкта -   Car .  Описуємо   Entity  об'єкт     @  Entity\n   public   class   Car   {\n   \n      @  PrimaryKey\n      public   long   id;\n   \n      public   String   model;\n   \n      public   int   year;\n   \n   }\n  Тепер   Dao  для роботи з   Car  об'єктом     @  Dao\n   public   interface   CarDao   {\n   \n      @  Query  (  \"SELECT * FROM car\"  )\n      List  \u003C  Car  >   getAll  ();\n   \n      @  Insert\n      void   insert  (  Car   car  );\n   \n      @  Delete\n      void   delete  (  Car   car  );\n   \n   }\n  Будемо вважати, що нам треба тільки читати всі записи, додавати нові та видаляти старі.  У   Database  необхідно додати   Car  у список   entities  і новий метод для отримання   CarDao     @  Database  (  entities   =   {Employee.class, Car.class},   version   =   1  )\n   public   abstract   class   AppDatabase   extends   RoomDatabase   {\n      public   abstract   EmployeeDao   employeeDao  ();\n      public   abstract   CarDao   carDao  ();\n   }\n  Оскільки ми додали нову таблицю, змінилася структура бази даних. І нам необхідно підняти версію бази даних до   2 . Але про це ми детально поговоримо пізніше. А поки що можна залишити версію, що дорівнює   1 , видалити стару версію застосунку і поставити нову.  UI потік  Повторюся, операції з роботи з базою даних - синхронні, і повинні виконуватися не в UI потоці.  У випадку з   Query  операціями ми можемо зробити їх асинхронними, використовуючи   LiveData  або   RxJava . У разі   insert/update/delete  ви можете обернути ці методи в асинхронний RxJava.  Також, ви можете використовувати   allowMainThreadQueries  у білдері створення   AppDatabase     AppDatabase   db   =    Room.  databaseBuilder  (  getApplicationContext  (),\n          AppDatabase.class,   \"database\"  )\n          .  allowMainThreadQueries  ()\n          .  build  ();\n  У цьому випадку ви не отримуватимете   Exception  під час роботи в UI потоці. Але ви повинні розуміти, що це погана практика, і може додати відчутних гальм вашому застосунку.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":873,"path":874,"dir":862,"title":875,"description":876,"keywords":877,"body":886},"content:1.android:7.lesson7:2.entity.md","/android/lesson7/entity","Room. Entity","У цьому уроці детальніше розглянемо можливості Entity. Як задати ім'я таблиці. Як задати ім'я або тип поля. Як створити складений або зовнішній ключ. Як створити індекс. Як використовувати вкладені об'єкти.",[878,879,880,881,882,883,884,885],"Ім'я таблиці","Ім'я поля","Тип поля","Модифікатори доступу","Первинний ключ","Індекс","Вкладені об'єкти","Ignore","  Room. Entity  У цьому уроці детальніше розглянемо можливості   Entity . Як задати ім'я таблиці. Як задати ім'я або тип поля. Як створити складений або зовнішній ключ. Як створити індекс. Як використовувати вкладені об'єкти.  Ім'я таблиці   Entity  клас використовується для створення таблиці. За замовчуванням як ім'я таблиці використовується ім'я цього класу. Але ми можемо вказати своє ім'я, використовуючи параметр   tableName .     @  Entity  (  tableName   =   \"employees\"  )\n   public   class   Employee   {\n    \n      // ...\n    \n   }\n  Для зберігання об'єктів   Employee  буде створено таблицю з іменем   employees .  Ім'я поля  За замовчуванням як ім'я полів у таблиці використовуються імена полів   Entity  класу. Але ми можемо вказати своє ім'я, використовуючи параметр name в анотації   ColumnInfo .     @  Entity  ()\n   public   class   Employee   {\n    \n      @  PrimaryKey  ()\n      public   long   id;\n    \n      @  ColumnInfo  (  name   =   \"full_name\"  )\n      public   String   fullName;\n    \n      public   int   salary;\n    \n   }\n  Для   fullName  у таблиці буде створено поле з ім'ям   full_name .  Тип поля  За замовчуванням   Room  визначає тип даних для поля в таблиці за типом даних поля в   Entity  класі. Але ми можемо явно вказати свій тип.     @  Entity  ()\n   public   class   Employee   {\n    \n      @  PrimaryKey  (  autoGenerate   =   true  )\n      public   long   id;\n    \n      public   String   name;\n    \n      @  ColumnInfo  (  typeAffinity   =   TEXT)\n      public   int   salary;\n    \n   }\n  У таблиці поле salary буде з типом   TEXT .  Модифікатори доступу  Щоб Room міг дістатися до полів класу   Entity , ми робимо їх   public .     @  Entity\n   public   class   Employee   {\n    \n      @  PrimaryKey\n      public   long   id;\n    \n      public   String   name;\n    \n      public   int   salary;\n    \n   }\n  Але є можливість використовувати   private  поля. Для цього треба додати   set/get  методи.     @  Entity\n   public   class   Employee   {\n    \n      @  PrimaryKey\n      private   long   id;\n      private   String   name;\n      private   int   salary;\n    \n      public   long   getId  () {\n          return   id;\n      }\n    \n      public   void   setId  (  long   id  ) {\n          this  .id   =   id;\n      }\n    \n      public   String   getName  () {\n          return   name;\n      }\n    \n      public   void   setName  (  String   name  ) {\n          this  .name   =   name;\n      }\n    \n      public   int   getSalary  () {\n          return   salary;\n      }\n    \n      public   void   setSalary  (  int   salary  ) {\n          this  .salary   =   salary;\n      }\n   }\n  Усі поля -   private . Але кожне має   set/get  методи.  В Android Studio ці методи додаються парою кліків. Тиснете в коді   ALT+INSERT , вибираєте пункт   Getter and Setter , потім вибираєте поля, для яких треба створити методи.  Замість set-методів ми також можемо використовувати конструктор.     @  Entity\n   public   class   Employee   {\n    \n      @  PrimaryKey\n      private   long   id;\n    \n      public   String   name;\n    \n      public   int   salary;\n    \n       public   Employee  (  long   id  ) {\n          this  .id   =   id;\n      }\n    \n      public   long   getId  () {\n          return   id;\n      }\n   }\n  Поле   id  тут -   private  і має   get -метод. А замість   set -методу, Room буде використовувати конструктор.  Параметр конструктора повинен мати той самий тип та ім'я, що й поле   Entity  класу. Ви можете використовувати конструктор для всіх полів або тільки для деяких, як у прикладі вище.  Я для спрощення прикладів скрізь буду використовувати public поля.  Первинний ключ  Ми вже знаємо, як за допомогою   @PrimaryKey  призначити будь-яке поле ключем. Кожен   Entity  клас повинен містити хоча б одне таке поле. Навіть якщо в класі всього одне поле.  У   PrimaryKey  є параметр   autoGenerate . Він дає змогу ввімкнути для поля режим   autoincrement , у якому база даних сама генеруватиме значення, якщо ви його не вкажете.     @  PrimaryKey  (  autoGenerate   =   true  )\n   public   long   id;\n  Тепер під час створення   Entity  об'єкта ви можете не заповнювати поле   id . База сама знайде найближче вільне значення і використає його.  Щоб створити складений ключ, використовуйте параметр   primaryKeys .     @  Entity  (  primaryKeys   =   {  \"key1\"  ,   \"key2\"  })\n   public   class   Item   {\n    \n      public   long   key1;\n      public   long   key2;\n    \n      // ...\n    \n   }\n   Зовнішній ключ \nЗовнішні ключі дають змогу пов'язувати таблиці між собою.  У вище розглянутих прикладах у нас є клас   Employee  для зберігання даних по співробітниках. Давайте створимо клас   Car  для зберігання даних по машинах. І кожна машина має бути прикріплена до якогось співробітника.     @  Entity  (  foreignKeys   =   @  ForeignKey  (  entity   =   Employee.class,   parentColumns   =   \"id\"  ,   childColumns   =   \"employee_id\"  ))\n   public   class   Car   {\n    \n      @  PrimaryKey  (  autoGenerate   =   true  )\n      public   long   id;\n    \n      public   String   model;\n    \n      public   int   year;\n    \n      @  ColumnInfo  (  name   =   \"employee_id\"  )\n      public   long   employeeId;\n    \n   }\n  У полі   employee_id  зберігатиметься   id  співробітника, до якого прикріплена ця машина.  Використовуємо параметр   foreignKeys  для створення зовнішнього ключа. Вказуємо, що значення поля   employee_id  (параметр   childColumns ) повинно обов'язково дорівнювати будь-якому значенню поля   id  (параметр   parentColumns ) у таблиці співробітників   Employee  (параметр   entity ).  Тобто якщо у нас є три співробітники з   id 1,2 і 3 , ми не зможемо додати в базу даних машину з   employee_id = 4 . Тому що в базі немає такого батьківського ключа, тобто співробітника з   id = 4 .  Або, якщо ви спробуєте видалити батьківський ключ, тобто співробітника, до якого прикріплена будь-яка машина, то база видасть вам помилку. Тому що після видалення співробітника, у машини в полі   employee_id  буде знаходитися значення, якого немає в полі   id  таблиці співробітників.  Для подібних випадків видалення або зміни батьківського ключа, ви можете налаштувати поведінку бази даних. За замовчуванням вона повертає помилку, але це можна змінити за допомогою параметрів   onDelete  і   onUpdate  в анотації   ForeignKey .  Додамо параметр   onDelete     @  Entity  (  foreignKeys   =   @  ForeignKey  (  entity   =   Employee.class,   parentColumns   =   \"id\"  ,   childColumns   =   \"employee_id\"  ,   onDelete   =   CASCADE))\n  Його значення =   CASCADE . Це означає, що при видаленні батьківського ключа, будуть видалені пов'язані з ним дочірні ключі. Тобто при видаленні співробітника, видалиться і його машина.  Список можливих значень для параметра   onDelete  можна подивитися   тут .  Ще один параметр анотації   ForeignKey  - це   deferred , що має за замовчуванням значення   false . Якщо задати цьому параметру значення   true , то зовнішній ключ стане відкладеним. Це може бути корисно під час вставки даних у різні таблиці в рамках однієї транзакції. Ви зможете внести всі необхідні зміни, і перевірку на коректність зовнішніх ключів буде виконано наприкінці, під час виконання   commit .  Індекс  Індекси можуть підвищити продуктивність вашої таблиці.  В анотації   Entity  є параметр   indicies , який дає змогу задавати індекси.     @  Entity  (  indices   =   {\n                  @  Index  (  \"salary\"  ),\n                  @  Index  (  value   =   {  \"first_name\"  ,   \"last_name\"  })\n              }\n          )\n   public   class   Employee   {\n    \n      @  PrimaryKey  (  autoGenerate   =   true  )\n      public   long   id;\n    \n      @  ColumnInfo  (  name   =   \"first_name\"  )\n      public   String   firstName;\n    \n      @  ColumnInfo  (  name   =   \"last_name\"  )\n      public   String   lastName;\n    \n      public   int   salary;\n    \n   }\n  Створюємо два індекси: один за полем   salary , а інший за двома полями   first_name  і   last_name .  Індекс дає можливість встановити для його полів перевірку на унікальність. Це робиться параметром   unique = true .     @  Entity  (  indices   =   {@  Index  (  value   =   {  \"first_name\"  ,   \"last_name\"  },   unique   =   true  )})\n  У цьому разі база стежитиме, щоб у цій таблиці не було запису з повторюваною парою значень   first_name  і   last_name .  Індекс для одного поля також може бути налаштований через параметр   index  анотації   ColumnInfo     @  Entity  ()\n   public   class   Employee   {\n    \n      @  PrimaryKey  (  autoGenerate   =   true  )\n      public   long   id;\n    \n      public   String   name;\n    \n      @  ColumnInfo  (  index   =   true  )\n      public   int   salary;\n    \n   }\n  Буде створено індекс для поля   salary .  Вкладені об'єкти  Нехай у нас є клас   Address , з даними про адресу. Це звичайний клас, не   Entity .     public   class   Address   {\n    \n      public   String   city;\n      public   String   street;\n      public   int   number;\n    \n   }\n  І ми хочемо використовувати його в   Entity  класі   Employee     @  Entity  ()\n   public   class   Employee   {\n    \n      @  PrimaryKey  (  autoGenerate   =   true  )\n      public   long   id;\n    \n      public   String   name;\n    \n      public   int   salary;\n    \n      public   Address   address;\n    \n   }\n  Якщо ми зробимо так, то Room буде лаятися, оскільки він не знає, як зберегти такий об'єкт у базу:\n  Cannot figure out how to save this field into database . Можна розглянути питання про додавання для нього конвертера типів.  Але є просте рішення - використовувати анотацію   Embedded .     @  Entity  ()\n   public   class   Employee   {\n    \n      @  PrimaryKey  (  autoGenerate   =   true  )\n      public   long   id;\n    \n      public   String   name;\n    \n      public   int   salary;\n    \n      @  Embedded\n      public   Address   address;\n    \n   }\n   Embedded  підкаже Room, що треба просто взяти поля з   Address  і вважати їх полями таблиці   Employee .  Тобто в базі буде створено таблицю   Employee  з полями   id ,   name ,   salary ,   city ,   street ,   number .  Додавання нового запису матиме такий вигляд:     Employee   employee   =   new   Employee  ();\n   employee.id   =   1  ;\n   employee.name   =   \"John Smith\"  ;\n   employee.salary   =   10000  ;\n   Address   address   =   new   Address  ();\n   address.city   =   \"London\"  ;\n   address.street   =   \"Baker Street\"  ;\n   address.number   =   221  ;\n   employee.address   =   address;\n    \n   db.  employeeDao  ().  insert  (employee);\n  Ми створюємо вкладений об'єкт   Address , але Room розбереться, і запише все в таблицю, як плоску структуру.   Embedded  об'єкти можуть містити в собі інші   Embedded  об'єкти.  Якщо у вас виходить так, що збігаються імена якихось полів в основному об'єкті і в   Embedded  об'єкті, то використовуйте префікс для   Embedded  об'єкта.     @  Embedded  (  prefix   =   \"address\"  )\n   public   Address   address;\n  У цьому разі до імен полів   Embedded  об'єкта в таблиці буде додано зазначений префікс.  Ignore  Анотація   Ignore  дає змогу підказати Room, що це поле не повинно записуватися в базу або читатися з неї.     @  Entity\n   public   class   Employee   {\n    \n      @  PrimaryKey\n      public   long   id;\n    \n      public   String   name;\n    \n      public   int   salary;\n    \n      @  Ignore\n      public   Bitmap   avatar;\n    \n   }\n  Нам не потрібно зберігати   Bitmap  у базі, тому додаємо   Ignore  до цього поля.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":888,"path":889,"dir":862,"title":890,"description":891,"keywords":892,"body":900},"content:1.android:7.lesson7:3.crud.md","/android/lesson7/crud","Room. Insert, Update, Delete, Transaction","У цьому уроці розглянемо докладніше анотації Insert, Update і Delete. А також дізнаємося, як використовувати транзакції в Room.",[893,894,895,896,897,898,899],"Insert","Вставка кількох об'єктів","Отримання id","Режими вставки","Update","Delete","Транзакції","  Room. Insert, Update, Delete, Transaction  У цьому уроці розглянемо докладніше анотації Insert, Update і Delete. А також дізнаємося, як використовувати транзакції в Room.  Insert  Анотація   Insert  - це простий спосіб вставити об'єкт у базу даних. Ми вже використовували її в прикладах минулих уроків.  Використання цієї анотації виглядає так:     @  Dao\n   public   interface   EmployeeDao   {\n    \n      @  Insert\n      void   insert  (  Employee   employee  );\n    \n      // ...\n    \n   }\n  У   Dao  інтерфейсі описуємо метод, який на вхід приймає   Entity  об'єкт. До методу додаємо анотацію   Insert  і Room згенерує необхідний код у реалізації цього інтерфейсу.  Давайте подивимося, які ще можливості в нас є.  Вставка кількох об'єктів  Ми можемо передавати в метод не один, а кілька об'єктів, використовуючи   varargs     @  Insert\n   void   insertMany  (  Employee  ... employees);\n  Також, це може бути список:     @  Insert\n   void   insert  (  List  \u003C  Employee  >   employees);\n  Або це взагалі може бути будь-який   Iterable :     @  Insert\n   void   insert  (  Iterable  \u003C  Employee  >   employees);\n  При виклику цього методу ви можете використовувати масив або колекцію.  Отримання id  Під час вставки метод   Insert  може повертати   id  щойно доданого запису. Для цього треба описати метод так, щоб він повертав   long .     @  Insert\n   long   insert  (  Employee   employee);\n  Якщо в   Employee  є числовий первинний ключ, то саме його значення ви й отримаєте.  У разі додавання декількох записів, необхідно використовувати   long[]     @  Insert\n   long  []   insert  (  List  \u003C  Employee  >   employees);\n  або   List\u003CLong>     @  Insert\n   List  \u003C  Long  >   insert  (  List  \u003C  Employee  >   employees);\n  Режими вставки  Розглянемо ситуацію, коли ми вставляємо в таблицю запис, але виявляється, що запис із таким ключем там уже є. За замовчуванням ми отримаємо помилку:   SQLiteConstraintException: UNIQUE constraint failed . І нічого в базу не запишеться.  Але це можна змінити за допомогою параметра   onConflict .     @  Insert  (  onConflict   =   OnConflictStrategy.REPLACE)\n   void   insert  (  Employee   employee);\n  У режимі   REPLACE  старий запис буде замінено новим. Цей режим добре підходить, якщо вам треба вставити запис, якщо його ще немає в таблиці або оновити запис, якщо він уже є.  Також є режим   IGNORE . У цьому режимі буде залишено старий запис і операція вставки не буде виконана.  Update  Ця анотація аналогічна   Insert , але вона не вставляє, а оновлює об'єкти в бд.     @  Update\n   void   update  (  Employee   employee);\n  Так само, як і з   Insert , ми можемо використовувати колекції та   varargs , щоб оновлювати кілька об'єктів одразу.   Update  шукає в бд запис за ключем. Якщо не знайде, то нічого не станеться. Якщо знайде, то оновить усі поля, а не тільки ті, які ми заповнили в   Entity  об'єкті.  Ми можемо отримати кількість оновлених записів. Для цього опишіть метод так, щоб він повертав   int .     @  Update\n   int   update  (  List  \u003C  Employee  >   employee);\n  Як і   Insert ,   Update  підтримує параметр   onConflict .  Delete  Методи з анотацією   Delete  видалятимуть об'єкти.     @  Delete\n   void   delete  (  Employee   employee);\n  У   Delete  методах ми також можемо використовувати колекції та   varargs , щоб видаляти кілька об'єктів одразу.   Delete  шукає в бд запис за ключем.  Ми можемо отримати кількість видалених записів. Для цього необхідно описати метод так, щоб він повертав   int .     @  Delete\n   int   delete  (  List  \u003C  Employee  >   employee);\n  Анотації   Insert ,   Update  і   Delete  дають змогу виконати прості операції. Для складніших дій необхідно використовувати SQL запити: INSERT, UPDATE і DELETE. Це можна зробити за допомогою анотації   Query .  Транзакції  Анотація   @Transaction  дає змогу виконувати кілька методів у межах однієї транзакції.  Розглянемо приклад, коли нам потрібно додати об'єкти   Car  і   Employee :     @  Dao\n   public   abstract   class   EmployeeCarDao   {\n    \n      @  Insert\n      public   abstract   void   insertEmployee  (  Employee   employee  );\n    \n      @  Insert\n      public   abstract   void   insertCar  (  Car   car  );\n    \n    \n      @  Transaction\n      public   void   insertCarAndEmployee  (  Car   car  ,   Employee   employee  ) {\n          insertCar  (car);\n          insertEmployee  (employee);\n      }\n    \n   }\n   EmployeeCarDao  - окремий   Dao  об'єкт для роботи з комбінацією   Car  і   Employee . У ньому описуємо методи для вставки об'єктів окремо, а потім обидва ці методи викликаємо в одному методі з анотацією   Transaction . У підсумку вставляться або обидва об'єкти, або, у разі виникнення помилки, жоден із них.  Зверніть увагу, що в цьому випадку   Dao  - не інтерфейс, а абстрактний клас.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":902,"path":903,"dir":862,"title":904,"description":905,"keywords":906,"body":911},"content:1.android:7.lesson7:4.query.md","/android/lesson7/query","Room. Query","У цьому уроці поговоримо докладніше про Query. У якому вигляді ми можемо отримувати дані: List, масив, Cursor, LiveData. Як передавати параметри. Як отримувати тільки деякі поля. Як за допомогою Query виконувати update і delete запити в Room.",[907,908,909,910],"List, масив, Cursor","Передача параметрів","Subsets","insert, update і delete запити","  Room. Query  У цьому уроці поговоримо докладніше про   Query . У якому вигляді ми можемо отримувати дані:   List , масив,   Cursor ,   LiveData . Як передавати параметри. Як отримувати тільки деякі поля. Як за допомогою   Query  виконувати   update  і   delete  запити в Room.  Як приклад будемо працювати з таким   Entity  класом:     @  Entity  ()\n   public   class   Employee   {\n    \n      @  PrimaryKey  ()\n      public   long   id;\n    \n      @  ColumnInfo  (  name   =   \"first_name\"  )\n      public   String   firstName;\n    \n      @  ColumnInfo  (  name   =   \"last_name\"  )\n      public   String   lastName;\n    \n      public   int   salary;\n    \n   }\n  List, масив, Cursor  Щоб запросити з бази   Employee -об'єкти, необхідно в   Dao  створити метод з анотацією   Query     @  Dao\n   public   interface   EmployeeDao   {\n    \n      @  Query  (  \"SELECT * FROM employee\"  )\n      List  \u003C  Employee  >   getAll  ();\n    \n      // ...\n    \n   }\n  У   Query  прописуємо запит, який має повернути дані. А як тип, що повертається, вказуємо List  .  Під час виклику цього методу Room зробить запит у таблицю employee, конвертує отримані дані в   Employee  об'єкти й упакує їх у   List .  Запит, який ви вказуєте в   Query , перевіряється на правильність синтаксису під час компіляції. Якщо в ньому буде помилка, система вам одразу підкаже це.  Замість   List , ми також можемо використовувати масив:     @  Query  (  \"SELECT * FROM employee\"  )\n   Employee  []   getAll  ();\n  і навіть   Cursor , якщо це необхідно з якихось причин:     @  Query  (  \"SELECT * FROM employee\"  )\n   Cursor   getAll  ();\n   LiveData  Room  вміє повертати дані в   LiveData  обгортці.     @  Query  (  \"SELECT * FROM employee\"  )\n   LiveData  \u003C  List  \u003C  Employee  >>   getAll  ();\n  Отримання даних у коді Activity має такий вигляд:     LiveData  \u003C  List  \u003C  Employee  >> employeesLiveData   =   db.  employeeDao  ().  getAll  ();\n    \n   employeesLiveData.  observe  (  this  ,   new   Observer  \u003C  List  \u003C  Employee  >>() {\n      @  Override\n      public   void   onChanged  (@  Nullable   List  \u003C  Employee  >   employees  ) {\n          log  (  \"onChanged \"   +   employees);\n      }\n   });\n  Отримуємо   LiveData  і підписуємося на нього.  Використання   LiveData  має величезну перевагу перед використанням списку або масиву. Підписавшись на   LiveData , ви отримуватимете свіжі дані під час їхньої зміни в базі. Тобто при додаванні нових, видаленні старих або оновленні поточних даних у таблиці   employee , Room знову виконає ваш   Query  запит, і ви отримаєте в   onChanged  методі актуальні дані з урахуванням останніх змін. Вам більше не треба самим запитувати ці дані щоразу. І все це буде приходити вам в UI потік.  Передача параметрів  У   Query  можна передавати параметри, щоб зробити запити більш конкретними.\nНаприклад, запит даних за   id     @  Query  (  \"SELECT * FROM employee WHERE id = :employeeId\"  )\n   Employee   getById  (  long   employeeId);\n  Перед параметром   employeeId  у запиті має стояти двокрапка. Room візьме значення цього параметра з методу і підставить його в запит.  Розглянемо ще кілька прикладів:  Пошук співробітників із зарплатою, більшою за задане значення     @  Query  (  \"SELECT * FROM employee WHERE salary > :minSalary\"  )\n   List  \u003C  Employee  >   getAllWithSalaryMoreThan  (  int   minSalary);\n  Пошук співробітників із зарплатою в заданому діапазоні     @  Query  (  \"SELECT * FROM employee WHERE salary BETWEEN :minSalary AND :maxSalary\"  )\n   List  \u003C  Employee  >   getAllWithSalaryBetween  (  int   minSalary,   int   maxSalary);\n  Пошук співробітників за ім'ям або прізвищем     @  Query  (  \"SELECT * FROM employee WHERE first_name LIKE :search OR last_name LIKE :search\"  )\n   List  \u003C  Employee  >   getAllWithNameLike  (  String   search);\n  Пошук співробітників за списком id.     @  Query  (  \"SELECT * FROM employee WHERE id IN (:idList)\"  )\n   List  \u003C  Employee  >   getByIdList  (  List  \u003C  Long  >   idList);\n  Subsets  Часто під час запиту даних нам потрібно отримати з таблиці не всі поля, а тільки деякі. Такі запити швидше і легше, ніж тягнути всі поля.  Припустимо, нам треба отримувати тільки ім'я та прізвище співробітника. Якщо зробити так:     @  Query  (  \"SELECT first_name, last_name FROM employee\"  )\n   List  \u003C  Employee  >   getNames  ();\n  то вже під час компіляції отримаємо помилку:   The columns returned by the query does not have the fields [id,salary] in Employee even though they are annotated as non-null or primitive . Стовпці, повернуті запитом:   first_name, last_name .  Room повідомляє, що в даних, які поверне цей запит, не вистачає полів, щоб заповнити всі поля об'єкта   Employee .  У цьому випадку ми можемо використовувати окремий об'єкт.     public   class   Name   {\n    \n      @  ColumnInfo  (  name   =   \"first_name\"  )\n      public   String   firstName;\n    \n      @  ColumnInfo  (  name   =   \"last_name\"  )\n      public   String   lastName;\n    \n   }\n  Зверніть увагу, що він не   Entity . Це звичайний клас. За допомогою   ColumnInfo  ми налаштовуємо імена полів, щоб вони збігалися з полями таблиці.  Використовуємо цей клас у методі запиту:     @  Query  (  \"SELECT first_name, last_name FROM employee\"  )\n   List  \u003C  Name  >   getNames  ();\n  Тепер усе ок, і ми отримаємо список   Name  об'єктів.  Ви також можете в цих не Entity класах використовувати вкладені класи з анотацією   @Embedded .  insert, update і delete запити  Анотації   Insert ,   Update  і   Delete  дають нам змогу модифікувати дані, але їхні можливості занадто обмежені. Часто виникає необхідність оновити тільки деякі поля або видалити записи за певною умовою. Це можна зробити запитами за допомогою   Query .  Давайте розглянемо кілька прикладів.  Оновлення зарплат у співробітників за списком id.     @  Query  (  \"UPDATE employee SET salary = :newSalary WHERE id IN (:idList)\"  )\n   int   updateSalaryByIdList  (  List  \u003C  Long  >   idList,   int   newSalary);\n  Опціонально метод може повертати   int  значення, в якому ми отримаємо кількість оновлених рядків. Якщо вам це не потрібно, то робіть метод void.  Виклик методу матиме такий вигляд:     int   updatedCount   =   db.  employeeDao  ().  updateSalaryByIdList  (Arrays.  asList  (  1L  ,   3L  ,   4L  ),   10000  );\n  Видалення співробітників за списком id     @  Query  (  \"DELETE from employee WHERE id IN (:idList)\"  )\n   int   deleteByIdList  (  List  \u003C  Long  >   idList);\n  Запити видалення також можуть повертати   int  значення, в якому ми отримаємо кількість видалених рядків.  Виклик методу:     int   deletedCount   =   db.  employeeDao  ().  deleteByIdList  (Arrays.  asList  (  1L  ,   3L  ,   4L  ));\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":913,"path":914,"dir":862,"title":915,"description":916,"keywords":917,"body":923},"content:1.android:7.lesson7:5.rxjava.md","/android/lesson7/rxjava","Room. RxJava","У цьому уроці розглянемо можливість спільного використання RxJava і Room. Як отримувати дані у Flowable, Single і Maybe.",[918,919,920,921,96,922],"Flowable","Single","Maybe","У якому випадку що краще використовувати?","Документація","  Room. RxJava  У цьому уроці розглянемо можливість спільного використання RxJava і Room. Як отримувати дані у   Flowable ,   Single  і   Maybe .  У   build.gradle  модуля додавайте dependencies     implementation   \"android.arch.persistence.room:rxjava2:1.0.0\"\n  Flowable  У Dao вказуємо для методу вихідний тип Flowable     @  Query  (  \"SELECT * FROM employee\"  )\n   Flowable  \u003C  List  \u003C  Employee  >>   getAll  ();\n  У коді підписуємося й отримуємо дані     db.  employeeDao  ().  getAll  ()\n          .  observeOn  (AndroidSchedulers.  mainThread  ())\n          .  subscribe  (  new   Consumer  \u003C  List  \u003C  Employee  >>() {\n              @  Override\n              public   void   accept  (  List  \u003C  Employee  >   employees  )   throws   Exception   {\n                  // ...\n              }\n          });\n   subscribeOn  у випадку з Flowable не потрібен. Запит до бази буде виконано не в UI потоці. А ось, щоб результат прийшов у UI потік, використовуємо   observeOn  Тепер при будь-якій зміні даних у базі, ми будемо отримувати свіжі дані в методі   accept . І нам не треба буде щоразу їх знову запитувати самим.  Якщо під час запиту декількох записів, замість   Flowable\u003CList\u003CEmployee>>  використовувати   Flowable\u003CEmployee> :     @  Query  (  \"SELECT * FROM employee\"  )\n   Flowable  \u003C  Employee  >   getAll  ();\n  то ми отримаємо тільки перший запис з усього результату  Якщо ж ми складаємо запит для отримання тільки одного запису, то   Flowable\u003CEmployee>  цілком підійде. Давайте розглянемо цей приклад докладніше.  Метод у   Dao     @  Query  (  \"SELECT * FROM employee WHERE id = :id\"  )\n   Flowable  \u003C  Employee  >   getById  (  long   id);\n  У коді підписуємося на   Flowable     db.  employeeDao  ().  getById  (  1  )\n          .  observeOn  (AndroidSchedulers.  mainThread  ())\n          .  subscribe  (  new   Consumer  \u003C  Employee  >() {\n              @  Override\n              public   void   accept  (  Employee   employee  )   throws   Exception   {\n                  // ...\n              }\n          });\n  Отже, ми запитуємо з бази запис за   id . І тут можливі варіанти.  Якщо запис є в базі, то він прийде в   accept  відразу ж після підписки. І під час кожного наступного оновлення цього запису в базі даних, він також приходитиме в   accept .  Якщо запису немає, то відразу після підписки нічого не прийде. А ось якщо він пізніше з'явиться, то він прийде в   accept .  У вищеописаного прикладу є мінус. Якщо запису немає в базі, то   Flowable  взагалі нічого нам не надішле. Тобто це буде виглядати так, ніби він все ще виконує запит.  Це можна виправити таким чином:     @  Query  (  \"SELECT * FROM employee WHERE id = :id\"  )\n   Flowable  \u003C  List  \u003C  Employee  >>   getById  (  long   id);\n  Хоч ми й очікуємо всього один запис, але використовуємо не   Flowable\u003CEmployee> , а   Flowable\u003CList\u003CEmployee>> . І якщо запису немає, то ми хоча б отримаємо порожній аркуш замість повної тиші.  Single  Розглянемо той самий приклад із запитом одного запису, але з використанням   Single . Нагадаю, що в   Single  може прийти тільки один   onNext , або   OnError . Після цього   Single  вважається завершеним.  Метод в Dao     @  Query  (  \"SELECT * FROM employee WHERE id = :id\"  )\n   Single  \u003C  Employee  >   getById  (  long   id);\n  У коді підписуємося     db.  employeeDao  ().  getById  (  1  )\n          .  subscribeOn  (Schedulers.  io  ())\n          .  observeOn  (AndroidSchedulers.  mainThread  ())\n          .  subscribe  (  new   DisposableSingleObserver  \u003C  Employee  >() {\n              @  Override\n              public   void   onSuccess  (  Employee   employee  ) {\n                  // ...\n              }\n    \n              @  Override\n              public   void   onError  (  Throwable   e  ) {\n                  // ...\n              }\n          });\n  На відміну від   Flowable , з   Single  необхідно використовувати   onSubscribe , щоб задати потік для виконання запиту. Інакше в   onError  прийде помилка:   java.lang.IllegalStateException: Cannot access database on the main thread since it may potentially lock the UI for a long period of time.  Знову розглядаємо варіанти наявності потрібного запису в базі.  Якщо такий запис у базі є, то він прийде в   onSuccess . Після цього   Single  вважатиметься завершеним і під час наступних оновлень цього запису нічого приходити вже не буде.  Якщо такого запису в базі немає, то ми в   onError  отримаємо помилку:   android.arch.persistence.room.EmptyResultSetException: Query returned empty result set: SELECT * FROM employee WHERE id = ? .\nПісля цього   Single  вважатиметься завершеним, і навіть якщо такий запис з'явиться в базі, то нам нічого приходити вже не буде.  Maybe  Розглянемо той самий приклад із запитом одного запису, але з використанням   Maybe . Нагадаю, що в   Maybe  може прийти або один   onNext , або   onComplete , або   OnError . Після цього   Maybe  вважається завершеним.  Метод в   Dao     @  Query  (  \"SELECT * FROM employee WHERE id = :id\"  )\n   Maybe  \u003C  Employee  >   getById  (  long   id);\n  У коді підписуємося     db.  employeeDao  ().  getById  (  1  )\n          .  subscribeOn  (Schedulers.  io  ())\n          .  observeOn  (AndroidSchedulers.  mainThread  ())\n          .  subscribe  (  new   DisposableMaybeObserver  \u003C  Employee  >() {\n              @  Override\n              public   void   onSuccess  (  Employee   employee  ) {\n                  // ...\n              }\n    \n              @  Override\n              public   void   onError  (  Throwable   e  ) {\n                  // ...\n              }\n    \n              @  Override\n              public   void   onComplete  () {\n                  // ...\n              }\n          });\n  З   Maybe  також необхідно використовувати   onSubscribe , щоб задати потік для виконання запиту.  Розглядаємо варіанти наявності необхідного запису в базі.  Якщо такий запис у базі є, то він прийде в   onSuccess . Після цього   Maybe  вважатиметься завершеним і під час наступних оновлень цього запису нічого приходити вже не буде.  Якщо такого запису в базі немає, то ми отримаємо onComplete. Після цього   Maybe  вважатиметься завершеним, і навіть якщо такий запис з'явиться в базі, то нам нічого приходити вже не буде.  У якому випадку що краще використовувати?   Flowable  підходить, якщо ви запитуєте дані і далі плануєте автоматично отримувати їх оновлення.   Single  і   Maybe  підходять для одноразового отримання даних. Різниця між ними в тому, що   Single  логічніше використовувати, якщо запис має бути в базі. Якщо його немає, вам прийде помилка. А   Maybe  допускає, що запису може і не бути.  Приклад  Крок 1: Залежності  Додайте необхідні залежності в   build.gradle :     dependencies {\n       implementation   'androidx.room:room-runtime:2.5.0'\n       implementation   'io.reactivex.rxjava3:rxjava:3.1.6'\n       implementation   'androidx.room:room-ktx:2.5.0'\n       implementation   'androidx.lifecycle:lifecycle-viewmodel-ktx:2.5.1'\n       implementation   'androidx.lifecycle:lifecycle-livedata-ktx:2.5.1'\n       annotationProcessor   'androidx.room:room-compiler:2.5.0'   // або kapt, якщо використовуєте Kotlin\n   }\n  Крок 2: Створення сутності (Entity)     @  Entity  (  tableName   =   \"users\"  )\n   public   class   User   {\n       @  PrimaryKey  (  autoGenerate   =   true  )\n       public   int   id;\n   \n       @  ColumnInfo  (  name   =   \"name\"  )\n       public   String   name;\n   \n       @  ColumnInfo  (  name   =   \"email\"  )\n       public   String   email;\n   \n       // Конструктори, геттери та сеттери\n       public   User  (  String   name  ,   String   email  ) {\n           this  .name   =   name;\n           this  .email   =   email;\n       }\n   }\n  Крок 3: Створення DAO     @  Dao\n   public   interface   UserDao   {\n   \n       // Використання Flowable для автоматичної підписки на зміни\n       @  Insert\n       Completable   insert  (  User   user  );\n   \n       @  Query  (  \"SELECT * FROM users\"  )\n       Flowable  \u003C  List  \u003C  User  >>   getAllUsers  ();\n   \n       // Використання Single для отримання одного елемента\n       @  Query  (  \"SELECT * FROM users WHERE id = :userId LIMIT 1\"  )\n       Single  \u003C  User  >   getUserById  (  int   userId  );\n   }\n  Крок 4: Репозиторій     public   class   UserRepository   {\n   \n       private   final   UserDao   userDao;\n   \n       public   UserRepository  (  Application   application  ) {\n           UserDatabase   db   =   UserDatabase.  getDatabase  (application);\n           this  .userDao   =   db.  userDao  ();\n       }\n   \n       // Отримання всіх користувачів як Flowable\n       public   Flowable  \u003C  List  \u003C  User  >>   getAllUsers  () {\n           return   userDao.  getAllUsers  ()\n                   .  subscribeOn  (Schedulers.  io  ())   // Підписка на IO потоці\n                   .  observeOn  (AndroidSchedulers.  mainThread  ());   // Оновлення UI на головному потоці\n       }\n   \n       // Отримання користувача за id як Single\n       public   Single  \u003C  User  >   getUserById  (  int   id  ) {\n           return   userDao.  getUserById  (id)\n                   .  subscribeOn  (Schedulers.  io  ()) \n                   .  observeOn  (AndroidSchedulers.  mainThread  ());\n       }\n   \n       // Вставка користувача\n       public   Completable   insertUser  (  User   user  ) {\n           return   userDao.  insert  (user)\n                   .  subscribeOn  (Schedulers.  io  ())\n                   .  observeOn  (AndroidSchedulers.  mainThread  ());\n       }\n   }\n  Крок 5: ViewModel     public   class   UserViewModel   extends   AndroidViewModel   {\n   \n       private   final   UserRepository   repository;\n       private   final   LiveData  \u003C  List  \u003C  User  >> allUsers;\n   \n       public   UserViewModel  (  Application   application  ) {\n           super  (application);\n           repository   =   new   UserRepository  (application);\n           allUsers   =   new   LiveData  \u003C  List  \u003C  User  >>() {\n               @  Override\n               protected   void   onActive  () {\n                   super  .  onActive  ();\n                   repository.  getAllUsers  ().  subscribe  (  new   Observer  \u003C  List  \u003C  User  >>() {\n                       @  Override\n                       public   void   onChanged  (  List  \u003C  User  >   users  ) {\n                           setValue  (users);   // оновлення LiveData з отриманими даними\n                       }\n                   });\n               }\n           };\n       }\n   \n       public   LiveData  \u003C  List  \u003C  User  >>   getAllUsers  () {\n           return   allUsers;\n       }\n   \n       public   void   addUser  (  User   user  ) {\n           repository.  insertUser  (user).  subscribe  ();\n       }\n   }\n  Крок 6: Інтеграція з UI (Activity)     public   class   UserActivity   extends   AppCompatActivity   {\n   \n       private   UserViewModel   userViewModel;\n   \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_user);\n   \n           // ініціалізація ViewModel\n           userViewModel   =   new   ViewModelProvider  (  this  ).  get  (UserViewModel.class);\n   \n           // Підписка на LiveData\n           userViewModel.  getAllUsers  ().  observe  (  this  , users   ->   {\n               // Оновлення UI при зміні даних\n               // Наприклад, оновлення RecyclerView\n           });\n   \n           // Додавання користувача через ViewModel\n           User   newUser   =   new   User  (  \"John Doe\"  ,   \"john.doe@example.com\"  );\n           userViewModel.  addUser  (newUser);\n       }\n   }\n  Пояснення:    Dao :   Використовуємо   Flowable  для отримання списку користувачів, щоб автоматично оновлювати UI при змінах.  Використовуємо   Single  для запиту одного елемента.  Використовуємо   Completable  для операцій, що не повертають результат, але можуть завершитись з помилкою (вставка).   Репозиторій :   Зберігає доступ до   Dao  і надає методи для взаємодії з даними. Використовуємо RxJava для асинхронних операцій.   ViewModel :   Отримує дані через репозиторій та підписується на зміни даних через RxJava (через LiveData).   UI :   Використовуємо   LiveData  для оновлення UI при зміні даних.  Переваги:    RxJava  дозволяє легко працювати з асинхронними операціями.   Flowable  автоматично оновлює UI при зміні даних у базі.   Single  для отримання одного результату.  Документація   https://developer.android.com/training/data-storage/room/async-queries#java  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":925,"path":926,"dir":862,"title":927,"description":928,"keywords":929,"body":939},"content:1.android:7.lesson7:6.relations.md","/android/lesson7/relations","Room. Запит із кількох таблиць. Relation","У цьому уроці розглянемо, як отримувати дані з декількох таблиць. А також розберемося, як використовувати анотацію Relation.",[930,931,932,933,934,935,936,937,935,938],"Relation","Relation + Transaction","Use the multimap return types approach","one-to-one relationships","one-to-many relationships","Запит до сутностей","many-to-many relationships","Визначення зв'язку","Вкладені запити","  Room. Запит із кількох таблиць. Relation  У цьому уроці розглянемо, як отримувати дані з декількох таблиць. А також розберемося, як використовувати анотацію Relation.  Для прикладу будемо використовувати дві таблиці:   співробітники  та   відділи . Кожен співробітник прикріплений до якогось відділу.   Entity  об'єкт для відділів:     @  Entity\n   public   class   Department   {\n    \n      @  PrimaryKey\n      public   int   id;\n    \n      public   String   name;\n    \n   }\n   Entity  об'єкт для співробітників:     @  Entity\n   public   class   Employee   {\n    \n      @  PrimaryKey\n      public   long   id;\n    \n      public   String   name;\n    \n      public   int   salary;\n    \n      @  ColumnInfo  (  name   =   \"department_id\"  )\n      public   int   departmentId;\n    \n   }\n  У полі   departmentId  зберігається   id  відділу, до якого прикріплений співробітник.  Ми хочемо отримати список працівників, у якому буде така інформація: ім'я працівника, його зарплата, найменування його відділу. Для цього нам треба буде написати запит, який витягне дані з двох таблиць.  Описуємо метод у   Dao  об'єкті     @  Dao\n   public   interface   EmployeeDao   {\n    \n      @  Query  (  \"SELECT employee.name, employee.salary, department.name AS department_name \"   +\n          \"FROM employee, department \"   +\n          \"WHERE department.id == employee.department_id\"  )\n      public   List  \u003C  EmployeeDepartment  >   getEmployeeWithDepartment  ();\n    \n      // ...\n      \n   }\n  Оскільки поле   name  є в обох таблицях, то для відділу перейменовуємо його в   department_name  Зверніть увагу на тип об'єктів, який ми будемо отримувати від цього методу. Це   EmployeeDepartment . Нам потрібно створити цей об'єкт і вказати в ньому всі поля, які ми очікуємо отримати від запиту.     public   class   EmployeeDepartment   {\n    \n      public   String   name;\n    \n      public   int   salary;\n    \n      @  ColumnInfo  (  name   =   \"department_name\"  )\n      public   String   departmentName;\n    \n   }\n  Це не   Entity  об'єкт, а звичайний клас. Поля цього класу мають збігатися з полями результату, який поверне запит. Room конвертує результати запиту в список цих об'єктів, і ми отримаємо те, що хотіли.  Relation  Анотація   Relation  також дає змогу робити запити з кількох таблиць, але структура результату буде трохи іншою. І нам самим не доведеться писати складні запити. Room усе зробить за нас.  Давайте уявимо, що нам треба отримати список відділів. І до кожного відділу має додаватися список співробітників.  Структура для цих даних матиме такий вигляд:     public   class   DepartmentWithEmployees   {\n    \n      public   int   id;\n    \n      public   String   name;\n    \n      @  Relation  (  parentColumn   =   \"id\"  ,   entityColumn   =   \"department_id\"  )\n      public   List  \u003C  Employee  > employees;\n  Це не   Entity , а звичайний клас. У полях   id  і   name  будуть дані відділу.  У   employees  буде список співробітників цього відділу. Для цього ми позначаємо список анотацією   Relation , і Room сам заповнить його для нас. Давайте розбиратися, як саме Room зрозуміє, що він має помістити в цей список. Звідки він братиме дані і за якою умовою?  Тип даних списку - це   Employee . Це   Entity  об'єкт, для нього в базі даних створено таблицю. З цієї таблиці Room і буде читати дані по співробітниках. У параметрах   parentColumn  і   entityColumn  вказуємо назви полів, які беруть участь в умові вибірки даних. У результаті Room шукатиме співробітників, у яких   entityColumn  (тобто   department_id ) дорівнює parentColumn (тобто   id ) відділу. Усі знайдені співробітники опиняться в   employees .  За вимогами Room, тип   employees  має бути   List  або   Set .  Залишилося описати метод у   Dao :     @  Dao\n   public   interface   DepartmentDao   {\n    \n      @  Query  (  \"SELECT id, name from department\"  )\n      List  \u003C  DepartmentWithEmployees  >   getDepartmentsWithEmployees  ();\n    \n      // ...\n      \n   }\n  Це простий запит, який витягне необхідні дані по відділу. А запит щодо співробітників для кожного відділу зробить за нас Room.  У класі   DepartmentWithEmployees  ми використовуємо поля   id  і   name  для даних по відділу. Але клас   Department  має точно таку саму структуру -   id  і   name . Тому ми в   DepartmentWithEmployees  можемо замінити ці поля на одне поле з типом   Department  і анотацією   Embedded :     public   class   DepartmentWithEmployees   {\n    \n      @  Embedded\n      public   Department   department;\n    \n      @  Relation  (  parentColumn   =   \"id\"  ,   entityColumn   =   \"department_id\"  )\n      public   List  \u003C  Employee  > employees;\n    \n   }\n  Припустімо, що нам потрібні не всі дані по співробітниках, а тільки деякі поля. Наприклад,   name  і   salary . Створюємо під них клас:     public   class   EmployeeNameAndSalary   {\n    \n      public   String   name;\n    \n      public   int   salary;\n    \n   }\n  І використовуємо його, як тип у Relation-списку     public   class   DepartmentWithEmployees   {\n    \n      public   int   id;\n    \n      public   String   name;\n    \n      @  Relation  (  parentColumn   =   \"id\"  ,   entityColumn   =   \"department_id\"  ,   entity   =   Employee.class)\n      public   List  \u003C  EmployeeNameAndSalary  > employees;\n    \n   }\n  А щоб Room знав, звідки брати дані по співробітниках, вказуємо   Entity  клас   Employee  у параметрі entity.   Relation  може бути вкладеним. Тобто в нашому прикладі клас   EmployeeNameAndSalary  також може містити в собі   Relation , який буде для кожного співробітника збирати, наприклад, список техніки, записаної на нього.   Relation  не може бути використаний в   Entity  класах, тільки у звичайних.   Relation  поле не може задаватися через конструктор. Воно має бути   public  або мати   public set -метод.  Relation + Transaction  При використанні   Relation , Room виконує кілька запитів, щоб зібрати всі дані. Має сенс виконувати всі ці запити в одній транзакції, щоб отримати коректні дані. Для цього можна використовувати анотацію   Transaction     @  Transaction\n   @  Query  (  \"SELECT id, name from department\"  )\n   List  \u003C  DepartmentWithEmployees  >   getDepartmentsWithEmployees  ();\n  Use the multimap return types approach  У підході з типом повернення multimap вам не потрібно визначати жодних додаткових класів даних. Замість цього ви визначаєте тип повернення мультикарти для вашого методу на основі потрібної вам структури відображення і визначаєте зв'язок між вашими сутностями безпосередньо у вашому SQL-запиті.  Наприклад, наступний метод запиту повертає відображення екземплярів   User  і   Book  для представлення користувачів бібліотеки з певними книгами, які вони взяли:     @  Query  (\n       \"SELECT * FROM user\"   +\n       \"JOIN book ON user.id = book.user_id\"\n   )\n   public   Map  \u003C  User,   List  \u003C  Book  >>   loadUserAndBookNames  ();\n  one-to-one relationships  Зв'язок «один-до-одного» між двома сутностями - це зв'язок, де кожному екземпляру батьківської сутності відповідає рівно один екземпляр дочірньої сутності, і навпаки.  Наприклад, розглянемо додаток для потокового прослуховування музики, де користувач має власну бібліотеку пісень. Кожен користувач має лише одну бібліотеку, і кожна бібліотека відповідає точно одному користувачеві. Отже, між сутністю   User  та сутністю   Library  існує зв'язок один-до-одного.  Визначте зв'язок  Щоб визначити зв'язок «один-до-одного», спочатку створіть клас для кожної з двох сутностей. Одна з сутностей повинна містити змінну, яка є посиланням на первинний ключ іншої сутності.     @  Entity\n   public   class   User   {\n       @  PrimaryKey   public   long   userId;\n       public   String   name;\n       public   int   age;\n   }\n   \n   @  Entity\n   public   class   Library   {\n       @  PrimaryKey   public   long   libraryId;\n       public   long   userOwnerId;\n   }\n  Запит до сутностей  Щоб зробити запит до списку користувачів і відповідних бібліотек, ви повинні спочатку змоделювати зв'язок один-до-одного між цими двома сутностями.  Для цього створіть новий клас даних, кожен екземпляр якого містить екземпляр батьківської сутності і відповідний екземпляр дочірньої сутності. Додайте анотацію   @Relation  до екземпляра дочірньої сутності, встановивши   parentColumn  як назву стовпця первинного ключа батьківської сутності, а   entityColumn  - як назву стовпця дочірньої сутності, який посилається на первинний ключ батьківської сутності.     public   class   UserAndLibrary   {\n       @  Embedded   public   User   user;\n       @  Relation  (\n            parentColumn   =   \"userId\"  ,\n            entityColumn   =   \"userOwnerId\"\n       )\n       public   Library   library;\n   }\n  Нарешті, додайте до класу DAO метод, який повертає всі екземпляри класу даних, що зв'язує батьківську сутність і дочірню сутність. Цей метод вимагає від Room виконання двох запитів. Тому вам слід додати до цього методу анотацію   @Transaction . Це гарантує, що вся операція виконується атомарно.     @  Transaction\n   @  Query  (  \"SELECT * FROM User\"  )\n   public   List  \u003C  UserAndLibrary  >   getUsersAndLibraries  ();\n  one-to-many relationships  Зв'язок «один-до-багатьох» між двома сутностями - це зв'язок, де кожному екземпляру батьківської сутності відповідає нуль або більше екземплярів дочірньої сутності, але кожен екземпляр дочірньої сутності може відповідати лише одному екземпляру батьківської сутності.  У прикладі програми для потокового прослуховування музики, припустимо, що користувач має можливість організовувати свої пісні у плейлисти. Кожен користувач може створити стільки плейлистів, скільки захоче, але кожен плейлист створює лише один користувач. Отже, між сутністю   User  (Користувач) та сутністю   Playlist  (Список відтворення) існує зв'язок один-до-багатьох.  Визначення зв'язку  Щоб визначити зв'язок «один-до-багатьох», спочатку створіть клас для двох сутностей. Як і у випадку зв'язку «один-до-одного», дочірня сутність повинна містити змінну, яка є посиланням на первинний ключ батьківської сутності.     @  Entity\n   public   class   User   {\n       @  PrimaryKey   public   long   userId;\n       public   String   name;\n       public   int   age;\n   }\n   \n   @  Entity\n   public   class   Playlist   {\n       @  PrimaryKey   public   long   playlistId;\n       public   long   userCreatorId;\n       public   String   playlistName;\n   }\n  Запит до сутностей  Щоб зробити запит до списку користувачів і відповідних плейлистів, спочатку потрібно змоделювати зв'язок «один-до-багатьох» між двома сутностями  Для цього створіть новий клас даних, кожен екземпляр якого містить екземпляр батьківської сутності та список усіх відповідних екземплярів дочірніх сутностей. Додайте анотацію   @Relation  до екземпляра дочірньої сутності, встановивши   parentColumn  як назву стовпця первинного ключа батьківської сутності, а   entityColumn  - як назву стовпця дочірньої сутності, який посилається на первинний ключ батьківської сутності.     @  Transaction\n   @  Query  (  \"SELECT * FROM User\"  )\n   public   List  \u003C  UserWithPlaylists  >   getUsersWithPlaylists  ();\n  many-to-many relationships  Зв'язок «багато-до-багатьох» між двома сутностями - це зв'язок, де кожному екземпляру батьківської сутності відповідає нуль або більше екземплярів дочірньої сутності, і навпаки.  У прикладі програми для потокового відтворення музики розглянемо пісні у визначених користувачем списках відтворення. Кожен плейлист може містити багато пісень, а кожна пісня може бути частиною багатьох різних плейлистів. Отже, між сутністю   Playlist  і сутністю   Song  існує зв'язок «багато до багатьох».  Визначення зв'язку  Щоб визначити зв'язок «багато до багатьох», спочатку створіть клас для кожної з двох сутностей. Зв'язок «багато-до-багатьох» відрізняється від інших типів зв'язків тим, що в дочірніх сутностях, як правило, немає посилань на батьківську сутність. Замість цього створіть третій клас для представлення асоціативної сутності, або таблиці перехресних посилань, між двома сутностями. Таблиця перехресних посилань повинна мати стовпці для первинного ключа кожної сутності у зв'язку «багато-до-багатьох», представленої в таблиці. У цьому прикладі кожен рядок у таблиці перехресних посилань відповідає парі екземплярів   Playlist  і   Song , де пісня, на яку є посилання, входить до списку відтворення, на який є посилання.     @  Entity\n   public   class   Playlist   {\n       @  PrimaryKey   public   long   playlistId;\n       public   String   playlistName;\n   }\n   \n   @  Entity\n   public   class   Song   {\n       @  PrimaryKey   public   long   songId;\n       public   String   songName;\n       public   String   artist;\n   }\n   \n   @  Entity  (  primaryKeys   =   {  \"playlistId\"  ,   \"songId\"  })\n   public   class   PlaylistSongCrossRef   {\n       public   long   playlistId;\n       public   long   songId;\n   }\n  Запит до сутностей  Наступний крок залежить від того, як ви хочете запитувати ці пов'язані сутності.   Якщо ви хочете запитувати списки відтворення і список відповідних пісень для кожного списку відтворення, створіть новий клас даних, який міститиме один об'єкт   Playlist  і список усіх об'єктів   Song , що входять до списку відтворення.  Якщо ви хочете запитувати пісні та список відповідних плейлистів для кожної з них, створіть новий клас даних, який містить один об'єкт   Song  і список усіх об'єктів   Playlist , до яких входить пісня.  У будь-якому випадку змоделюйте зв'язок між об'єктами за допомогою властивості   associateBy  в анотації   @Relation  у кожному з цих класів, щоб визначити об'єкт перехресного посилання, який забезпечує зв'язок між об'єктом   Playlist  і об'єктом   Song .     public   class   PlaylistWithSongs   {\n       @  Embedded   public   Playlist   playlist;\n       @  Relation  (\n            parentColumn   =   \"playlistId\"  ,\n            entityColumn   =   \"songId\"  ,\n            associateBy   =   @  Junction  (PlaylistSongCrossref.class)\n       )\n       public   List  \u003C  Song  > songs;\n   }\n   \n   public   class   SongWithPlaylists   {\n       @  Embedded   public   Song   song;\n       @  Relation  (\n            parentColumn   =   \"songId\"  ,\n            entityColumn   =   \"playlistId\"  ,\n            associateBy   =   @  Junction  (PlaylistSongCrossref.class)\n       )\n       public   List  \u003C  Playlist  > playlists;\n   }\n  Нарешті, додайте метод до класу DAO, щоб розкрити функцію запиту, яка потрібна вашому додатку.    getPlaylistsWithSongs : цей метод робить запит до бази даних і повертає всі отримані об'єкти   PlaylistWithSongs .   getSongsWithPlaylists : цей метод робить запит до бази даних і повертає всі отримані об'єкти   SongWithPlaylists .  Кожен з цих методів вимагає від Room виконання двох запитів, тому додайте до обох методів анотацію   @Transaction , щоб вся операція виконувалася атомарно.     @  Transaction\n   @  Query  (  \"SELECT * FROM Playlist\"  )\n   public   List  \u003C  PlaylistWithSongs  >   getPlaylistsWithSongs  ();\n   \n   @  Transaction\n   @  Query  (  \"SELECT * FROM Song\"  )\n   public   List  \u003C  SongWithPlaylists  >   getSongsWithPlaylists  ();\n  Вкладені запити   https://developer.android.com/training/data-storage/room/relationships/nested  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":941,"path":942,"dir":862,"title":943,"description":944,"keywords":945,"body":948},"content:1.android:7.lesson7:7.views.md","/android/lesson7/views","Views","Починаючи з версії 2.1.0, бібліотека персистентності Room надає підтримку представлень баз даних SQLite, що дозволяє інкапсулювати запит у клас. Room називає ці класи з підтримкою запитів views, і вони поводяться так само, як прості об'єкти даних, коли використовуються у DAO.",[946,947],"Створення view","Зв'язування подання з базою даних","  Views  Починаючи з версії 2.1.0, бібліотека персистентності Room надає підтримку представлень баз даних SQLite, що дозволяє інкапсулювати запит у клас. Room називає ці класи з підтримкою запитів views, і вони поводяться так само, як прості об'єкти даних, коли використовуються у DAO.  Створення view  Щоб створити view, додайте до класу анотацію   @DatabaseView . Встановіть значення анотації на запит, який повинен представляти клас.  У наступному фрагменті коду наведено приклад представлення:      @DatabaseView  (  \"SELECT user.id, user.name, user.departmentId,\"   +\n         \"department.name AS departmentName FROM user \"   +\n         \"INNER JOIN department ON user.departmentId = department.id\"  )\n   data   class   UserDetail  (\n     val   id:   Long  ,\n     val   name:   String  ?,\n     val   departmentId:   Long  ,\n     val   departmentName:   String  ?\n   )\n     @  DatabaseView  (  \"SELECT user.id, user.name, user.departmentId,\"   +\n               \"department.name AS departmentName FROM user \"   +\n               \"INNER JOIN department ON user.departmentId = department.id\"  )\n   public   class   UserDetail   {\n     public   long   id;\n     public   String   name;\n     public   long   departmentId;\n     public   String   departmentName;\n   }\n  Зв'язування подання з базою даних  Щоб включити подання як частину бази даних вашого додатка, додайте властивість   views  до анотації   @Database  вашого додатка:      @Database  (entities   =   [User::  class  ],\n           views   =  [UserDetail::  class  ], version   =   1  )\n   abstract   class   AppDatabase   :   RoomDatabase  () {\n     abstract   fun   userDao  ():   UserDao\n   }\n     @  Database  (  entities   =   {User.class},   views   =   {UserDetail.class},\n           version   =   1  )\n   public   abstract   class   AppDatabase   extends   RoomDatabase   {\n     public   abstract   UserDao   userDao  ();\n   }\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":950,"path":951,"dir":862,"title":952,"description":953,"keywords":954,"body":955},"content:1.android:7.lesson7:8.type-converter.md","/android/lesson7/type-converter","Room. Type converter","У цьому уроці розглянемо, як використовувати конвертери типів даних, щоб Room міг зберігати не тільки поля-примітиви.",[],"  Room. Type converter  У цьому уроці розглянемо, як використовувати конвертери типів даних, щоб Room міг зберігати не тільки поля-примітиви.  Іноді ваші Entity об'єкти можуть містити поля, які не є примітивами, і не можуть бути збережені в БД.  Як приклад розглянемо клас працівника. У нього цілком може бути поле, в якому ми хочемо перерахувати його хобі. Використовуємо для цього поле hobbies з типом   List\u003CString>     @  Entity  ()\n   public   class   Employee   {\n    \n      @  PrimaryKey\n      public   long   id;\n    \n      public   String   name;\n    \n      public   int   salary;\n    \n      public   List  \u003C  String  > hobbies;\n    \n   }\n  Якщо ми спробуємо зараз скомпілювати проєкт, то отримаємо помилку:   Cannot figure out how to save this field into database. You can consider adding a type converter for it.  Room справедливо зауважує, що й гадки не має, як йому таке поле зберегти в базу, і пропонує використовувати   type converter .  Ок, давайте створимо конвертер. Він має вміти конвертувати   List\u003CString>  у який-небудь простий тип, який може бути збережений у базу, наприклад,   String . Також конвертер має вміти конвертувати у зворотний бік, тобто зі   String  у   List\u003CString> , щоб Room міг прочитати дані з бази в поле   Entity  об'єкта.  Створюємо конвертер:     public   class   HobbiesConverter   {\n    \n      @  TypeConverter\n      public   String   fromHobbies  (  List  \u003C  String  >   hobbies  ) {\n          return   hobbies.  stream  ().  collect  (Collectors.  joining  (  \",\"  ));\n      }\n    \n      @  TypeConverter\n      public   List  \u003C  String  >   toHobbies  (  String   data  ) {\n          return   Arrays.  asList  (data.  split  (  \",\"  ));\n      }\n    \n   }\n  Перший метод перетворює   List\u003CString>  на   String . Другий - навпаки. Обидва методи позначаємо анотацією   TypeConverter .  Залишилося вказати цей конвертер для поля   hobbies . Це робиться анотацією   TypeConverters  із зазначенням класу конвертера.     @  Entity  ()\n   public   class   Employee   {\n    \n      @  PrimaryKey\n      public   long   id;\n    \n      public   String   name;\n    \n      public   int   salary;\n    \n      @  TypeConverters  ({HobbiesConverter.class})\n      public   List  \u003C  String  > hobbies;\n    \n   }\n  Тепер Room знатиме, що для поля   hobbies  він може використовувати конвертер   HobbiesConverter .  Конвертер також можна вказати для всього   Entity  об'єкта. Це може бути корисно, якщо у вас в   Entity  кілька полів потребують конвертери. Ви створюєте один клас, там прописуєте всі необхідні методи перетворення полів, і вказуєте цей клас для всього   Entity .     @  Entity  ()\n   @  TypeConverters  ({EmployeeConverter.class})\n   public   class   Employee   {\n    \n      @  PrimaryKey\n      public   long   id;\n    \n      public   String   name;\n    \n      public   int   salary;\n    \n      public   List  \u003C  String  > hobbies;\n    \n   }\n  Бувають випадки, коли перетворення може бути необхідним не тільки для Entity об'єкта. Розглянемо приклад.  Є Entity клас     @  Entity  ()\n   public   class   Employee   {\n    \n      @  PrimaryKey\n      public   long   id;\n    \n      public   String   name;\n    \n      public   int   salary;\n    \n      public   long   birthday;\n    \n   }\n  У працівника всі поля є простими, і Room без проблем може їх зберегти/прочитати. Цим полям не потрібні конвертери.  Але що якщо ми хочемо в Dao зробити так:     @  Dao\n   public   interface   EmployeeDao   {\n    \n      @  Query  (  \"SELECT * FROM employee WHERE birthday = :birthdayDate\"  )\n      Employee   getByDate  (  Date   birthdayDate  );\n    \n   }\n  Тобто нам для пошуку за полем   birthday  (з типом long) зручніше використовувати об'єкт Date.  Під час спроби зібрати проєкт отримуємо помилку:   Query method parameters should either be a type that can be converted into a database column or a List / Array that contains such type . Для цього можна розглянути можливість додавання   Type Adapter .  Room повідомляє, що типи не збігаються і знову пропонує використовувати конвертери.  Створюємо конвертер:     public   class   DateConverter   {\n    \n      @  TypeConverter\n      public   Long   dateToTimestamp  (  Date   date  ) {\n          if   (date   ==   null  ) {\n              return   null  ;\n          }   else   {\n              return   date.  getTime  ();\n          }\n      }\n    \n   }\n  У нашому випадку необхідно   Date  конвертувати в   long , щоб Room міг виконати   query  запит. Створюємо для цього метод   dateToTimestamp .  Зворотна конвертація нам не потрібна. У Room немає необхідності конвертувати   long  у   Date . Об'єкт   Employee  міститиме дату у форматі   long .  Конвертер прописуємо в   Dao , прямо для конкретного параметра конкретного методу     @  Dao\n   public   interface   EmployeeDao   {\n    \n      @  Query  (  \"SELECT * FROM employee WHERE birthday = :birthday\"  )\n      Employee   getByDate  (@  TypeConverters  ({DateConverter.class})   Date   birthday  );\n   }\n  Тепер Room конвертує   Date  в   long  і запит буде виконано.  Також конвертер можна прописати для всього методу, а не окремого параметра     @  Dao\n   public   interface   EmployeeDao   {\n    \n      @  Query  (  \"SELECT * FROM employee WHERE birthday BETWEEN :birthdayFrom and :birthdayTo\"  )\n      @  TypeConverters  ({DateConverter.class})\n      Employee   getByDate  (  Date   birthdayFrom  ,   Date   birthdayTo  );\n   }\n  У цьому разі Room зможе використовувати конвертер для перетворення всіх параметрів методу.  Якщо ж прописати конвертер для   Dao , то він буде доступний усім методам цього   Dao     @  Dao\n   @  TypeConverters  ({DateConverter.class})\n   public   interface   EmployeeDao   {\n    \n      ...\n   }\n  Ну і найглобальніше рішення - прописати конвертер для   Database     @  Database  (  entities   =   {Employee.class},   version   =   1  )\n   @  TypeConverters  ({DateConverter.class})\n   public   abstract   class   AppDatabase   extends   RoomDatabase   {\n      public   abstract   EmployeeDao   employeeDao  ();\n   }\n  У цьому разі Room зможе використовувати його у всіх   Entity  і   Dao .  Якщо у вас кілька конвертерів, вказуйте їх через кому.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":957,"path":958,"dir":862,"title":959,"description":960,"keywords":961,"body":964},"content:1.android:7.lesson7:9.prepopulate.md","/android/lesson7/prepopulate","Prepopulate","Іноді вам може знадобитися, щоб ваша програма починала роботу з базою даних, яка вже завантажена певним набором даних. Це називається попереднім заповненням бази даних. У версії Room 2.2.0 і вище ви можете використовувати методи API для попереднього заповнення бази даних Room під час ініціалізації вмістом з попередньо запакованого файлу бази даних у файловій системі пристрою.",[962,963],"Попереднє заповнення з app asset","Prepopulate from the file system","  Prepopulate  Іноді вам може знадобитися, щоб ваша програма починала роботу з базою даних, яка вже завантажена певним набором даних. Це називається попереднім заповненням бази даних. У версії Room 2.2.0 і вище ви можете використовувати методи API для попереднього заповнення бази даних Room під час ініціалізації вмістом з попередньо запакованого файлу бази даних у файловій системі пристрою.  Попереднє заповнення з app asset  Щоб попередньо заповнити базу даних Room з готового файлу бази даних, який знаходиться в будь-якому місці в   assets/  вашого додатку, викличте метод   createFromAsset()  з вашого об'єкта   RoomDatabase.Builder  перед викликом   build() :      Room.  databaseBuilder  (appContext, AppDatabase::  class  .java,   \"Sample.db\"  )\n     .  createFromAsset  (  \"database/myapp.db\"  )\n     .  build  ()\n     Room.  databaseBuilder  (appContext, AppDatabase.class,   \"Sample.db\"  )\n     .  createFromAsset  (  \"database/myapp.db\"  )\n     .  build  ();\n  Метод   createFromAsset()  приймає рядковий аргумент, який містить відносний шлях від каталогу   assets/  до файлу попередньо упакованої бази даних.  Prepopulate from the file system  Щоб попередньо заповнити базу даних Room з готового файлу бази даних, який знаходиться у будь-якому місці файлової системи пристрою, окрім   assets/  вашого додатку, викличте метод   createFromFile()  з вашого об'єкта   RoomDatabase.Builder  перед викликом   build() :      Room.  databaseBuilder  (appContext, AppDatabase::  class  .java,   \"Sample.db\"  )\n     .  createFromFile  (  File  (  \"mypath\"  ))\n     .  build  ()\n     Room.  databaseBuilder  (appContext, AppDatabase.class,   \"Sample.db\"  )\n     .  createFromFile  (  new   File  (  \"mypath\"  ))\n     .  build  ();\n  Метод   createFromFile()  приймає аргумент   File  для попередньо упакованого файлу бази даних. Room створює копію вказаного файлу, а не відкриває його безпосередньо, тому переконайтеся, що ваша програма має права на читання цього файлу.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":966,"path":967,"dir":862,"title":968,"description":969,"keywords":970,"body":971},"content:1.android:7.lesson7:10.migrations.md","/android/lesson7/migrations","Room. Міграція версій бази даних","У цьому уроці розглянемо, як виконується міграція версій бази даних у Room",[],"  Room. Міграція версій бази даних  У цьому уроці розглянемо, як виконується міграція версій бази даних у Room  Якщо ви працювали зі стандартними механізмами SQLite в Android, то ви знаєте, що коли ви міняєте структуру бази даних, вам необхідно піднімати версію бази даних і писати SQL запити, які виконають оновлення.  У Room все точно так само. Давайте розглянемо приклад.  У нас є   Entity  клас працівника     @  Entity  ()\n   public   class   Employee   {\n   \n      @  PrimaryKey\n      public   long   id;\n   \n      public   String   name;\n   \n      public   int   salary;\n   \n   }\n  Додамо йому поле   birthday     @  Entity  ()\n   public   class   Employee   {\n   \n      @  PrimaryKey\n      public   long   id;\n   \n      public   String   name;\n   \n      public   int   salary;\n   \n      public   long   birthday;\n   \n   }\n  Тепер під час запуску програми ми в логах побачимо помилку:   java.lang.IllegalStateException: Room cannot verify the data integrity . Схоже, ви змінили схему, але забули оновити номер версії. Ви можете просто виправити це, збільшивши номер версії  Room повідомляє, що ми вирішили змінити структуру бази даних, а номер версії не змінили.  Ок, виправляємося, і піднімаємо версію бази в   Database  класі.     @  Database  (  entities   =   {Employee.class},   version   =   2  )\n   public   abstract   class   AppDatabase   extends   RoomDatabase   {\n      public   abstract   EmployeeDao   employeeDao  ();\n   }\n  Запускаємо застосунок і знову помилка:   java.lang.IllegalStateException: Необхідна міграція з 1 на 2 . Будь ласка, надайте міграцію в білдері або викличте   fallbackToDestructiveMigration  в білдері, і в цьому випадку Room заново створить усі таблиці.  Цього разу Room каже, що йому потрібна міграція - тобто SQL-запит, який змінить структуру бази даних так, щоб ця структура відповідала Entity класам. Так, Room поки що не вміє самостійно визначати зміни Entity класів і змінювати під них структуру бази даних.  Або, як варіант, ми можемо використовувати   fallbackToDestructiveMigration  у білдері створення бази:     database   =   Room.  databaseBuilder  (  this  , AppDatabase.class,   \"database\"  )\n          .  fallbackToDestructiveMigration  ()\n          .  build  ();\n  У цьому випадку міграцію можна не налаштовувати. Але якщо під час запуску застосунку Room побачить, що необхідна міграція, то він просто перестворить базу відповідно до нової структури Entity класів, і всі дані пропадуть. Так собі варіант, особливо з точки зору користувача. Він втратить усі свої дані.  Давайте зробимо міграцію. Ми в Entity клас Employee додали нове поле   birthday . Відповідно в таблицю Employee нам також треба додати нове поле   birthday .  Створюємо об'єкт   Migration :     public   static   final   Migration   MIGRATION_1_2   =   new   Migration  (  1  ,   2  ) {\n      @  Override\n      public   void   migrate  (  final   SupportSQLiteDatabase   database  ) {\n          database.  execSQL  (  \"ALTER TABLE Employee ADD COLUMN birthday INTEGER DEFAULT 0 NOT NULL\"  );\n      }\n   };\n  У конструкторі вказуємо стару і нову версію бази. Відповідно, під час міграції бази з версії 1 на 2 Room викличе метод   migrate  цього Migration об'єкта і в таблиці   Employee  буде створено нове поле.  У якому саме класі створювати об'єкт   MIGRATION_1_2  - справа смаку. Як варіант, можна в   AppDatabase .  Залишилося передати цей об'єкт у білдер бази.     database   =   Room.  databaseBuilder  (  this  , AppDatabase.class,   \"database\"  )\n          .  addMigrations  (AppDatabase.MIGRATION_1_2)\n          .  allowMainThreadQueries  ()\n          .  build  ();\n  У методі   addMigration  вказуємо міграцію.  Якщо міграцій кілька, то їх можна перерахувати через кому.     .  addMigrations  (AppDatabase.MIGRATION_1_2, AppDatabase.MIGRATION_2_3, AppDatabase.MIGRATION_3_4)\n  Якщо користувач з першої версії бази оновиться на четверту, то всі ці міграції будуть виконані одна за одною.  У наступному уроці розглянемо, як написати тест для міграції.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":973,"path":974,"dir":862,"title":975,"description":976,"keywords":977,"body":980},"content:1.android:7.lesson7:11.testing.md","/android/lesson7/testing","Room. Тестування","У цьому уроці розглянемо, як тестувати Room. Напишемо кілька тестів для Dao і протестуємо міграцію.",[867,978,979],"Міграція","Схеми","  Room. Тестування  У цьому уроці розглянемо, як тестувати Room. Напишемо кілька тестів для   Dao  і протестуємо міграцію.  Dao  У   Dao  ви прописуєте різні операції з   Entity  об'єктами: читання, вставка, зміна, видалення.  Приклад   Dao :     @  Dao\n   public   interface   EmployeeDao   {\n    \n      @  Query  (  \"SELECT * FROM employee\"  )\n      List  \u003C  Employee  >   getAll  ();\n    \n      @  Query  (  \"SELECT * FROM employee ORDER BY salary DESC\"  )\n      List  \u003C  Employee  >   getAllOrderBySalary  ();\n    \n      @  Insert\n      void   insert  (  Employee   employee  );\n    \n      @  Insert\n      void   insertAll  (  List  \u003C  Employee  >   employees  );\n    \n      @  Update\n      int   update  (  Employee   employee  );\n    \n      @  Delete\n      void   delete  (  Employee   employee  );\n    \n      @  Query  (  \"DELETE FROM employee\"  )\n      void   deleteAll  ();\n   }\n  Для цих методів можна написати кілька тестів.  Я ж одразу покажу вміст тестового класу.     @  RunWith  (AndroidJUnit4.class)\n   public   class   EmployeeDaoTest   {\n    \n      private   AppDatabase   db;\n      private   EmployeeDao   employeeDao;\n    \n      @  Before\n      public   void   createDb  ()   throws   Exception   {\n          db   =   Room.  inMemoryDatabaseBuilder  (\n                  InstrumentationRegistry.  getContext  (),\n                  AppDatabase.class)\n                  .  build  ();\n          employeeDao   =   db.  employeeDao  ();\n    \n      }\n    \n      @  After\n      public   void   closeDb  ()   throws   Exception   {\n          db.  close  ();\n      }\n    \n   }\n  Зверніть увагу, що тест інструментальний. Тобто його треба буде запускати на пристрої або емуляторі.  У змінній   db  буде зберігатися база. При її створенні ми використовували метод   inMemoryDatabaseBuilder . У результаті під час запуску тесту дані бази перебуватимуть у пам'яті та після завершення тесту будуть видалені.  У   Before  методі ми створюємо базу і Dao, а в   After  методі - закриваємо базу.  Розглянемо кілька можливих тестових методів  Вставляємо один запис і перевіряємо, що він же зчитувався.     @  Test\n   public   void   whenInsertEmployeeThenReadTheSameOne  () throws Exception {\n      List  \u003C  Employee  > employees   =   EmployeeTestHelper.  createListOfEmployee  (  1  );\n      \n      employeeDao.  insert  (employees.  get  (  0  ));\n      List  \u003C  Employee  > dbEmployees   =   employeeDao.  getAll  ();\n      \n      assertEquals  (  1  , dbEmployees.  size  ());\n      assertTrue  (EmployeeTestHelper.  employeesAreIdentical  (employees.  get  (  0  ), dbEmployees.  get  (  0  )));\n   }\n  На допомогу собі я створив клас   EmployeeTestHelper , який має кілька корисних методів:    createListOfEmployee  створює список із зазначеною кількістю   Employee  об'єктів, заповнених рандомними даними   employeesAreIdentical  перевіряє, що всі два зазначених   Employee  об'єкти рівні за всіма полями  Наступний тест перевірить, що під час виклику методу update запис має оновитися в базі.     @  Test\n   public   void   whenUpdateEmployeeThenReadTheSameOne  () throws Exception {\n      List  \u003C  Employee  > employees   =   EmployeeTestHelper.  createListOfEmployee  (  1  );\n      Employee   employee   =   employees.  get  (  0  );\n      employeeDao.  insert  (employee);\n    \n      employee.salary   +=   100  ;\n      employee.name   +=   \" test\"  ;\n      employeeDao.  update  (employee);\n    \n      List  \u003C  Employee  > dbEmployees   =   employeeDao.  getAll  ();\n      assertTrue  (EmployeeTestHelper.  employeesAreIdentical  (employees.  get  (  0  ), dbEmployees.  get  (  0  )));\n   }\n  Під час вставки кількох записів, усі вони мають опинитися в базі     @  Test\n   public   void   whenInsertEmployeesThenReadThem  () throws Exception {\n      List  \u003C  Employee  > employees   =   EmployeeTestHelper.  createListOfEmployee  (  5  );\n    \n      employeeDao.  insertAll  (employees);\n    \n      assertEquals  (  5  , employeeDao.  getAll  ().  size  ());\n   }\n  Метод   deleteAll  очищає всю базу.     @  Test\n   public   void   whenDeleteAllThenReadNothing  () throws Exception {\n      List  \u003C  Employee  > employees   =   EmployeeTestHelper.  createListOfEmployee  (  5  );\n      employeeDao.  insertAll  (employees);\n    \n      employeeDao.  deleteAll  ();\n    \n      assertTrue  (employeeDao.  getAll  ().  isEmpty  ());\n   }\n  Метод   getAllOrderBySalary  повинен повертати дані відсортовані за зарплатою     @  Test\n   public   void   checkOrderBySalary  () throws Exception {\n      List  \u003C  Employee  > employees   =   EmployeeTestHelper.  createListOfEmployee  (  5  );\n      employeeDao.  insertAll  (employees);\n      Collections.  sort  (employees,   new   Comparator  \u003C  Employee  >() {\n          @  Override\n          public   int   compare  (  Employee   o1  ,   Employee   o2  ) {\n              return   o2.salary   -   o1.salary;\n          }\n      });\n    \n      assertEquals  (employees, employeeDao.  getAllOrderBySalary  ());\n   }\n  Щоб останній метод працював коректно, необхідно додати реалізацію методів   equals  і   hashcode  для   Employee     @  Entity  ()\n   public   class   Employee   {\n    \n      @  PrimaryKey\n      public   long   id;\n    \n      public   String   name;\n    \n      public   int   salary;\n    \n      @  Override\n      public   boolean   equals  (  Object   o  ) {\n          if   (  this   ==   o)   return   true  ;\n          if   (o   ==   null   ||   getClass  ()   !=   o.  getClass  ())   return   false  ;\n    \n          Employee   employee   =   (Employee) o;\n    \n          return   id   ==   employee.id;\n      }\n    \n      @  Override\n      public   int   hashCode  () {\n          return   (  int  ) (id   ^   (id   >>>   32  ));\n      }\n    \n   }\n  Міграція  Розглянемо тестування міграції на простому прикладі. У нас є база версії 1 і Entity клас.     @  Entity  ()\n   public   class   Employee   {\n    \n      @  PrimaryKey\n      public   long   id;\n    \n      public   String   name;\n    \n      public   int   salary;\n    \n   }\n  Ми додамо нове поле в цей клас, налаштуємо міграцію і створимо тест міграції.  Спочатку необхідно налаштувати експорт схеми вашої бази в json файли. Це робиться в   build.gradle  файлі модуля:     android {\n      ...\n      defaultConfig {\n          ...\n          javaCompileOptions {\n              annotationProcessorOptions {\n                  arguments   = [  \"room.schemaLocation\"  :   \"$projectDir/schemas\"  .toString()]\n              }\n          }\n      }\n  Після компіляції застосунку в папці проєкту з'явиться папка   schemas/\u003Capplication_package> , у якій зберігатимуться схеми вашої бази даних. Поточна версія бази   = 1 . Для неї буде створено файл   1.json .  Вміст цього файлу являє собою поточну схему бази:     {\n     \"formatVersion\"  :   1  ,\n     \"database\"  : {\n       \"version\"  :   1  ,\n       \"identityHash\"  :   \"f644b5f11fc9422f1830daaaf37a190c\"  ,\n       \"entities\"  : [\n         {\n           \"tableName\"  :   \"Employee\"  ,\n           \"createSql\"  :   \"CREATE TABLE IF NOT EXISTS `${TABLE_NAME}` (`id` INTEGER NOT NULL, `name` TEXT, `salary` INTEGER NOT NULL, PRIMARY KEY(`id`))\"  ,\n           \"fields\"  : [\n             {\n               \"fieldPath\"  :   \"id\"  ,\n               \"columnName\"  :   \"id\"  ,\n               \"affinity\"  :   \"INTEGER\"  ,\n               \"notNull\"  :   true\n             },\n             {\n               \"fieldPath\"  :   \"name\"  ,\n               \"columnName\"  :   \"name\"  ,\n               \"affinity\"  :   \"TEXT\"  ,\n               \"notNull\"  :   false\n             },\n             {\n               \"fieldPath\"  :   \"salary\"  ,\n               \"columnName\"  :   \"salary\"  ,\n               \"affinity\"  :   \"INTEGER\"  ,\n               \"notNull\"  :   true\n             }\n           ],\n           \"primaryKey\"  : {\n             \"columnNames\"  : [\n               \"id\"\n             ],\n             \"autoGenerate\"  :   false\n           },\n           \"indices\"  : [],\n           \"foreignKeys\"  : []\n         }\n       ],\n       \"setupQueries\"  : [\n         \"CREATE TABLE IF NOT EXISTS room_master_table (id INTEGER PRIMARY KEY,identity_hash TEXT)\"  ,\n         \"INSERT OR REPLACE INTO room_master_table (id,identity_hash) VALUES(42,   \\\"  f644b5f11fc9422f1830daaaf37a190c  \\\"  )\"\n       ]\n     }\n   }\n  Давайте додамо нове поле в   Employee . Це поле міститиме податковий клас співробітника. Клас може набувати значення   1,2 і 3  залежно від розміру зарплати. Будемо вважати, що у нас прогресивна шкала оподаткування )  Змінюємо версію бази в   AppDatabase  на 2. І в клас   Employee  додаємо поле   taxclass :     @  Entity  ()\n   public   class   Employee   {\n    \n      @  PrimaryKey\n      public   long   id;\n    \n      public   String   name;\n    \n      public   int   salary;\n    \n      public   int   taxclass;\n    \n   }\n  Компілюємо проєкт, і в папці schemas з'являється файл   2.json . Число 2 означає, що файл описує схему бази версії   2 . Тобто в ній тепер буде інформація про поле   taxclass .  У підсумку, в папці   schemas  у нас формується щось на кшталт журналу версій бази даних. Навіщо це потрібно, стане зрозуміло трохи пізніше.  Налаштовуємо міграцію. Детально про це я розповідав у минулому уроці. Тут зазначу лише, як виглядатиме   Migration  з першої на другу версію:     public   static   final   Migration   MIGRATION_1_2   =   new   Migration  (  1  ,   2  ) {\n      @  Override\n      public   void   migrate  (  final   SupportSQLiteDatabase   database  ) {\n          database.  execSQL  (  \"ALTER TABLE employee ADD COLUMN taxclass INTEGER DEFAULT 0 NOT NULL\"  );\n          database.  execSQL  (  \"UPDATE employee SET taxclass = 1 WHERE salary \u003C 10000\"  );\n          database.  execSQL  (  \"UPDATE employee SET taxclass = 2 WHERE salary BETWEEN 10000 AND 30000\"  );\n          database.  execSQL  (  \"UPDATE employee SET taxclass = 3 WHERE salary > 30000\"  );\n      }\n   };\n  Тут ми додаємо нове поле в таблицю і налаштовуємо класи. Якщо зарплата менше   10000 , то клас   = 1 . Якщо від   10000  до   30000 , то   2 . Якщо вище   30000 , то   3 .  Міграція готова. Під час запуску програми Room виконає перехід на другу версію бази. А ми зі свого боку можемо написати тест, який змоделює цей перехід. Тобто тест створить базу версії 1, заповнить її даними, виконає міграцію на версію 2 і перевірить, що все пройшло успішно.  Створюємо тест. У секцію   dependencies  додайте:     androidTestImplementation   \"android.arch.persistence.room:testing:1.0.0\"\n  Це дасть нам доступ до інструменту тестування   MigrationTestHelper .  А в секцію android додайте наступний   sourceSets :     android {\n       ...\n       sourceSets {\n           androidTest.assets.srcDirs += files(  \"$projectDir/schemas\"  .toString())\n       }\n   }\n  Це дасть тесту доступ до папки   Schemas , щоб він зміг зчитати схеми бази.  Тестовий клас:     @  RunWith  (AndroidJUnit4.class)\n   public   class   MigrationTest   {\n    \n      private   static   final   String   TEST_DB   =   \"migration-test\"  ;\n    \n      @  Rule\n      public   MigrationTestHelper   helper;\n    \n      public   MigrationTest  () {\n          helper   =   new   MigrationTestHelper  (InstrumentationRegistry.  getInstrumentation  (),\n                  AppDatabase.class.  getCanonicalName  (),\n                  new   FrameworkSQLiteOpenHelperFactory  ());\n      }\n    \n    \n      @  Test\n      public   void   migrate1To2  ()   throws   IOException   {\n          SupportSQLiteDatabase   db   =   helper.  createDatabase  (TEST_DB,   1  );\n    \n          db.  execSQL  (  \"INSERT INTO employee VALUES (1, 'name 1', 5000)\"  );\n          db.  execSQL  (  \"INSERT INTO employee VALUES (2, 'name 2', 10000)\"  );\n          db.  execSQL  (  \"INSERT INTO employee VALUES (3, 'name 3', 20000)\"  );\n          db.  execSQL  (  \"INSERT INTO employee VALUES (4, 'name 4', 30000)\"  );\n          db.  execSQL  (  \"INSERT INTO employee VALUES (5, 'name 5', 35000)\"  );\n          db.  close  ();\n    \n          db   =   helper.  runMigrationsAndValidate  (TEST_DB,   2  ,   true  , MIGRATION_1_2);\n    \n          Cursor   cursor   =   db.  query  (  \"select * from employee\"  );\n          assertEquals  (  5  , cursor.  getCount  ());\n          while   (cursor.  moveToNext  ()) {\n              int   salary   =   cursor.  getInt  (cursor.  getColumnIndex  (  \"salary\"  ));\n              int   taxClass   =   cursor.  getInt  (cursor.  getColumnIndex  (  \"taxclass\"  ));\n    \n              int   expectedTaxClass   =   0  ;\n              if   (salary   \u003C   10000  ) {\n                  expectedTaxClass   =   1  ;\n              }   else   if   (salary   \u003C=   30000  ) {\n                  expectedTaxClass   =   2  ;\n              }   else   {\n                  expectedTaxClass   =   3  ;\n              }\n              assertEquals  (  \"Wrong taxclass for salary: \"   +   salary, expectedTaxClass, taxClass);\n          }\n      }\n    \n   }\n  У конструкторі створюємо   MigrationTestHelper . Він також буде використаний як   Rule .  Розбираємо метод   migrate1To2 .  Спочатку ми методом createDatabase створюємо базу першої версії. Це можливо завдяки тому, що в папці schemas є файл   1.json  і   MigrationTestHelper  за ним може створити базу.  Далі заповнюємо базу тестовими даними і закриваємо її. Закривати необхідно, тому що зараз структура бази буде змінюватися.  Метод   runMigrationsAndValidate  виконає міграцію бази на другу версію (виконавши код з   MIGRATION_1_2 ) і перевірить, що отримана структура бази відповідає схемі з файлу   2.json .  Далі ми з нової отриманої бази читаємо дані по співробітниках і перевіряємо, що   MIGRATION_1_2  відпрацював коректно і проставив працівникам правильні податкові класи. Для кожного співробітника ми самі за зарплатою обчислюємо податковий клас і звіряємо його з тим, який прийшов із бази.  Таким чином тест виконав міграцію бази і перевірив, що структура і дані були перетворені коректно.  Схеми  Одне невелике, але важливе зауваження про схеми в папці   schemas . Вони генеруються під час компіляції проєкту, і тут треба бути уважними, тому що може вийти така ситуація:   є база версії 1 і, відповідно, файл   1.json  вирішуємо змінити структуру бази  додаємо нове поле в Entity клас, але забуваємо підняти версію бази  компілюємо проєкт і отримуємо в   1.json  уже нову структуру бази  справжня схема версії 1 тепер загублена  Після цього міграційний тест не зможе створити базу першої версії, тому що   1.json  описує вже другу версію.  Щоб уникнути цього, спочатку завжди піднімайте версію додатка в   AppDatabase  класі, а потім уже змінюйте структуру Entity класів.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":982,"path":983,"dir":984,"title":985,"description":986,"keywords":987,"body":992},"content:1.android:8.lesson8:1.pagedlist.md","/android/lesson8/pagedlist","lesson8","Paging Library. Основи","У цьому уроці почнемо знайомство з Paging Library. Розглянемо загальну схему роботи зв'язки PagedList і DataSource.",[988,989,990,991,869],"PagedListAdapter","Приклад використання Android DiffUtil","PagedList","DataSource","  Paging Library. Основи  У цьому уроці почнемо знайомство з   Paging Library . Розглянемо загальну схему роботи зв'язки   PagedList  і   DataSource .   Paging Library  містить інструменти для посторінкового підвантаження даних. Тобто коли дані довантажуються не всі відразу, а в міру прокручування списку. Давайте спочатку розглянемо в загальних рисах, чим цей спосіб відрізняється від звичайного, а потім виконаємо кілька прикладів.  Для підключення до проєкту додайте в   dependencies     implementation   \"android.arch.paging:runtime:1.0.0\"\n  Отже, ми хочемо відобразити дані в списку. Дані можуть бути звідки завгодно: база даних, сервер, файл із рядками тощо.  Тобто будь-яке джерело, яке може надати нам дані для відображення їх у списку. Для зручності давайте називати його загальним словом   Storage .  Зазвичай ми отримуємо дані зі   Storage  і поміщаємо їх у   List  в   адаптер . Далі   RecyclerView  буде в   адаптера  просити   View , а   адаптер  проситиме дані в   List .  Виходить така схема:\n  RecyclerView >> Adapter >> List  де   List  одразу містить усі необхідні дані і нічого не треба більше довантажувати.  З   Paging Library  схема буде трохи складнішою:   RecyclerView >> PagedListAdapter >> PagedList > DataSource > Storage  Тобто звичайний   Adapter  ми міняємо на   PagedListAdapter . А замість   List  у нас буде зв'язка   PagedList + DataSource , яка вміє в міру необхідності підтягувати дані зі   Storage .  Розглянемо докладніше ці компоненти.  PagedListAdapter   PagedListAdapter  - це   RecyclerView.Adapter , заточений під читання даних із   PagedList .  Приклад:     class   EmployeeAdapter   extends   PagedListAdapter  \u003C  Employee  ,   EmployeeViewHolder  > {\n   \n      protected   EmployeeAdapter  (  DiffUtil  .  ItemCallback  \u003C  Employee  >   diffUtilCallback  ) {\n          super  (diffUtilCallback);\n      }\n   \n      @  NonNull\n      @  Override\n      public   EmployeeViewHolder   onCreateViewHolder  (@  NonNull   ViewGroup   parent  ,   int   viewType  ) {\n          View   view   =   LayoutInflater.  from  (parent.  getContext  ()).  inflate  (R.layout.employee, parent,   false  );\n          EmployeeViewHolder   holder   =   new   EmployeeViewHolder  (view);\n          return   holder;\n      }\n   \n      @  Override\n      public   void   onBindViewHolder  (@  NonNull   EmployeeViewHolder   holder  ,   int   position  ) {\n          holder.  bind  (  getItem  (position));\n      }\n   \n   }\n  Як бачите, він дуже схожий на   RecyclerView.Adapter . Від нього також вимагається біндити дані в   Holder .  Відмінності такі:   Йому відразу треба надати   DiffUtil.Callback .  Немає ніякого сховища даних (  List  або т.п.)  Немає методу   getItemCount  Пункти   2  і   3  обумовлені тим, що адаптер усередині себе використовує   PagedList  як джерело даних, і він сам займатиметься зберіганням даних і визначенням їхньої кількості.  Щоб передати адаптеру   PagedList , ми будемо використовувати метод адаптера   submitList .  Приклад використання Android DiffUtil  Як правильно оновлювати дані в списку?  Запитувач зазвичай має на увазі два варіанти відповіді:   Передавати нові дані в адаптер і викликати метод   notifyDataSetChanged , щоб рефрешнути   RecyclerView  Створювати новий адаптер, давати йому нові дані і передавати цей адаптер у   RecyclerView .  setAdapter()  Обидва ці варіанти не є правильними, хоча технічно вони цілком робочі.  Проблема в тому, що в обох випадках весь список буде перемальований. Точніше, для кожного видимого рядка буде викликано метод   onBindViewHolder . І якщо у рядка важкий layout, використовується будь-яка анімація і дані адаптера оновлюються досить часто, то на слабких девайсах ви цілком можете побачити проблеми у швидкості роботи вашого списку.  Давайте на простому прикладі розглянемо більш оптимальний спосіб оновлення даних у списку.  Нехай у нас є   RecyclerView , який відображає простий список товарів (  Product ).    Товар має поле   id  і два відображуваних поля: назва (  name ) і ціна (  price ).\nПісля натискання на кнопку   Update  ми будемо оновлювати дані в списку.  Початкове наповнення списку може виглядати так:     @  Override\n   protected   void   onCreate  (  Bundle   savedInstanceState) {\n      super  .  onCreate  (savedInstanceState);\n      setContentView  (R.layout.activity_main);\n   \n     \n      // ...\n   \n      List  \u003C  Product  > productList   =   new   LinkedList  \u003C>();\n      productList.  add  (  new   Product  (  1  ,   \"Name1\"  ,   100  ));\n      productList.  add  (  new   Product  (  2  ,   \"Name2\"  ,   200  ));\n      productList.  add  (  new   Product  (  3  ,   \"Name3\"  ,   300  ));\n      productList.  add  (  new   Product  (  4  ,   \"Name4\"  ,   400  ));\n      productList.  add  (  new   Product  (  5  ,   \"Name5\"  ,   500  ));\n   \n      adapter.  setData  (productList);\n      adapter.  notifyDataSetChanged  ();\n   \n   }\n  У методі   setData  ми просто передаємо дані в адаптер без виклику будь-яких   notify  методів.  Потім викликаємо метод   notifyDataSetChanged , щоб список перемалювався.  Для спрощення весь код по роботі з даними знаходиться в Activity, але в реальних прикладах краще виносити його в презентер.  В адаптері в метод   onBindViewHolder  я додав виведення в лог позиції оновлюваного рядка:     @  Override\n   public   void   onBindViewHolder  (  ProductHolder   holder,   int   position) {\n      Log.  d  (TAG,   \"bind, position = \"   +   position);\n      holder.  bind  (data.  get  (position));\n   }\n  У такий спосіб ми бачитимемо, для яких рядків списку було виконано біндинг під час оновлення даних.  Для початку переконаємося, що під час використання методу   notifyDataSetChanged  для всіх рядків буде виконано біндинг. Після натискання на кнопку   Update  будемо оновлювати дані в списку:     void   onUpdateClick  () {\n      List  \u003C  Product  > productList   =   new   LinkedList  \u003C>();\n      productList.  add  (  new   Product  (  1  ,   \"Name1\"  ,   100  ));\n      productList.  add  (  new   Product  (  2  ,   \"Name21\"  ,   200  ));\n      productList.  add  (  new   Product  (  3  ,   \"Name3\"  ,   300  ));\n      productList.  add  (  new   Product  (  4  ,   \"Name4\"  ,   400  ));\n      productList.  add  (  new   Product  (  5  ,   \"Name5\"  ,   501  ));\n   \n      adapter.  setData  (productList);\n      adapter.  notifyDataSetChanged  ();\n   }\n  Для спрощення прикладу, ми самі формуємо новий список, але на практиці він міг прийти до нас від сервера або з БД. Дані майже ті ж самі, що й раніше, але у другого товару трохи змінилося найменування, а у п'ятого - ціна. Ці нові дані передаємо в адаптер і викликаємо   notifyDataSetChanged  Тиснемо   Update   \nДивимося лог після натискання на кнопку   Update .     bind,   position   =   0\n   bind,   position   =   1\n   bind,   position   =   2\n   bind,   position   =   3\n   bind,   position   =   4\n  Біндінг спрацював для всіх 5-ти рядків, хоча дані були оновлені тільки у двох. Не дуже оптимальний варіант оновлення.  Навіть якщо після натискання на   Update  дані надійдуть ті самі, що й були, то біндинг однаково спрацює для всіх рядків. Так відбувається тому, що адаптер не знає, що змінилося, а що ні. Тому він оновлює всі рядки списку.  Щоб вирішити цю проблему, ми замість   notifyDataSetChanged  можемо використовувати більш точкове оновлення - метод   notifyItemChanged .     void   onUpdateClick  () {\n       List  \u003C  Product  > productList   =   new   LinkedList  \u003C>();\n       productList.  add  (  new   Product  (  1  ,   \"Name1\"  ,   100  ));\n       productList.  add  (  new   Product  (  2  ,   \"Name21\"  ,   200  ));\n       productList.  add  (  new   Product  (  3  ,   \"Name3\"  ,   300  ));\n       productList.  add  (  new   Product  (  4  ,   \"Name4\"  ,   400  ));\n       productList.  add  (  new   Product  (  5  ,   \"Name5\"  ,   501  ));\n   \n       adapter.  setData  (productList);\n       adapter.  notifyItemChanged  (  1  );\n       adapter.  notifyItemChanged  (  4  );\n   }\n  Ми передаємо адаптеру дані і говоримо йому, що треба буде перемалювати тільки рядки з позиціями   1  і 4`. (позиції в адаптері починаються з нуля).  Запускаємо додаток, тиснемо   Update  і дивимося лог:     bind,   position   =   1\n   bind,   position   =   4\n  Тепер біндинг спрацював тільки для тих рядків, які ми оновили і явно вказали адаптеру.  Крім методу   notifyItemChanged , який оновить змінений рядок, є ще кілька   notify  методів, які допоможуть вам оновити список під час додавання, видалення або переміщення рядків.  Ці точкові   notify  методи зручні, коли ми точно знаємо, які рядки були змінені. Але якщо ми просто отримуємо нові дані ззовні, то буде досить складно вручну все порівнювати і визначати, що змінилося, а що ні. Цю роботу за нас може виконати   DiffUtil .  Він порівняє два набори даних: старий і новий, з'ясує, які відбулися зміни, і за допомогою   notify  методів оптимально оновить адаптер.  Від нас вимагається тільки успадкувати клас   DiffUtil.Callback  і реалізувати кілька його абстрактних методів.     public   class   ProductDiffUtilCallback   extends   DiffUtil.Callback   {\n   \n      private   final   List  \u003C  Product  > oldList;\n      private   final   List  \u003C  Product  > newList;\n   \n      public   ProductDiffUtilCallback  (  List  \u003C  Product  >   oldList  ,   List  \u003C  Product  >   newList  ) {\n          this  .oldList   =   oldList;\n          this  .  new  List   =   newList;\n      }\n   \n      @  Override\n      public   int   getOldListSize  () {\n          return   oldList.  size  ();\n      }\n   \n      @  Override\n      public   int   getNewListSize  () {\n          return   newList.  size  ();\n      }\n   \n      @  Override\n      public   boolean   areItemsTheSame  (  int   oldItemPosition  ,   int   newItemPosition  ) {\n          Product   oldProduct   =   oldList.  get  (oldItemPosition);\n          Product   newProduct   =   newList.  get  (newItemPosition);\n          return   oldProduct.  getId  ()   ==   newProduct.  getId  ();\n      }\n   \n      @  Override\n      public   boolean   areContentsTheSame  (  int   oldItemPosition  ,   int   newItemPosition  ) {\n          Product   oldProduct   =   oldList.  get  (oldItemPosition);\n          Product   newProduct   =   newList.  get  (newItemPosition);\n          return   oldProduct.  getName  ().  equals  (newProduct.  getName  ())\n                  &&   oldProduct.  getPrice  ()   ==   newProduct.  getPrice  ();\n      }\n   }\n  У конструктор передаємо старі дані та нові дані. Вони знадобляться для порівняння.  У методах   getOldListSize  і   getNewListSize  просто повертаємо кількість записів у старому списку і в новому.  А в методах   areItemsTheSame  і   areContentsTheSame  нам дають дві позиції: одну зі старого списку (  oldItemPosition ) і одну з нового (  newItemPosition ). Відповідно, ми зі списку   oldList  беремо   Product  з позицією   oldItemPosition , а з   newList  -   Product  з позицією   newItemPosition , і порівнюємо їх.  У чому ключова різниця між   areItemsTheSame  і   areContentsTheSame ?  Розглянемо на прикладі товарів. У   Product  є три поля:   id ,   name  і   price .  Для кожної пари порівнюваних товарів   DiffUtil  спочатку викличе метод   areItemsTheSame , щоб визначити, чи треба в принципі порівнювати ці товари. Тобто спочатку достатньо порівняти їх за   id . Якщо   id  не рівні, отже, це різні товари і порівнювати їхні ціни та найменування немає сенсу - найімовірніше, вони також відрізнятимуться.  А ось якщо   id  рівні, значить товар зі старого списку і товар з нового списку - це один і той самий товар і треба визначити, чи змінився він. У цьому випадку   DiffUtil  викликає метод   areContentsTheSame , щоб визначити, чи є відмінності між старим товаром і новим. У цьому методі ми порівнюємо товари за ціною і найменуванням. Якщо вони однакові, значить товари за вказаними позиціями в старому і новому списку однакові. І біндинг для рядка, що відображає цей товар, викликати не треба, бо не буде там жодних змін. А якщо ціна або найменування у нового товару відрізняється від старого, значить товар змінився і для рядка, що відображає цей товар, треба буде викликати біндинг.  Тобто в   areItemsTheSame  ви порівнюєте поля, щоб у принципі визначити, чи різні це об'єкти. А в   areContentsTheSame  вже порівнюєте деталі, щоб визначити, чи змінилося щось із того, що ви відображаєте на екрані.  Давайте уявимо, що в   Product  є ще одне поле, наприклад - дата поставки. Але в списку відображати це поле не потрібно. Чи враховувати це поле в   areContentsTheSame ?  Якщо ви будете його враховувати, то при зміні тільки цього поля, рядок списку з товаром буде перемальовано, але при цьому візуально ніяких змін не буде.   Це буде зайва робота . Тому в   areContentsTheSame  має сенс використовувати тільки ті поля об'єкта, зміна яких призведе до видимих змін рядка в списку.  Використовуємо наш створений   ProductDiffUtilCallback     void   onUpdateClick  () {\n       List  \u003C  Product  > productList   =   new   LinkedList  \u003C>();\n       productList.  add  (  new   Product  (  1  ,   \"Name1\"  ,   100  ));\n       productList.  add  (  new   Product  (  2  ,   \"Name21\"  ,   200  ));\n       productList.  add  (  new   Product  (  3  ,   \"Name3\"  ,   300  ));\n       productList.  add  (  new   Product  (  4  ,   \"Name4\"  ,   400  ));\n       productList.  add  (  new   Product  (  5  ,   \"Name5\"  ,   501  ));\n   \n       ProductDiffUtilCallback   productDiffUtilCallback   =   \n               new   ProductDiffUtilCallback  (adapter.  getData  (), productList);\n       DiffUtil  .  DiffResult   productDiffResult   =   DiffUtil.  calculateDiff  (productDiffUtilCallback);\n   \n       adapter.  setData  (productList);\n       productDiffResult.  dispatchUpdatesTo  (adapter);\n   }\n  Створюємо   ProductDiffUtilCallback  і передаємо в нього старий список і новий. Передавши   productDiffUtilCallback  у метод   DiffUtil.calculateDiff , виконуємо порівняння двох списків. Результат порівняння отримуємо в   DiffResult .  Далі передаємо в адаптер нові дані і просимо   productDiffResult  оновити   RecyclerView  з урахуванням змін. Тобто це буде не просто бездумне   notifyDataSetChanged , а саме використання   notify  методів, щоб оновити список максимально ефективно.  Лог матиме такий вигляд:     bind,   position   =   1\n   bind,   position   =   4\n   DiffUtil  правильно визначив, що треба оновити тільки рядки з позиціями   1  і   4 .  Давайте трохи ускладнимо приклад. У нових даних приберемо перший товар і додамо шостий.     void   onUpdateClick  () {\n      List  \u003C  Product  > productList   =   new   LinkedList  \u003C>();\n      productList.  add  (  new   Product  (  2  ,   \"Name21\"  ,   200  ));\n      productList.  add  (  new   Product  (  3  ,   \"Name3\"  ,   300  ));\n      productList.  add  (  new   Product  (  4  ,   \"Name4\"  ,   400  ));\n      productList.  add  (  new   Product  (  5  ,   \"Name5\"  ,   501  ));\n      productList.  add  (  new   Product  (  6  ,   \"Name6\"  ,   600  ));\n   \n      ProductDiffUtilCallback   productDiffUtilCallback   =   new   ProductDiffUtilCallback  (adapter.  getData  (), productList);\n      DiffUtil  .  DiffResult   productDiffResult   =   DiffUtil.  calculateDiff  (productDiffUtilCallback);\n   \n      adapter.  setData  (productList);\n      productDiffResult.  dispatchUpdatesTo  (adapter);\n   }\n  Результат\n   Лог     bind,   position   =   0\n   bind,   position   =   3\n   bind,   position   =   4\n  Товари змістилися на один вгору, але   DiffUtil  все одно коректно визначив, що біндінг треба викликати тільки для трьох рядків, які відображають другий, п'ятий і шостий товари. Третій і четвертий товари хоч і поміняли позиції через видалення першого, але, дані в них не змінилися, і схоже, що для них були використані ті ж самі холдери, тому у виконанні біндінгу для них не було необхідності.  У   DiffUtil.Callback  є ще один метод -   getChangePayload . Про нього поговорим пізніше.  Під час використання   DiffUtil  враховуйте, що виконання методу   DiffUtil.calculateDiff  може займати довгий час. Тому, якщо очікуєте, що кількість записів вимірюватиметься сотнями і зміни списку будуть значні, то має сенс викликати цей метод асинхронно.  У методу calculateDiff є ще один варіант виклику\n  DiffUtil.DiffResult calculateDiff (DiffUtil.Callback cb, boolean detectMoves)  Що означає прапор   detectMoves ? За замовчуванням, цей прапор   = true . У цьому випадку   DiffUtil  спробує знайти переміщення рядків, які відбулися в новому списку порівняно зі старим. І якщо він знайде такі переміщення, то він викличе відповідні   notify  методи, і ви отримаєте красиву анімацію   \nАле це буде на шкоду швидкості роботи   calculateDiff .  Якщо ж вам не потрібна така анімація, то можна вказувати   detectMoves = false  У цьому разі, у разі зміни порядку записів анімація матиме такий вигляд:   \nЗате ви отримаєте приріст у швидкості роботи   calculateDiff  PagedList  Якщо не сильно вдаватися в деталі, то   PagedList  - це обгортка над   List . Він теж містить дані і вміє віддавати їх методом   get(position) . Але при цьому він перевіряє, наскільки запитуваний елемент близький до кінця наявних у нього даних, і за необхідності довантажує собі нові дані за допомогою   DataSource .  Тобто у   PagedList  у списку вже є, наприклад,   40  елементів. Адаптер просить у нього елемент із позицією   31 .   PagedList  дає йому цей елемент і при цьому розуміє, що адаптер просив елемент, близький до кінця його даних. А отже, є ймовірність, що скоро адаптер прийде за елементами з позицією   40  і далі. Тому   PagedList  звертається до   DataSource  за новою порцією даних, наприклад, від   41  до   50 .  Створюється   PagedList  за допомогою білдера:     PagedList  \u003C  Employee  > pagedList   =   new   PagedList  .  Builder  \u003C>(dataSource, config)\n          .  setBackgroundThreadExecutor  (Executors.  newSingleThreadExecutor  ())\n          .  setMainThreadExecutor  (  new   MainThreadExecutor  ())\n          .  build  ();\n  Від нас вимагається надати пару   Executor -ів. Один для виконання запиту даних в окремому потоці, а другий для повернення результатів в UI потік.  На вхід конструктору білдера необхідно надати   DataSource  і   PagedList.Config . Про   DataSource  ми поговоримо трохи пізніше, а   PagedList.Config  - це конфіг   PagedList . У ньому ми можемо задати різні параметри, наприклад, розмір сторінки.  Створення   PagedList.Config  може виглядати так:     PagedList  .  Config   config   =   new   PagedList.Config.  Builder  ()\n          .  setEnablePlaceholders  (  false  )\n          .  setPageSize  (  10  )\n          .  build  ();\n  Детально всі його параметри ми розглянемо пізніше.  Варіант реалізації   MainThreadExecutor :     class   MainThreadExecutor   implements   Executor   {\n      private   final   Handler   mHandler   =   new   Handler  (Looper.  getMainLooper  ());\n   \n      @  Override\n      public   void   execute  (  Runnable   command  ) {\n          mHandler.  post  (command);\n      }\n   }\n  DataSource   DataSource  - це посередник між   PagedList  і   Storage . Виникає запитання: навіщо потрібен цей посередник? Чому   PagedList  не може безпосередньо попросити чергову порцію даних у   Storage ? Тому що у   Storage  можуть бути різні вимоги до способу запиту даних.  Наприклад, базі даних ми можемо дати позицію і бажану кількість записів, і у відповідь отримаємо порцію даних, починаючи із зазначеної позиції. А ось сервер може працювати зовсім по-іншому. Наприклад, він віддає дані посторінково і чекатиме від нас номер наступної сторінки, щоб віддати нову порцію даних. Також у сервера буває схема, коли з черговою порцією даних він надсилає нам токен. Цей токен необхідно використовувати для отримання наступної порції даних.   Paging Library  надає три різних   DataSource , які мають нам допомогти зв'язати між собою   PagedList  і   Storage . Це   PositionalDataSource ,   PageKeyedDataSource  і   ItemKeyedDataSource . В окремому уроці ми ще детально розглянемо, у чому різниця між ними. А поки що працюватимемо з   PositionalDataSource , тому що він простіший і зрозуміліший за інші.  Практика  Давайте перейдемо до практичного прикладу і все стане зрозуміліше. Як   DataSource  будемо використовувати   PositionalDataSource .  Отже, щоб уся схема запрацювала, нам треба створити   DataSource ,   PagedList  і   адаптер :     // DataSource\n   MyPositionalDataSource   dataSource   =   new   MyPositionalDataSource  (  new   EmployeeStorage  ())\n   // PagedList\n   PagedList.Config config   =   new   PagedList.Config.  Builder  ()\n           .  setEnablePlaceholders  (  false  )\n           .  setPageSize  (  10  )\n           .  build  ()\n   PagedList  \u003C  Employee  > pagedList   =   new   PagedList  .  Builder  \u003C>(dataSource, config)\n           .  setMainThreadExecutor  (  new   MainThreadExecutor  ())\n           .  setBackgroundThreadExecutor  (Executors.  newSingleThreadExecutor  ())\n           .  build  ()\n   // Adapter\n   adapter   =   new   EmployeeAdapter  (diffUtilCallback);\n   adapter.  submitList  (pagedList)\n   // RecyclerView\n   recyclerView.  setAdapter  (adapter);\n   DataSource  передаємо в   PagedList .   PagedList  передаємо в адаптер. Адаптер передаємо в   RecyclerView .  Код   MyPositionalDataSource :     class   MyPositionalDataSource   extends   PositionalDataSource  \u003C  Employee  > {\n       private   final   EmployeeStorage   employeeStorage;\n   \n       public   MyPositionalDataSource  (  EmployeeStorage   employeeStorage  ) {\n           this  .employeeStorage   =   employeeStorage;\n       }\n       @  Override\n       public   void   loadInitial  (@  NonNull   LoadInitialParams   params  , @  NonNull   LoadInitialCallback  \u003C  Employee  >   callback  ) {\n           Log.  d  (TAG,   \"loadInitial, requestedStartPosition = \"   +   params.requestedStartPosition   +\n                   \", requestedLoadSize = \"   +   params.requestedLoadSize);\n           List  \u003C  Employee  > result   =   employeeStorage.  getData  (params.requestedStartPosition, params.requestedLoadSize);\n           callback.  onResult  (result,   0  );\n       }\n       @  Override\n       public   void   loadRange  (@  NonNull   LoadRangeParams   params  , @  NonNull   LoadRangeCallback  \u003C  Employee  >   callback  ) {\n           Log.  d  (TAG,   \"loadRange, startPosition = \"   +   params.startPosition   +   \", loadSize = \"   +   params.loadSize);\n           List  \u003C  Employee  > result   =   employeeStorage.  getData  (params.startPosition, params.loadSize);\n           callback.  onResult  (result);\n       }\n   \n   }\n   EmployeeStorage  - це створений мною клас, який емулює   Storage  і містить   100 Employee  записів. Не наводжу тут реалізацію цього класу, тому що вона не має значення. У реальному прикладі замість нього буде   база даних  (  Room ) або   сервер  (  Retrofit ), до яких ми звертаємося за даними.   MyPositionalDataSource  наслідує   PositionalDataSource  і має реалізувати пару методів:    loadInitial  - початкове завантаження даних.  Коли ми створюємо   PagedList , він відразу запитує порцію даних у   DataSource . Робить він це методом   loadInitial . Як параметри він передає нам:    requestedStartPosition  - з якої позиції довантажувати   requestedLoadSize  - розмір порції  Використовуючи ці параметри, ми запитуємо дані у   Storage . Отриманий результат передаємо в   callback.onResult    loadRange  - підвантаження нової порції даних  Коли ми прокручуємо список,   PagedList  довантажує нові дані. Для цього він викликає метод   loadRange . Як параметри він передає нам позицію, з якої треба довантажувати дані, і розмір порції.  Використовуючи ці параметри, ми запитуємо дані у   Storage . Отриманий результат передаємо в   callback.onResult  Я додав логів у ці методи, щоб було видно, що відбувається.  Про те, що означає другий параметр у   callback.onResult , поговоримо в другій частині. А потоки, в яких буде виконуватися цей код, обговоримо в третій частині.  Запускаємо застосунок.  Для наочності я зробив гіфку, в якій ви можете бачити, які логи з'являються в міру прокручування списку.\n   Розбираємося, що відбувається.  Відразу після запуску в логах бачимо рядок:   loadInitial ,   requestedStartPosition = 0 ,   requestedLoadSize = 30   PagedList  запросив початкову порцію даних розміром   30  елементів (  requestedLoadSize ), починаючи з нульового (  requestedStartPosition ). DataSource передає ці параметри в   Storage , отримує дані і повертає їх у   PagedList . У підсумку адаптер відображає ці записи.  Звідки взялося число   30 ? За замовчуванням розмір початкового завантаження дорівнює   розмір сторінки * 3 . Розмір сторінки ми встановили рівним   10  (у   PagedList.Config  методом   setPageSize ), тому   requestedLoadSize  дорівнює   30 .  Тепер починаємо скролити список вниз. Коли список показав запис із позицією 20, PagedList запросив наступну порцію даних:     loadRange,   startPosition   30,   loadSize   =   10\n  Чому він зробив це саме після досягнення запису з позицією   20 ? За це відповідає параметр   prefetchDistance . За замовчуванням він дорівнює pageSize, тобто   10 . Відповідно, коли до кінця списку залишається   10  записів,   PagedList  довантажує наступну порцію.  У міру прокручування списку, довантажуються такі порції даних     loadRange,   startPosition   =   40,   loadSize   =   10\n   loadRange,   startPosition   =   50,   loadSize   =   10\n   loadRange,   startPosition   =   60,   loadSize   =   10\n   loadRange,   startPosition   =   70,   loadSize   =   10\n   loadRange,   startPosition   =   80,   loadSize   =   10\n   loadRange,   startPosition   =   90,   loadSize   =   10\n   loadRange,   startPosition   =   100,   loadSize   =   10\n  Після сотого запису список не прокручується. Так відбувається тому, що мій   EmployeeStorage  містить лише   100  записів. При спробі отримати у нього   10  записів, починаючи з позиції   100 , він просто поверне порожній список. Коли   DataSource  передасть цей порожній список у   callback .  onResult , це буде сигналом для   PagedList , що дані закінчилися. Після цього   PagedList  більше не намагатиметься довантажувати дані і список не буде скролитися.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":994,"path":995,"dir":984,"title":996,"description":997,"keywords":998,"body":1004},"content:1.android:8.lesson8:2.paging-library.md","/android/lesson8/paging-library","Paging Library. PagedList і DataSource. Placeholders.","У цьому уроці розглянемо, які параметри ми можемо задати для PagedList. Детально розберемо, які значення необхідно передавати в callback.onResult у DataSource. Навчимося використовувати режим Placeholders.",[999,1000,1001,1002,1003],"Initial Key","pageSize","initialLoadSizeHint","prefetchDistance","Placeholders","  Paging Library. PagedList і DataSource. Placeholders.  У цьому уроці розглянемо, які параметри ми можемо задати для   PagedList . Детально розберемо, які значення необхідно передавати в   callback.onResult  у   DataSource . Навчимося використовувати режим   Placeholders .  У минулому уроці ми розглянули приклад із використанням інструментів   Paging Library . Нагадаю основні моменти коду:  Адаптер:     class   EmployeeAdapter   extends   PagedListAdapter  \u003C  Employee  ,   EmployeeViewHolder  > {\n    \n      protected   EmployeeAdapter  (  DiffUtil  .  ItemCallback  \u003C  Employee  >   diffUtilCallback  ) {\n          super  (diffUtilCallback);\n      }\n    \n      @  NonNull\n      @  Override\n      public   EmployeeViewHolder   onCreateViewHolder  (@  NonNull   ViewGroup   parent  ,   int   viewType  ) {\n          View   view   =   LayoutInflater.  from  (parent.  getContext  ()).  inflate  (R.layout.employee, parent,   false  );\n          EmployeeViewHolder   holder   =   new   EmployeeViewHolder  (view);\n          return   holder;\n      }\n    \n      @  Override\n      public   void   onBindViewHolder  (@  NonNull   EmployeeViewHolder   holder  ,   int   position  ) {\n          holder.  bind  (  getItem  (position));\n      }\n    \n   }\n   DataSource :     class   MyPositionalDataSource   extends   PositionalDataSource  \u003C  Employee  > {\n    \n       private   final   EmployeeStorage   employeeStorage;\n    \n       public   MyPositionalDataSource  (  EmployeeStorage   employeeStorage  ) {\n           this  .employeeStorage   =   employeeStorage;\n       }\n    \n       @  Override\n       public   void   loadInitial  (@  NonNull   LoadInitialParams   params  , @  NonNull   LoadInitialCallback  \u003C  Employee  >   callback  ) {\n           Log.  d  (TAG,   \"loadInitial, requestedStartPosition = \"   +   params.requestedStartPosition   +\n                   \", requestedLoadSize = \"   +   params.requestedLoadSize);\n           List  \u003C  Employee  > result   =   employeeStorage.  getData  (params.requestedStartPosition, params.requestedLoadSize);\n           callback.  onResult  (result,   0  );\n       }\n    \n       @  Override\n       public   void   loadRange  (@  NonNull   LoadRangeParams   params  , @  NonNull   LoadRangeCallback  \u003C  Employee  >   callback  ) {\n           Log.  d  (TAG,   \"loadRange, startPosition = \"   +   params.startPosition   +   \", loadSize = \"   +   params.loadSize);\n           List  \u003C  Employee  > result   =   employeeStorage.  getData  (params.startPosition, params.loadSize);\n           callback.  onResult  (result);\n       }\n    \n   }\n  Де,   EmployeeStorage  - це просто емуляція якогось зовнішнього джерела даних, яке містить   100  записів  Код у   MainActivity , де ми все це збираємо разом:     // DataSource\n   MyPositionalDataSource   dataSource   =   new   MyPositionalDataSource  (  new   EmployeeStorage  ());\n    \n    \n   // PagedList\n   PagedList  .  Config   config   =   new   PagedList.Config.  Builder  ()\n           .  setEnablePlaceholders  (  false  )\n           .  setPageSize  (  10  )\n           .  build  ();\n    \n   PagedList  \u003C  Employee  > pagedList   =   new   PagedList  .  Builder  \u003C>(dataSource, config)\n           .  setMainThreadExecutor  (  new   MainThreadExecutor  ())\n           .  setBackgroundThreadExecutor  (Executors.  newSingleThreadExecutor  ())\n           .  build  ();\n    \n    \n   // Adapter\n   adapter   =   new   EmployeeAdapter  (diffUtilCallback);\n   adapter.  submitList  (pagedList);\n    \n    \n   // RecyclerView\n   recyclerView.  setAdapter  (adapter);\n  Де,   EmployeeStorage  - це просто емуляція якогось зовнішнього джерела даних, яке містить   100  записів  Код у   MainActivity , де ми все це збираємо разом:  Initial Key  У нашому прикладі   PagedList  запитує початкову порцію даних з позиції   0 . Але цілком може бути ситуація, коли необхідно запросити дані не з самого початку.  Наприклад, у застосунку відкрито список і вже прокручено до якоїсь позиції. Користувач згортає додаток і займається іншими справами. Системі раптом не вистачає пам'яті, і вона вбиває додаток. Користувач вирішує повернутися, відкриває застосунок і ось тут нам треба показати список на тому самому місці, де він був. Перед тим як додаток було вбито, ми в   onSaveInstanceState  зберегли поточну позицію списку і тепер хочемо показати дані в ньому з цієї ж позиції.   PagedList  дає нам таку можливість.  У білдері   PagedList  є параметр   initialKey . Для прикладу задамо йому значення   50 .     PagedList  \u003C  Employee  > pagedList   =   new   PagedList  .  Builder  \u003C>(dataSource, config)\n          .  setMainThreadExecutor  (  new   MainThreadExecutor  ())\n          .  setBackgroundThreadExecutor  (Executors.  newSingleThreadExecutor  ())\n          .  setInitialKey  (  50  )\n          .  build  ();\n  А в методі   loadInitial  у   MyPositionalDataSource  треба буде трохи підправити параметри виклику   callback.onResult .     @  Override\n   public   void   loadInitial  (@  NonNull   LoadInitialParams   params, @  NonNull   LoadInitialCallback  \u003C  Employee  >   callback) {\n      Log.  d  (TAG,   \"loadInitial, requestedStartPosition = \"   +   params.requestedStartPosition   +\n              \", requestedLoadSize = \"   +   params.requestedLoadSize);\n      List  \u003C  Employee  > result   =   employeeStorage.  getData  (params.requestedStartPosition, params.requestedLoadSize);\n      callback.  onResult  (result, params.requestedStartPosition);\n   }\n  Під час запиту даних параметр   params.requestedStartPosition  дорівнюватиме   50 , оскільки ми задали це в   setInitialKey .  У   callback.onResult  ми повертаємо не тільки дані з   Storage , а й позицію початкового елемента цих даних. Тобто ми повідомляємо   PagedList , що дані, які ми йому передали, починаються з позиції   params.requestedStartPosition , тобто   50 .  Розумію, що це виглядає як мінімум дивно.   PagedList  ніби як сам попросив нас надати йому дані з позиції   50 . Тобто він знає про це. Навіщо ми йому про це додатково повідомляємо в   callback.onResult ? Тому що він чекає від нас це значення. Навіть якщо воно дорівнюватиме тому значенню, яке він нам сам і надіслав у   params.requestedStartPosition . У подальшій роботі він буде використовувати саме те значення, які ми повернули йому.  У найпростіших випадках два цих значення будуть рівні. І код у прикладі вище працюватиме. Але в складних випадках ці значення можуть відрізнятися. Тобто   PagedList  просив нас дані з позиції   50 , а ми змогли надати тільки з позиції   40 . Давайте розглянемо такий нетривіальний сценарій.  Згадуємо вищеописаний випадок, коли застосунок вбивається системою, поки він висить у фоні. Припустимо, що перед тим, як бути вбитим, він довантажив усі   100  записів. Список був промотаний до кінця і показував останні   10  записів: з   90  по   100 . Отже, під час відновлення програми   PagedList  попросить у нас записи, починаючи з позиції   90 .  Невеликий відступ.   PagedList  попросить   30  записів, починаючи з   90 . Чому   30 , адже всього було   100  записів, і він повинен попросити 10? Тому що він нічого не знає про те, скільки в нас даних у   Storage . А   30  - це розмір його порції початкових даних за замовчуванням. І якщо в   Storage  є тільки   10  записів, починаючи з   90 , то ми просто їх і повертаємо в   PagedList . Початкові порції даних, які запитуються та отримуються, необов'язково повинні збігатися за розміром.  Давайте уявимо, що, поки додаток було вбито, кількість даних у   Storage  зменшилася до   70 . А   PagedList  просить з   90 . Наш   Storage  повинен вміти обробляти такі ситуації. Тобто коли ми в нього в первісному завантаженні попросимо записи, починаючи з   90 , він повинен зрозуміти, що таких записів більше немає, і повернути найближчі доступні записи.  Наприклад, якщо в   Storage  всього   70  записів, і ми запитуємо   30  записів, починаючи з   90 , то   Storage  може повернути нам   30  останніх записів, тобто   30  записів з позиції   40 . Ми передаємо ці дані в   callback.onResult , і обов'язково вказуємо, що їхня позиція починається з   40 , а не з   90 , як розраховував   PagedList .  У підсумку виходить, що нас просили про дані з позиції   90  (  params.requestedStartPosition ), а в   callback.onResult  ми передаємо список і повідомляємо, що вийшло добути дані тільки з позиції   40 . Таким чином ми скорегували початкову позицію   PagedList . Він знає, що у нього є записи з позиції   40  по позицію   70 . І це дасть йому змогу запитувати у   DataSource  інші дані, використовуючи правильні позиції.  Якщо ж ми в   callback.onResult  просто передамо   params.requestedStartPosition  (тобто   90 ), то   PagedList  думатиме, що він отримав початкові дані з позиції   90  по позицію   120 . І далі він буде запитувати дані з   120  по   130 , з   80  по   90  і т.д. Тобто вийде розсинхрон зі   Storage . Тому нам необхідно повернути в   PagedList  коректне значення початкової позиції отриманих даних. А щоб ми могли це зробити, нам треба отримати це значення від   Storage .  У підсумку виходить, що нас просили про дані з позиції   90  (  params.requestedStartPosition ), а в   callback.onResult  ми передаємо список і повідомляємо, що вийшло добути дані тільки з позиції   40 . Таким чином ми скорегували початкову позицію   PagedList . Він знає, що у нього є записи з позиції   40  по позицію   70 . І це дасть йому змогу запитувати у   DataSource  інші дані, використовуючи правильні позиції.  Якщо ж ми в   callback.onResult  просто передамо   params.requestedStartPosition  (тобто   90 ), то   PagedList  думатиме, що він отримав початкові дані з позиції   90  по позицію   120 . І далі він буде запитувати дані з   120  по   130 , з   80  по   90  і т.д. Тобто вийде розсинхрон зі   Storage . Тому нам необхідно повернути в   PagedList  коректне значення початкової позиції отриманих даних. А щоб ми могли це зробити, нам треба отримати це значення від   Storage .     class   MyPositionalDataSource   extends   PositionalDataSource  \u003C  Employee  > {\n   \n      private   final   EmployeeStorage   employeeStorage;\n   \n      public   MyPositionalDataSource  (  EmployeeStorage   employeeStorage  ) {\n          this  .employeeStorage   =   employeeStorage;\n      }\n   \n      @  Override\n      public   void   loadInitial  (@  NonNull   LoadInitialParams   params  , @  NonNull   LoadInitialCallback  \u003C  Employee  >   callback  ) {\n          Log.  d  (TAG,   \"loadInitial, requestedStartPosition = \"   +   params.requestedStartPosition   +\n                  \", requestedLoadSize = \"   +   params.requestedLoadSize);\n          EmployeeData   result   =   employeeStorage.  getInitialData  (params.requestedStartPosition, params.requestedLoadSize);\n          callback.  onResult  (result.data, result.position);\n      }\n   \n      @  Override\n      public   void   loadRange  (@  NonNull   LoadRangeParams   params  , @  NonNull   LoadRangeCallback  \u003C  Employee  >   callback  ) {\n          Log.  d  (TAG,   \"loadRange, startPosition = \"   +   params.startPosition   +   \", loadSize = \"   +   params.loadSize);\n          List  \u003C  Employee  > result   =   employeeStorage.  getData  (params.startPosition, params.loadSize);\n          callback.  onResult  (result);\n      }\n   \n   }\n  У методі   loadInitial  я для отримання даних використовую   employeeStorage.getInitialData . Цей метод поверне дані і позицію, з якої ці дані починаються. Якщо раптом запитуваних даних немає, то він зможе повернути найближчі дані. Це важливо, тому що ми не можемо передати порожній список у   callback.onResult  у методі   loadInitial . Якщо ми в   callback.onResult  повернемо порожній список і позицію   90 , тим самим повідомляючи, що нам не вдалося отримати ці дані, то   PagedList  повідомить нам, що це наша проблема:   Initial result cannot be empty if items are present in data set  Тому нам треба обов'язково отримати від   Storage  якісь початкові дані. У нашому прикладі я від   employeeStorage.getInitialData  отримаю   30  записів і позицію   40  і передам це в   PagedList .  Зрозуміло, може виникнути ситуація, що даних у   Storage  немає зовсім. Навіть для початкового завантаження. Тоді ми передаємо в   callback.onResult  порожній список і позицію   0 . Тільки з позицією   0    PagedList  прийме від нас порожній список у методі   loadInitial  і зрозуміє, що даних узагалі ніяких немає.  У методі   loadRange  ми для отримання даних продовжуємо використовувати метод   employeeStorage.getData . Він не повинен нічого враховувати і визначати. Від нього вимагається просто повернути дані, якщо вони є. А якщо їх немає, то це буде сигналом для   PagedList , що дані закінчилися.  Давайте подивимося, який вигляд це має в роботі\n    PagedList  просить   30  записів, починаючи з   90 .     loadInitial,   requestedStartPosition   =   90,   requestedLoadSize   =   30\n   DataSource  повертає йому   30  записів, починаючи з   40 , і список їх відображає.  Відразу після першого завантаження   PagedList  просить у   DataSource  нову порцію даних:   10  штук, починаючи з позиції   30 .     loadRange,   startPosition   =   30,   loadSize   =   10\n  Тобто він зрозумів, що на початку списку мають бути ще дані і довантажив одну порцію. Причому, якби ми не скоригували його позицію на   40  (у   callback.onResult ), то він вважав би, що відображає записи з   90  по   120 , і запросив би   10  записів з позиції   80 .  Подальші скроли вгору, будуть також довантажувати попередні записи, поки не дійдемо до нуля.     loadRange,   startPosition   =   20,   loadSize   =   10\n   loadRange,   startPosition   =   10,   loadSize   =   10\n   loadRange,   startPosition   =   0,   loadSize   =   10\n  При скролі в кінець списку,   PagedList  спробує довантажити наступні записи після   70 .     loadRange,   startPosition   =   70,   loadSize   =   10\n  Але в   Storage  більше нічого немає.   PagedList  отримає порожній список (у   callback  у методі   loadRange ) і заспокоїться.  pageSize  Параметр   pageSize  дає змогу задати розмір сторінки     PagedList  .  Config   config   =   new   PagedList.Config.  Builder  ()\n          .  setEnablePlaceholders  (  false  )\n          .  setPageSize  (  15  )\n          .  build  ();\n  Якщо ми задамо йому значення   15 , то   PagedList  проситиме у   DataSource  по   15  записів.     loadInitial,   requestedStartPosition   =   0,   requestedLoadSize   =   45\n   loadRange,   startPosition   =   45,   loadSize   =   15\n   loadRange,   startPosition   =   60,   loadSize   =   15\n   loadRange,   startPosition   =   75,   loadSize   =   15\n   loadRange,   startPosition   =   90,   loadSize   =   15\n   loadRange,   startPosition   =   100,   loadSize   =   15\n  Параметр   requestedLoadSize  також змінився, він дорівнює   розмір сторінки * 3 , тобто   45  initialLoadSizeHint  Цей параметр відповідає за кількість даних, яку запитуватиме   PagedList  під час початкового завантаження. За замовчуванням він дорівнює   pageSize * 3 , але ми можемо задати своє значення.     PagedList  .  Config   config   =   configBuilder\n          .  setEnablePlaceholders  (  false  )\n          .  setPageSize  (  10  )\n          .  setInitialLoadSizeHint  (  50  )\n          .  build  ();\n  Розмір сторінки задаємо   10 , а initialLoadSizeHint у   50 .  Логи:     loadInitial,   requestedStartPosition   =   0,   requestedLoadSize   =   50\n   loadRange,   startPosition   =   50,   loadSize   =   10\n   loadRange,   startPosition   =   60,   loadSize   =   10\n   loadRange,   startPosition   =   70,   loadSize   =   10\n   …\n  При першому завантаженні   PagedList  отримав   50  записів. І далі довантажує порціями по 10.  prefetchDistance   PagedList  використовує цей параметр, щоб визначити, коли треба довантажувати наступну порцію даних. За замовчуванням цей параметр дорівнює   pageSize . Можна задати своє значення.     PagedList  .  Config   config   =   configBuilder\n          .  setEnablePlaceholders  (  false  )\n          .  setPageSize  (  10  )\n          .  setPrefetchDistance  (  20  )\n          .  build  ();\n  Тепер   PagedList  буде довантажувати нові дані, коли при прокручуванні залишається   20  записів до кінця списку.  Placeholders   Презентація  з Google IO.   PagedList  зазвичай не знає скільки всього буде даних. Він у міру прокрутки списку довантажує дані і додає їх у список. Він буде так робити, поки в   Storage  не закінчаться дані.  Але є й інший режим. Коли   PagedList  виконує первісне завантаження даних, ми можемо відразу повідомити йому, що у нас очікується, наприклад,   100  записів.   PagedList  повідомить про це адаптеру, і список відразу покаже   100  записів. Реальними з них будуть тільки ті, які були отримані під час початкового завантаження. Решта будуть фейковими, замість реальних даних там будуть   null -заглушки.  Тобто для таких записів метод адаптера   getItem(position)  повертатиме   null . Відповідно, нам треба буде навчити   Holder  адекватно реагувати на   null -дані, які ми йому передаємо, і відображати якусь візуальну заглушку, що показує користувачеві, що дані поки що не доступні.  Далі, у міру прокручування списку,   PagedList  буде довантажувати реальні дані і відображати їх замість заглушок.  Я зробив приклад із розміром сторінки   = 5    Список містить   100  рядків. Саме це значення я передав у   PagedList  під час завантаження початкового завантаження даних. Видно, що весь список, крім початкових даних, заповнений заглушками. У міру прокручування списку виконується підвантаження даних і заглушки замінюються отриманими реальними даними. Нових записів у список додаватися вже не буде.  Реалізувати це нескладно.  У конфігурації   PagedList  треба ввімкнути   placeholders .     PagedList  .  Config   config   =   configBuilder\n          .  setEnablePlaceholders  (  true  )\n          .  setPageSize  (  5  )\n          .  build  ();\n  Код методу   loadInitial  треба буде трохи переписати.     @  Override\n   public   void   loadInitial  (@  NonNull   LoadInitialParams   params, @  NonNull   LoadInitialCallback  \u003C  Employee  >   callback) {\n      Log.  d  (TAG,   \"loadInitial, requestedStartPosition = \"   +   params.requestedStartPosition   +\n              \", requestedLoadSize = \"   +   params.requestedLoadSize);\n      EmployeeData   result   =   employeeStorage.  getInitialData  (params.requestedStartPosition, params.requestedLoadSize);\n      if   (params.placeholdersEnabled) {\n          callback.  onResult  (result.data, result.position, result.count);\n      }   else   {\n          callback.  onResult  (result.data, result.position);\n      }\n   }\n   EmployeeStorage  повинен вміти повертати нам кількість записів, які він містить. Він може повертати це значення разом із даними в методі   getInitialData . Або можна отримувати це значення викликом окремого методу. Тут усе залежить від реалізації   Storage .  Отримане значення нам слід передати як третій параметр у   callback.onResult . У такий спосіб   PagedList  знатиме, скільки записів треба відобразити в списку.  Зверніть увагу, в коді я роблю перевірку параметра   placeholdersEnabled . Якщо він увімкнений, то я передаю кількість записів у колбек, інакше - не передаю. Якщо у вас буде увімкнено параметр   placeholdersEnabled  і ви не передасте кількість записів, то буде помилка:\n  Placeholders requested, but totalCount not provided . Будь ласка, викличте трипараметричний метод   onResult , або вимкніть   placeholders  у   PagedList.Config   PagedList  не зможе заповнити список заглушками, тому що він не знає, скільки записів у ньому буде.  Ну і зміни в холдері, щоб забезпечити підтримку заглушок     public   void   bind  (  Employee   employee) {\n      if   (employee   ==   null  ) {\n          textViewName.  setText  (R.string.wait);\n          textViewSalary.  setText  (R.string.wait);\n      }   else   {\n          textViewName.  setText  (employee.name);\n          textViewSalary.  setText  (employee.salary);\n      }\n   }\n  Якщо адаптер замість реальних даних дає   null , значить це заглушка і треба відобразити якийсь тимчасовий текст.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1006,"path":1007,"dir":984,"title":1008,"description":1009,"keywords":1010,"body":1015},"content:1.android:8.lesson8:3.data-source.md","/android/lesson8/data-source","Paging Library. Види DataSource","Якщо адаптер замість реальних даних дає ґ, значить це заглушка і треба відобразити якийсь тимчасовий текст.",[1011,1012,1013,1014,96],"PositionalDataSource","PageKeyedDataSource","ItemKeyedDataSource","PagingSource","  Paging Library. Види DataSource  Якщо адаптер замість реальних даних дає ґ, значить це заглушка і треба відобразити якийсь тимчасовий текст.  Нагадаю, що   DataSource  - це міст між   PagedList  і   Storage . Де   Storage  може бути базою даних, сервером або ще якимось джерелом даних, які ви хочете відобразити в списку. І оскільки різні   Storage  можуть мати різний формат запиту даних,   DataSource  допомагає привести ці формати в зрозумілі для   PagedList  методи.  У кожного   DataSource  є метод для початкового завантаження даних і метод (або методи) для подальшого підвантаження. Первинне завантаження виконується в момент створення   PagedList , щоб списку було що показати, коли адаптер отримує   PagedList . Далі ми скролимо список, а   PagedList  довантажує дані, використовуючи для цього методи подальшого довантаження.  На даний момент є три різних   DataSource . Загалом вони схожі. Загальні принципи та нюанси їхньої роботи ми вже розглянули дуже докладно в минулих уроках (рекомендую переглянути їх, щоб краще розуміти подальший текст). У цьому уроці я зроблю короткий огляд методів і параметрів, щоб побачити, у чому відмінності.  PositionalDataSource   Презентація  з Google IO.\n  Документація  Цей   DataSource  дає змогу запитувати дані за позицією. Тобто якщо тягнемо дані, наприклад, з БД, то можемо вказати, з якої позиції і скільки даних вантажити. Якщо дані з файлу, то вказуємо з якого рядка і скільки рядків вантажити.   PagedList  сам визначає необхідну позицію, з якої треба вантажити чергову порцію даних, і передає її в   DataSource .  Порожня реалізація має такий вигляд:     class   MyDataSource   extends   PositionalDataSource  \u003C  Value  > {\n   \n      @  Override\n      public   void   loadInitial  (@  NonNull   LoadInitialParams   params  , @  NonNull   LoadInitialCallback  \u003C  Value  >   callback  ) {\n         \n      }\n   \n      @  Override\n      public   void   loadRange  (@  NonNull   LoadRangeParams   params  , @  NonNull   LoadRangeCallback  \u003C  Value  >   callback  ) {\n   \n      }\n   }\n  Value — це тип даних, які очікує отримати PagedList  Метод   loadInitial  — початкове завантаження даних зі Storage   LoadInitialParams  містить такі параметри:     int   requestedStartPosition  — з якої позиції завантажувати.    int   requestedLoadSize  — скільки завантажувати.    int   pageSize  — розмір сторінки (число завантажених даних має бути кратним значенню   pageSize ).    boolean   placeholdersEnabled  — чи ввімкнені placeholders.   LoadInitialCallback  має два варіанти методу для передачі даних у   PagedList :     onResult  (  List  \u003C  Value  >   data,   int   position)  — передаємо дані й указуємо, з якої позиції вони починаються. Якщо список із даними порожній, то   PagedList  вважатиме, що даних зовсім немає.    onResult  (  List  \u003C  Value  >   data,   int   position,   int   totalCount)  — те ж саме, що й попередній варіант, але додатково вказуємо загальну кількість записів. Цей варіант використовується, якщо ввімкнені placeholders.   Метод   loadRange  — подальше підвантаження даних зі Storage  Цей метод викликається під час прокручування списку.   LoadRangeParams  містить такі параметри:     int   startPosition  — з якої позиції завантажувати.    int   loadSize  — скільки завантажувати.   LoadRangeCallback  має один варіант методу для передачі даних у   PagedList :     onResult  (  List  \u003C  T  >   data)  — просто передаємо дані. Якщо список буде порожнім,   PagedList  вважатиме, що дані закінчилися.  PageKeyedDataSource   Презентація  з Google IO.\n  Документація  Цей   DataSource  підходить для спілкування зі   Storage , який разом із черговою порцією даних передає нам якийсь ключ для отримання наступної порції даних.  Це може бути посторінкове завантаження з параметром   page . Ми просимо дані, наприклад, зі   page = 4 .   Storage  повертає нам їх і повідомляє, що наступну порцію можна отримати, передавши йому   page  зі значенням   5 .  Для числових значень   page  це виглядає безглуздим, тому що йде просто додавання одиниці. Але ключ може бути і текстовим. Наприклад, так раніше працював   API Youtube  (не знаю, як зараз). Тобто ми шукаємо відео за якимось пошуковим запитом. Youtube повертає нам першу порцію даних і з ними   текстовий токен . У наступному запиті до Youtube ми передаємо цей токен, щоб отримати наступну порцію результатів нашого пошуку. І так далі.  Також сервер може як ключ взагалі передавати готове посилання, яке треба буде використовувати, щоб отримати наступну порцію даних.  Загалом, основний сенс у тому, що наступний запит даних ми зможемо зробити, використавши для цього якийсь ключ, отриманий у попередньому запиті.  Порожня реалізація     class   MyDataSource   extends   PageKeyedDataSource  \u003C  Key  ,   Value  > {\n   \n      @  Override\n      public   void   loadInitial  (@  NonNull   LoadInitialParams  \u003C  Key  >   params  , @  NonNull   LoadInitialCallback  \u003C  Key  ,   Value  >   callback  ) {\n         \n      }\n   \n      @  Override\n      public   void   loadBefore  (@  NonNull   LoadParams  \u003C  Key  >   params  , @  NonNull   LoadCallback  \u003C  Key  ,   Value  >   callback  ) {\n   \n      }\n   \n      @  Override\n      public   void   loadAfter  (@  NonNull   LoadParams  \u003C  Key  >   params  , @  NonNull   LoadCallback  \u003C  Key  ,   Value  >   callback  ) {\n   \n      }\n   }\n    Key  - це тип ключа (  page ,   токен  тощо), який використовується для отримання даних.   Value  - це тип даних, які очікує отримати   PagedList .   Метод   loadInitial  - початкове завантаження даних.   LoadInitialParams  містить такі параметри:     int   requestedLoadSize  - скільки даних потрібно завантажити.    boolean   placeholdersEnabled  - чи ввімкнено   placeholders .   LoadInitialCallback  має два варіанти методу для передачі даних у   PagedList :     onResult  (  List  \u003C  Value  >   data,   Key   previousPageKey,   Key   nextPageKey)   Передаємо дані та вказуємо ключі для завантаження попередньої та наступної порції даних.  Якщо замість ключа передати   null ,   PagedList  розуміє, що даних у цьому напрямку немає.  Зазвичай   previousPageKey  дорівнює   null , оскільки ми завантажуємо дані з початку, і попередніх порцій немає.    onResult  (  List  \u003C  Value  >   data,   int   position,   int   totalCount,   Key   previousPageKey,   Key   nextPageKey)   Те саме, що й попередній варіант, але додатково вказуємо загальну кількість записів та позицію, з якої ці дані починаються.  Цей варіант використовується, якщо ввімкнено   placeholders .   Метод   loadBefore  - завантаження попередньої порції даних.   Викликається під час прокрутки списку вгору, якщо ви вказали   previousPageKey  під час виклику callback у   loadInitial .  Зазвичай   previousPageKey = null , тому метод   loadBefore  часто не реалізується, оскільки він не викликається.   LoadParams  містить такі параметри:     Key   key  - ключ для отримання даних.    int   requestedLoadSize  - бажаний розмір порції даних. Цей параметр не є обов’язковим, оскільки сервер може мати власне уявлення про розмір порції.   LoadCallback  має один варіант методу для передачі даних у   PagedList :     onResult  (  List  \u003C  Value  >   data,   Key   adjacentPageKey)   Передаємо дані та вказуємо, який ключ використовувати для отримання наступної попередньої порції.  Якщо передати   null ,   PagedList  розуміє, що у цьому напрямку даних більше немає.   Метод   loadAfter  - завантаження наступної порції даних.   Викликається під час прокрутки списку вниз, якщо ви вказали   nextPageKey  під час виклику callback у   loadInitial .   LoadParams  містить такі параметри:     Key   key  - ключ для отримання даних.   int requestedLoadSize{lang=java}  - бажаний розмір порції даних. Цей параметр не є обов’язковим, оскільки сервер може мати власне уявлення про розмір порції.   LoadCallback  має один варіант методу для передачі даних у PagedList:     onResult  (  List  \u003C  Value  >   data,   Key   adjacentPageKey)   Передаємо дані та вказуємо, який ключ використовувати для отримання наступної порції.  Якщо передати   null , PagedList розуміє, що у цьому напрямку даних більше немає.   Важливе зауваження!  Можливі варіанти, коли ми можемо обійтися без отримання ключів від сервера. Наприклад, якщо ми запитуємо дані за номером сторінки (  page ), сервер повертає дані, але не повертає номер наступної сторінки. У такому випадку можна створити лічильник всередині   DataSource  та змінювати його на одиницю після кожного отримання даних.  Це менш надійно, ніж отримувати ключ із сервера, оскільки через помилку в логіці може виникнути розсинхрон із сервером. Проте, якщо немає можливості вплинути на структуру відповіді сервера, іншого вибору немає.  ItemKeyedDataSource   Презентація  з Google IO.  Цей   DataSource  схожий на щойно розглянутий нами   PageKeyedDataSource . Він також використовує попередні отримані від сервера дані для завантаження наступних даних. Але як ключі він використовує не окремі значення типу   page  або   токена , а безпосередньо дані.  Коли ми скролимо список і наближаємося до його кінця,   PagedLIst  візьме останній елемент списку і дасть його нам. А ми, використовуючи цей елемент, маємо завантажити наступну порцію даних, яка слідує за цим останнім елементом.  Найпоказовіший кейс для цього   DataSource  - це відсортований список. Наприклад, ми виводимо з БД записи, відсортовані за будь-яким ключем. Під час скролу списку ми в   DataSource  отримуємо останній елемент списку, і знаючи його ключ, зможемо довантажити наступну за ним порцію даних, використовуючи те ж сортування.  Порожня реалізація     class   MyDataSource   extends   ItemKeyedDataSource  \u003C  Key  ,   Value  > {\n   \n      @  Override\n      public   void   loadInitial  (@  NonNull   LoadInitialParams  \u003C  Key  >   params  , @  NonNull   LoadInitialCallback  \u003C  Value  >   callback  ) {\n         \n      }\n   \n      @  Override\n      public   void   loadAfter  (@  NonNull   LoadParams  \u003C  Key  >   params  , @  NonNull   LoadCallback  \u003C  Value  >   callback  ) {\n   \n      }\n   \n      @  Override\n      public   void   loadBefore  (@  NonNull   LoadParams  \u003C  Key  >   params  , @  NonNull   LoadCallback  \u003C  Value  >   callback  ) {\n   \n      }\n   \n      @  NonNull\n      @  Override\n      public   Key   getKey  (@  NonNull   Value   item  ) {\n          return   null  ;\n      }\n   }\n   Key - це тип даних, який буде використовуватися в якості ключа.  Value - це тип даних, які очікує отримати PagedList.   Метод   getKey  - тут від нас вимагається вказати, як отримати ключ з елемента списку.  Наприклад, якщо у нас тип даних (Value) - це, наприклад,   Employee , то тип Key може бути   Long , а метод виглядатиме так:     public   Long   getKey  (@  NonNull   Employee   item) {\n      return   item.id;\n   }\n  Тепер   PagedList  знає, як з будь-якого елемента списку отримати ключ, який буде використовуватися для завантаження наступних даних.  Може бути так, що вам у якості ключа потрібен весь елемент. Тоді реалізація виглядатиме так:     public   Employee   getKey  (@  NonNull   Employee   item) {\n      return   item;\n   }\n  Тобто типи   Key  і   Value  обидва рівні   Employee .\nЯк отримувати   Key  з   Value  - залежить від вашого завдання.   Метод   loadInitial  - початкове завантаження даних.   LoadInitialParams  містить такі параметри:     Key   requestedInitialKey   - ключ для початкового завантаження даних (може бути вказано методом   setInitialKey  у   PagedList.Builder  або в   LivePagedListBuilder ).    int   requestedLoadSize   - скільки даних потрібно завантажити.    boolean   placeholdersEnabled   - чи ввімкнено placeholders.   LoadInitialCallback  має два варіанти методу для передачі даних у   PagedList :     onResult  (@  NonNull   List  \u003C  Value  >   data)   Тільки передаємо дані.    onResult  (@  NonNull   List  \u003C  Value  >   data,   int   position,   int   totalCount)   Те саме, що й попередній варіант, але додатково вказуємо загальну кількість записів та позицію, з якої ці дані починаються.  Цей варіант використовується, якщо ввімкнено placeholders.   Метод   loadBefore  - завантаження попередньої порції даних.  Викликається при прокрутці списку вгору, щоб завантажити попередні записи.   LoadParams  містить такі параметри:     Key   key   - ключ для отримання даних.   PagedList  бере перший елемент списку, отримує з нього ключ методом   getKey  і дає цей ключ нам.    int   requestedLoadSize   - бажаний розмір порції даних. Цей параметр не є обов'язковим, оскільки сервер може мати власне уявлення про розмір порції.   LoadCallback  має один варіант методу для передачі даних у   PagedList :     onResult  (  List  \u003C  Value  >   data)   Передаємо дані. Якщо передати порожній список,   PagedList  зрозуміє, що в цьому напрямку даних більше немає.   Метод   loadAfter  - завантаження наступної порції даних.  Викликається при прокрутці списку вниз, щоб завантажити наступні записи.   LoadParams  містить такі параметри:     Key   key   - ключ для отримання даних.   PagedList  бере останній елемент списку, отримує з нього ключ методом   getKey  і дає цей ключ нам.    int   requestedLoadSize   - бажаний розмір порції даних. Цей параметр не є обов'язковим, оскільки сервер може мати власне уявлення про розмір порції.   LoadCallback  має один варіант методу для передачі даних у   PagedList :     onResult  (  List  \u003C  Value  >   data)   Передаємо дані. Якщо передати порожній список,   PagedList  зрозуміє, що в цьому напрямку даних більше немає.  PagingSource   PagingSource  - це джерело даних, яке відповідає за завантаження сторінок даних в обробці пагінації. Він дозволяє завантажувати нові порції даних через методи   load() , керуючи процесом їх отримання та кешування. PagingSource використовується для завантаження даних з віддалених джерел або локальних баз даних, де потрібно отримувати сторінки.   Метод   load  - основний метод, що виконує завантаження даних.  Метод   load  має параметр   LoadParams , який містить необхідну інформацію для отримання сторінки даних:    LoadParams.Key key  - ключ для завантаження даних. Зазвичай це сторінка або інший параметр, залежно від специфікацій джерела.   int loadSize  - кількість елементів, які потрібно завантажити в одну порцію.  Метод   load  має повернути об'єкт типу   LoadResult , який є результатом запиту. Існують три можливі типи результату:     LoadResult.Page  - повертає одну сторінку даних.     LoadResult  .  Page  \u003C  Value  > page   =   new   LoadResult  .  Page  \u003C>(\n       data   =   dataList,\n       prevKey   =   previousPageKey,\n       nextKey   =   nextPageKey\n   );\n    data  - список завантажених даних.   prevKey  - ключ для попередньої сторінки, якщо вона є. Якщо немає попередньої сторінки, передаємо   null .   nextKey  - ключ для наступної сторінки, якщо вона є. Якщо немає наступної сторінки, передаємо   null .    LoadResult.Error  - помилка при завантаженні даних.     LoadResult  .  Error  \u003C  Value  > error   =   new   LoadResult  .  Error  \u003C>(exception);\n   Повертає помилку, яка була викинута під час завантаження.    LoadResult.Invalid  - результат, що вказує на невірні параметри для завантаження сторінки.   Ключі завантаження    Key  - це тип даних, що використовуватиметься як ключ для отримання наступної або попередньої сторінки. Зазвичай це сторінка або унікальний ідентифікатор.   Value  - це тип даних, які ви очікуєте отримати після завантаження сторінки.   Параметри   LoadParams :    Key key  - ключ для отримання даних. Наприклад, це може бути номер сторінки або токен.   int loadSize  - кількість елементів, які потрібно завантажити в одній порції.   Важливе зауваження:   PagingSource  дозволяє отримувати дані і працювати з ними через механізм пагінації. Важливо враховувати правильний вибір ключа, оскільки ключі визначають, як переходити до наступних або попередніх сторінок даних.  Якщо ваш API використовує сторінкові параметри (наприклад,   page ,   limit ), ви будете використовувати прості значення для ключів (наприклад, числа для сторінок). У випадку більш складних систем, де відповіді API містять токени або унікальні ідентифікатори для наступних запитів, ваш ключ може бути складнішим (наприклад, рядковий токен).   Підсумок:   PagingSource  — це механізм, який дає змогу ефективно працювати з великими наборами даних через пагінацію, дозволяючи контролювати процес завантаження сторінок і обробку ключів для подальших запитів.  Приклад  Припустимо, ми маємо API, яке повертає список користувачів за допомогою пагінації, де кожен запит має параметр page для завантаження наступної порції даних. Ми хочемо створити   PagingSource , який буде використовувати цей параметр для завантаження даних.     public   class   UsersPagingSource   extends   PagingSource  \u003C  Integer  ,   User  > {\n   \n       private   final   ApiService   apiService;\n   \n       public   UsersPagingSource  (  ApiService   apiService  ) {\n           this  .apiService   =   apiService;\n       }\n   \n       @  Override\n       public   LoadResult  \u003C  Integer  ,   User  >   load  (@  NonNull   LoadParams  \u003C  Integer  >   params  ) {\n           int   page   =   params.  getKey  ()   !=   null   ?   params.  getKey  ()   :   1  ;   // Починаємо з першої сторінки\n   \n           try   {\n               // Викликаємо API для завантаження користувачів\n               Response  \u003C  UserResponse  > response   =   apiService.  getUsers  (page, params.  getLoadSize  ()).  execute  ();\n   \n               if   (response.  isSuccessful  ()) {\n                   List  \u003C  User  > users   =   response.  body  ().  getUsers  ();\n   \n                   // Повертаємо результат як LoadResult.Page\n                   return   new   LoadResult  .  Page  \u003C>(\n                           users,   // Дані користувачів\n                           (page   ==   1  )   ?   null   :   page   -   1  ,   // Попередній ключ, null на першій сторінці\n                           (users.  isEmpty  ())   ?   null   :   page   +   1   // Наступний ключ, null якщо немає більше даних\n                   );\n               }   else   {\n                   return   new   LoadResult  .  Error  \u003C>(  new   Exception  (  \"API error\"  ));\n               }\n           }   catch   (  Exception   e  ) {\n               return   new   LoadResult  .  Error  \u003C>(e);   // Повертаємо помилку\n           }\n       }\n   }\n     public   class   UserRepository   {\n   \n       private   final   ApiService   apiService;\n   \n       public   UserRepository  (  ApiService   apiService  ) {\n           this  .apiService   =   apiService;\n       }\n   \n       public   LiveData  \u003C  PagingData  \u003C  User  >>   getUsers  () {\n           return   new   Pager  (\n               new   PagingConfig  (  20  ,   10  ,   false  ),   // pageSize = 20, enablePlaceholders = false\n               ()   ->   new   UsersPagingSource  (apiService)   // Вказуємо наш PagingSource\n           ).  getLiveData  ();\n       }\n   }\n     public   class   UsersFragment   extends   Fragment   {\n   \n       private   UserRepository   userRepository;\n       private   PagingDataAdapter  \u003C  User  ,   UserViewHolder  > adapter;\n   \n       @  Override\n       public   void   onViewCreated  (@  NonNull   View   view  , @  Nullable   Bundle   savedInstanceState  ) {\n           super  .  onViewCreated  (view, savedInstanceState);\n   \n           // Ініціалізація адаптера\n           adapter   =   new   UserAdapter  ();\n   \n           // Отримуємо PagingData з репозиторію\n           userRepository.  getUsers  ().  observe  (  getViewLifecycleOwner  (), pagingData   ->   {\n               adapter.  submitData  (  getLifecycle  (), pagingData);\n           });\n   \n           // Підключаємо адаптер до RecyclerView\n           RecyclerView   recyclerView   =   view.  findViewById  (R.id.recycler_view);\n           recyclerView.  setAdapter  (adapter);\n       }\n   }\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1017,"path":1018,"dir":984,"title":1019,"description":1020,"keywords":1021,"body":1022},"content:1.android:8.lesson8:4.android-data-binding-basic.md","/android/lesson8/android-data-binding-basic","Android Data Binding. Основи","У build.gradle файл модуля в секції android необхідно включити Data Binding:",[],"  Android Data Binding. Основи  У   build.gradle  файл модуля в секції   android  необхідно включити   Data Binding :   android {\n    ....\n    dataBinding {\n        enabled = true\n    }\n}\n   Data Binding  допоможе організувати роботу з   View  так, щоб нам не довелося писати купу методів   findViewById ,   setText ,   setOnClickListener  тощо. Давайте розглянемо простий приклад.  Є клас   Employee , який містить у собі дані про працівника     public   class   Employee   {\n    \n      public   Employee  (  long   id  ,   String   name  ,   String   address  ) {\n          this  .id   =   id;\n          this  .name   =   name;\n          this  .address   =   address;\n      }\n    \n      public   long   id;\n    \n      public   String   name;\n    \n      public   String   address;\n   }\n  Ми хочемо вивести   ім'я  та   адресу працівника  на екран main_activity.xml:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  LinearLayout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n      android:layout_width  =  \"match_parent\"\n      android:layout_height  =  \"match_parent\"\n      android:orientation  =  \"vertical\"  >\n    \n      \u003C  TextView\n          android:id  =  \"@+id/name\"\n          android:layout_width  =  \"wrap_content\"\n          android:layout_height  =  \"wrap_content\"  />\n    \n      \u003C  TextView\n          android:id  =  \"@+id/address\"\n          android:layout_width  =  \"wrap_content\"\n          android:layout_height  =  \"wrap_content\"  />\n    \n   \u003C/  LinearLayout  >\n  Нескладне завдання. Для цього ми зазвичай пишемо методи   findViewById  і   setText . Тут усе зрозуміло.  Давайте розглянемо, як це ж можна зробити за допомогою Data Binding.  Вносимо зміни в   main_activity.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  layout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"  >\n    \n      \u003C  data  >\n    \n          \u003C  variable\n              name  =  \"employee\"\n              type  =  \"ru.startandroid.application.data.Employee\"   />\n    \n      \u003C/  data  >\n    \n   \u003C  LinearLayout\n      android:layout_width  =  \"match_parent\"\n      android:layout_height  =  \"match_parent\"\n      android:orientation  =  \"vertical\"  >\n    \n          \u003C  TextView\n              android:layout_width  =  \"wrap_content\"\n              android:layout_height  =  \"wrap_content\"\n              android:text  =  \"@{employee.name}\"   />\n    \n          \u003C  TextView\n              android:layout_width  =  \"wrap_content\"\n              android:layout_height  =  \"wrap_content\"\n              android:text  =  \"@{employee.address}\"   />\n    \n      \u003C/  LinearLayout  >\n    \n   \u003C/  layout  >\n  Кореневим елементом тепер є   \u003Clayout> , а   LinearLayout  змістився всередину нього.  У секції   data  ми оголошуємо змінну з ім'ям   employee . Її тип - раніше розглянутий клас   Employee . Тепер ми можемо використовувати цю змінну в атрибутах в'юшок цього   layout . У першому   TextView , в атрибуті   text  ми використовуємо   employee.name , а в другому   TextView  -   employee.address .  Зверніть увагу, що ми не вказуємо   id  для   View . У цьому немає необхідності.  Як ви розумієте, нам залишається лише передати об'єкт   Employee  у цей   layout . І значення цього об'єкта будуть підставлені у відповідні   TextView .  Це робиться таким чином.     public   class   MainActivity   extends   AppCompatActivity   {\n    \n      @  Override\n      protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n          super  .  onCreate  (savedInstanceState);\n    \n          Employee   employee   =   new   Employee  (  1  ,   \"John Smith\"  ,   \"London\"  );\n    \n          MainActivityBinding   binding   =   DataBindingUtil.  setContentView  (  this  , R.layout.main_activity);\n          binding.  setEmployee  (employee);\n      }\n   }\n  Спочатку створюємо   Employee  об'єкт.  Потім використовуємо   DataBindingUtil . Метод   DataBindingUtil.setContentView  всередині себе зробить звичний нам   setContentView  для   Activity , а також налаштує і поверне об'єкт біндингу   MainActivityBinding .   MainActivityBinding  - це згенерований клас. Ім'я цього класу береться з імені   layout  файлу (тобто   main_activity ), плюс слово   Binding .   MainActivityBinding  все знає про наш   layout : які   View  там є, які змінні (  variable ) ми там вказували, і як все це пов'язати одне з одним, щоб дані зі змінних потрапляли в   View .  Метод   setEmployee  був згенерований у класі біндингу, оскільки ми описали змінну   employee  у   layout  файлі. Цим методом ми передаємо біндингу об'єкт   Employee . Біндінг візьме значення   employee.name  і   employee.address  і помістить їх (методом   setText ) у відповідні   TextView . Усе, як ми й налаштовували в   layout .  Запускаємо додаток\n   Дані з   Employee  поміщені в   TextView .  Одразу хочу зауважити, що якщо ми тепер у коді будемо змінювати об'єкт   Employee , то дані на екрані змінюватися не будуть. Вони рахувалися один раз і далі не відстежуються (за такої реалізації).  Щоб екран отримав нові дані, треба знову передати біндингу змінений об'єкт   Employee :     binding.  setEmployee  (employee);\n  Або можна викликати метод   invalidateAll :     binding.  invalidateAll  ();\n  Біндинг рахує нові дані з раніше отриманого об'єкта   Employee .  Поля в Employee у цьому прикладі я зробив   public . Але ви можете зробити їх   private  і створити для них   public get  методи.  Можливо, використання біндингу для пари   TextView  здається безглуздим. Але коли таких   TextView  десятки, то біндинг може позбавити вас від написання купи коду.  Крім того, ми розглянули зовсім простий випадок використання біндингу. Але його можливості набагато ширші. Наприклад, можна зробити так, щоб під час передачі в атрибут   ImageView  посилання на картинку, біндінг запускав   Picasso  для завантаження цієї картинки і поміщав результат в   ImageView . Або біндінг може сам відстежувати зміни в об'єкті з даними (у прикладі вище - це   Employee ) і оновлювати екран без будь-яких додаткових методів.  Ці можливості ми розглянемо в наступних уроках.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1024,"path":1025,"dir":984,"title":1026,"description":1027,"keywords":1028,"body":1030},"content:1.android:8.lesson8:5.android-data-binding-extend.md","/android/lesson8/android-data-binding-extend","Android Data Binding. Код у layout. Доступ до View","Продовжуємо говорити про DataBinding. Ми вже розглянули, як можна поміщати значення з об'єктів у TextView. Але біндинг цим не обмежується і дає нам можливість писати код прямо в layout.",[1029],"View","  Android Data Binding. Код у layout. Доступ до View  Продовжуємо говорити про   DataBinding . Ми вже розглянули, як можна поміщати значення з об'єктів у   TextView . Але біндинг цим не обмежується і дає нам можливість писати код прямо в   layout .  Давайте розглянемо приклади, коли це може знадобитися.\nЄ клас   Employee :     public   class   Employee   {\n    \n      public   Employee  (  long   id  ,   String   name  ,   String   address  ,   int   salary  ) {\n          this  .id   =   id;\n          this  .name   =   name;\n          this  .address   =   address;\n          this  .salary   =   salary;\n      }\n    \n      public   long   id;\n    \n      public   String   name;\n    \n      public   String   address;\n    \n      public   int   salary;\n   }\n  Ми хочемо виводити на екран   ім'я, адресу і зарплату .  Екран буде таким:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  layout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"  >\n    \n      \u003C  data  >\n    \n          \u003C  variable\n              name  =  \"employee\"\n              type  =  \"ru.startandroid.application.data.Employee\"   />\n    \n      \u003C/  data  >\n    \n      \u003C  LinearLayout\n          android:layout_width  =  \"match_parent\"\n          android:layout_height  =  \"match_parent\"\n          android:orientation  =  \"vertical\"  >\n    \n          \u003C  TextView\n              android:layout_width  =  \"wrap_content\"\n              android:layout_height  =  \"wrap_content\"\n              android:text  =  \"@{employee.name}\"   />\n    \n          \u003C  TextView\n              android:layout_width  =  \"wrap_content\"\n              android:layout_height  =  \"wrap_content\"\n              android:text  =  \"@{employee.address}\"   />\n    \n          \u003C  TextView\n              android:layout_width  =  \"wrap_content\"\n              android:layout_height  =  \"wrap_content\"\n              android:text  =  \"@{employee.salary}\"   />\n    \n      \u003C/  LinearLayout  >\n    \n   \u003C/  layout  >\n  А виклик біндингу таким:     @  Override\n   protected   void   onCreate  (  Bundle   savedInstanceState) {\n      super  .  onCreate  (savedInstanceState);\n    \n      Employee   employee   =   new   Employee  (  1  ,   \"John Smith\"  ,   \"London\"  ,   10000  );\n    \n      MainActivityBinding   binding   =   DataBindingUtil.  setContentView  (  this  , R.layout.main_activity);\n      binding.  setEmployee  (employee);\n   }\n  Нічого незвичайного. Усе так само, як і в минулому уроці.  Але під час запуску отримаємо помилку:   android.content.res.Resources$NotFoundException: String resource ID #0x2710  Так сталося, тому що біндінг спробував відобразити поле   salary  в   TextView . Він просто виконав код   setText(employee.salary) . І оскільки   salary  у нас має тип   int , то   TextView  вирішив, що йому передають   ідентифікатор рядкового ресурсу . І, звісно, він не знайшов такий рядок у   strings.xml .  Це досить часта помилка, що виникає. І в коді ми зазвичай вирішуємо її за допомогою   String.valueOf() :     textView.  setText  (String.  valueOf  (employee.salary));\n  Біндінг дає змогу зробити нам те саме прямо в   layout :     \u003C  TextView\n      android:layout_width  =  \"wrap_content\"\n      android:layout_height  =  \"wrap_content\"\n      android:text  =  \"@{String.valueOf(employee.salary)}\"   />\n  Тобто всередині   @{ ... }  ми можемо писати найпростіший код і він буде виконаний.  Запустивши додаток, ми побачимо зарплату в   TextView .  Розглянемо ще кілька прикладів:  Відображення в одному   TextView  відразу двох полів   Employee     \u003C  TextView\n      android:layout_width  =  \"wrap_content\"\n      android:layout_height  =  \"wrap_content\"\n      android:text  =  '@{employee.name + \", \" + employee.address}'   />\n  Зверніть увагу на лапки. Оскільки нам потрібні подвійні лапки, щоб додати кому між   name  і   address , то весь цей код ми поміщаємо в одинарні лапки.  Видимість   View  залежно від значення поля     \u003C  TextView\n      android:layout_width  =  \"wrap_content\"\n      android:layout_height  =  \"wrap_content\"\n      android:text  =  \"@{employee.address}\"\n      android:visibility  =  \"@{TextUtils.isEmpty(employee.address) ? View.GONE : View.VISIBLE}\"  />\n  Адреса буде відображена, тільки якщо вона не порожня. А за порожньої адреси видимість цього   TextView  буде   GONE .  Зверніть увагу, що ми тут використовуємо класи   TextUtils  і   View . Якщо зараз спробувати запустити додаток, то ми отримаємо таку помилку:   Identifiers must have user defined types from the XML file. TextUtils is missing it  Біндінг каже, що не знає нічого про   TextUtils . Нам треба додати його в   import . Робиться це в секції   data .     \u003C  data  >\n      \u003C  import   type  =  \"android.view.View\"  />\n      \u003C  import   type  =  \"android.text.TextUtils\"  />\n    \n      \u003C  variable   .../>\n    \n   \u003C/  data  >\n  Тепер біндінг знає, які класи ми маємо на увазі  Тобто це аналогічно тому, як у java коді ви пишете:     import   android.text.TextUtils  ;\n   import   android.view.View  ;\n  і після цього можете використовувати ці класи.  Використання   resources  значення:   strings ,   dimens  тощо.     \u003C  TextView\n      android:layout_width  =  \"wrap_content\"\n      android:layout_height  =  \"wrap_content\"\n      android:text  =  \"@{TextUtils.isEmpty(employee.address) ? @string/empty_address : employee.address}\"  />\n  Якщо адреса порожня, то показуємо заглушку зі   strings .  У прикладах вище ми використовували в   layout  тільки одну змінну -   Employee . Давайте додамо ще одну.  Створимо новий клас, який міститиме інформацію про   відділ     public   class   Department   {\n    \n      public   Department  (  long   id  ,   String   name  ) {\n          this  .id   =   id;\n          this  .name   =   name;\n      }\n    \n      public   long   id;\n    \n      public   String   name;\n   }\n  Додамо змінну типу   Department  у layout     \u003C  data  >\n    \n      \u003C  variable\n          name  =  \"employee\"\n          type  =  \"ru.startandroid.application.data.Employee\"   />\n    \n      \u003C  variable\n          name  =  \"department\"\n          type  =  \"ru.startandroid.application.data.Department\"   />\n    \n   \u003C/  data  >\n  І використовуємо її:     \u003C  TextView\n      android:layout_width  =  \"wrap_content\"\n      android:layout_height  =  \"wrap_content\"\n      android:text  =  '@{employee.name + \"(\" + department.name + \")\"}'   />\n  В одному   TextView  показуємо дані з двох змінних.  Код виконання біндингу матиме такий вигляд:     @  Override\n   protected   void   onCreate  (  Bundle   savedInstanceState) {\n      super  .  onCreate  (savedInstanceState);\n    \n      Employee   employee   =   new   Employee  (  1  ,   \"John Smith\"  ,   \"\"  ,   10000  );\n      Department   department   =   new   Department  (  100  ,   \"IT\"  );\n    \n      MainActivityBinding   binding   =   DataBindingUtil.  setContentView  (  this  , R.layout.main_activity);\n      binding.  setEmployee  (employee);\n      binding.  setDepartment  (department);\n   }\n  Для змінної   Department  у класі   MainActivityBinding  було згенеровано окремий метод   setDepartment .  Можна трохи ускладнити логіку і показувати назву відділу, тільки якщо ми передали об'єкт   Department  у біндинг:     \u003C  TextView\n      android  :  layout_width  =  \"wrap_content\"\n      android  :  layout_height  =  \"wrap_content\"\n      android  :  text  =  '@{employee.name + (department == null ? \"\" : \" (\" + department.name + \")\") }'   />\n  Біндінг вміє працювати і з колекціями. Наприклад, якщо в   Employee  є поле зі   списком хобі :     public   List  \u003C  String  > hobbies;\n  то, в   layout  ми можемо відобразити   перше хобі  зі списку таким чином:     \u003C  TextView\n      android:layout_width  =  \"wrap_content\"\n      android:layout_height  =  \"wrap_content\"\n      android:text  =  \"@{employee.hobbies[0]}\"   />\n  Якщо нам необхідно використовувати список як окрему змінну в   layout , то   variable  матиме такий вигляд:     \u003C  variable\n      name  =  \"hobbies\"\n      type  =  \"java.util.List  &lt;  String  &gt;  \"   />\n  Обмеження XML не дають змоги просто так використовувати символи   \u003C  і   > . Тому їх доводиться замінювати спецсимволами \u003C і >.  Той самий опис змінної, але   List  винесено в імпорт:     \u003C  import   type  =  \"java.util.List\"  />\n    \n   \u003C  variable\n      name  =  \"hobbies\"\n      type  =  \"List  &lt;  String  &gt;  \"   />\n   Map  колекції описуються аналогічно:     \u003C  import   type  =  \"java.util.Map\"  />\n    \n   \u003C  variable\n      name  =  \"map\"\n      type  =  \"Map  &lt;  String, String  &gt;  \"  />\n  Отримання значення за ключем:     \u003C  TextView\n      android:layout_width  =  \"wrap_content\"\n      android:layout_height  =  \"wrap_content\"\n      android:text  =  \"@{map[`key`]}\"   />\n  В   офіційній документації  ви можете подивитися повний список можливостей написання коду в   layout .  View  Якщо нам потрібні будь-які   View  з нашого   layout , то їх можна отримати з біндингу. Для цього необхідно, щоб   View  мало   id .  Наприклад, якщо в   layout  є поле:     \u003C  TextView\n       android:id  =  \"@+id/name\"\n       android:layout_width  =  \"wrap_content\"\n       android:layout_height  =  \"wrap_content\"   />\n  то ми можемо отримати його з біндингу так:     TextView   textViewName   =   binding.name;\n  Також можна отримати кореневе   View  методом   getRoot :     View   rootView   =   binding.  getRoot  ();\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1032,"path":1033,"dir":984,"title":1034,"description":1035,"keywords":1036,"body":1039},"content:1.android:8.lesson8:6.event-handling.md","/android/lesson8/event-handling","Android Data Binding. Обробка подій","За допомогою біндингу ми можемо вішати обробники на події View. Є два способи це зробити, давайте розглянемо їх.",[1037,1038],"Посилання на метод","Виклик методу","  Android Data Binding. Обробка подій  За допомогою біндингу ми можемо вішати обробники на події   View . Є два способи це зробити, давайте розглянемо їх.  Посилання на метод  Розглянемо приклад з   onClick . Припустимо, у нас на екрані, який відображає дані щодо працівника (  Employee ), є кнопка   Delete , і ми хочемо присвоїти їй   onClick  обробник.  Створюємо свій клас обробник:     public   class   MyHandler    {\n    \n      public   void   onDelete  (  View   view  ) {\n          // ...\n      }\n   }\n  Він не обов'язково має наслідувати   OnClickListener . Але його метод має бути public і мати ті самі параметри, що й метод   OnClickListener.onClick(View view view) , тобто має бути один параметр типу   View . Ім'я методу може бути будь-яким.  Прописуємо цей обробник, як   variable  у   layout .     \u003C  data  >\n      \u003C  variable\n          name  =  \"handler\"\n          type  =  \"ru.startandroid.application.MyHandler\"   />\n      \n      ...\n    \n   \u003C/  data  >\n  В   onClick  кнопки посилаємося на його метод   onDelete :     \u003C  Button\n      android:layout_width  =  \"wrap_content\"\n      android:layout_height  =  \"wrap_content\"\n      android:text  =  \"@string/delete\"\n      android:onClick  =  \"@{handler::onDelete}\"  />\n  Залишилося створити об'єкт   MyHandler  і передати його в біндинг:     MyHandler   myHandler   =   new   MyHandler  ();\n   binding.  setHandler  (myHandler);\n  Після натискання на кнопку   Delete  буде викликано метод   onDelete  об'єкта   myHandler .  Якщо під час спроби налаштувати обробник у біндингу ви отримуєте подібну помилку:   Listener class android.view.View.View.OnClickListener with method onClick did not match signature of any method handler::onDelete  уважно перевірте, що модифікатори доступу та параметри методу у вашому обробнику такі самі, що й у методі інтерфейсу стандартного обробника. У випадку з   onClick  - це   OnClickListener .  Виклик методу  Якщо в першому способі ми просто вказували біндингу, який метод обробника викликати, то в другому способі ми просто самі будемо викликати цей метод. Цей спосіб більш гнучкий, тому що метод нашого обробника не зобов'язаний мати ті самі параметри, що й метод інтерфейсу стандартного обробника.  Розглянемо знову приклад з   onClick . Створюємо обробник.     public   class   MyHandler    {\n    \n      public   void   onDelete  (  Employee   employee  ) {\n          // ...\n      }\n    \n   }\n  У метод   onDelete  ми плануємо отримувати не   View , як у прикладі раніше, а об'єкт   Employee .   MyHandler  так само, як і раніше, прописуємо в   variable  і передаємо в   binding .  В   onClick  кнопки пишемо виклик     \u003C  Button\n      android:layout_width  =  \"wrap_content\"\n      android:layout_height  =  \"wrap_content\"\n      android:text  =  \"@string/delete\"\n      android:onClick  =  \"@{(view) -> handler.onDelete(employee)}\"  />\n  Тут використовується лямбда. На вхід нам пропонуються ті самі параметри, що і в методі інтерфейсу стандартного обробника, тобто view з   OnClickListener.onClick(View view) . Але ми не використовуємо цей параметр. У метод   onDelete  ми передаємо   employee , який у нас описаний, як один із   variable  у   layout .  У результаті після натискання на кнопку, біндінг надасть нам   View , на яке було натискання. Але ми його проігноруємо, візьмемо у біндингу об'єкт   Employee  і відправимо в   handler.onDelete .  Біндінг дає нам можливість не писати параметри в лямбді, якщо вони нам не потрібні. Тобто можна зробити так:     \u003C  Button\n      android:layout_width  =  \"wrap_content\"\n      android:layout_height  =  \"wrap_content\"\n      android:text  =  \"@string/delete\"\n      android:onClick  =  \"@{() -> handler.onDelete(employee)}\"  />\n  Таким чином біндінг зрозуміє, що його   View  нам не потрібен, і не буде його передавати. Майте на увазі, що якщо в стандартному обробнику кілька параметрів, то ви можете вказати або всі параметри, або жодного.  Щоб закріпити тему, давайте розглянемо приклад із   CheckBox . Наприклад, на екрані з даними щодо працівника є чекбокс   Enabled , який вмикає/вимикає працівника.  В обробнику створюємо метод,     public   class   MyHandler    {\n    \n      public   void   onEnabled  (  Employee   employee  ,   boolean   enabled  ) {\n          // ...\n      }\n   }\n  Будемо отримувати об'єкт   Employee  і стан чекбокса.  В   onCheckedChanged  пишемо виклик методу нашого обробника.     \u003C  CheckBox\n      android:layout_width  =  \"wrap_content\"\n      android:layout_height  =  \"wrap_content\"\n      android:text  =  \"@string/enabled\"\n      android:onCheckedChanged  =  \"@{(view, checked) -> handler.onEnabled(employee, checked)}\"   />\n  У лямбді вказуємо параметри, які прийшли б нам у стандартному обробнику   OnCheckedChangeListener .  onCheckedChanged(CompoundButton compoundButton, boolean checked) .  Параметр   view  нам не знадобиться, а ось   checked  передаємо в метод разом із   employee .  Тепер після натискання на чекбокс, біндінг викликатиме метод   onEnabled  і передаватиме туди   Employee  об'єкт і стан чекбокса.  Розглянемо ще кілька цікавих моментів.  Під час виклику обробника ми можемо використовувати умови.  Наприклад, є такий обробник.     public   class   MyHandler    {\n      public   void   onEnabled  (  Employee   employee  ) {\n          // ...\n      }\n    \n      public   void   onDisabled  (  Employee   employee  ) {\n          // ...\n      }\n   }\n  Ми можемо в   layout  вказати його методи таким чином     \u003C  CheckBox\n      android:layout_width  =  \"wrap_content\"\n      android:layout_height  =  \"wrap_content\"\n      android:text  =  \"@string/enabled\"\n      android:onCheckedChanged  =  \"@{(view, checked) -> checked ? handler.onEnabled(employee) : handler.onDisabled(employee)}\"  />\n  Тобто якщо чекбокс увімкнено, то викликаємо метод   onEnabled , інакше -   onDisabled .  Якщо в одному з випадків нам нічого не треба викликати, то можна використовувати   void     \u003C  CheckBox\n      android:layout_width  =  \"wrap_content\"\n      android:layout_height  =  \"wrap_content\"\n      android:text  =  \"@string/enabled\"\n      android:onCheckedChanged  =  \"@{(view, checked) -> checked ? handler.onEnabled(employee) : void}\"  />\n  У біндигу за замовчуванням є змінна   context , яку ви завжди можете використовувати, якщо є необхідність.     \u003C  CheckBox\n      android:layout_width  =  \"wrap_content\"\n      android:layout_height  =  \"wrap_content\"\n      android:text  =  \"@string/enabled\"\n      android:onCheckedChanged  =  \"@{(view, checked) -> handler.onEnabled(employee, checked, context)}\"  />\n  Значення змінної   context  отримано викликом методу   getContext  у кореневого   View  вашого layout.  У цих прикладах я створював окремий об'єкт обробника, але, звісно, ви можете створювати інтерфейси, прописувати їх як   variable  у   layout  і використовувати хоч саме   Activity  як реалізацію.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1041,"path":1042,"dir":984,"title":1043,"description":1044,"keywords":1045,"body":1049},"content:1.android:8.lesson8:7.observable.md","/android/lesson8/observable","Android Data Binding. Observable поля. Двосторонній біндинг.","Коли ми використовуємо біндинг для звичайного Java-об'єкта, то екран не буде автоматично змінюватися при зміні значень у цьому об'єкті.",[1046,1047,1048],"Observable поля","BaseObservable","Двосторонній біндинг","  Android Data Binding. Observable поля. Двосторонній біндинг.  Коли ми використовуємо біндинг для звичайного Java-об'єкта, то екран не буде автоматично змінюватися при зміні значень у цьому об'єкті.  Тобто ви передаєте об'єкт   Employee  у біндинг, а потім можете скільки завгодно змінювати в ньому поля і нічого на екрані змінюватися не буде. Вам треба буде знову руками передати змінений об'єкт у біндинг або викликати у біндингу метод   invalidateAll , тоді екран відобразить актуальні дані.  У першому уроці з Data Binding я згадував, що є можливість зробити так, щоб біндинг сам моніторив значення полів і оновлював екран, щойно відбулися якісь зміни. Для цього треба використовувати механізми   Observable .  Observable поля  Зробимо кілька   Observable  полів у класі   Employee :     public   class   Employee   {\n   \n      public   Employee  (  long   id  ,   String   name  ,   String   address  ,   int   salary  ) {\n          this  .id   =   id;\n          this  .name.  set  (name);\n          this  .address   =   address;\n          this  .salary.  set  (salary);\n      }\n   \n      public   long   id;\n   \n      public   ObservableField  \u003C  String  > name   =   new   ObservableField  \u003C>();\n   \n      public   String   address;\n   \n      public   ObservableInt   salary   =   new   ObservableInt  ();\n   \n   }\n  Для Java примітивів є готові   Observable  поля:   ObservableInt ,   ObservableFloat  тощо. Для решти використовуємо   ObservableField  із зазначенням типу. Щоб присвоїти такому полю значення, використовуємо метод   set .  Поля   name  і   salary  робимо   Observable . Їх ми будемо використовувати в біндингу.   layout  файл має звичайний вигляд, у ньому нічого змінювати не треба:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  layout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"  >\n   \n      \u003C  data  >\n          \u003C  variable\n              name  =  \"employee\"\n              type  =  \"ru.startandroid.application.data.Employee\"  />\n      \u003C/  data  >\n   \n      \u003C  LinearLayout\n          android:layout_width  =  \"match_parent\"\n          android:layout_height  =  \"match_parent\"\n          android:orientation  =  \"vertical\"  >\n   \n          \u003C  TextView\n              android:layout_width  =  \"wrap_content\"\n              android:layout_height  =  \"wrap_content\"\n              android:text  =  \"@{employee.name}\"   />\n   \n          \u003C  TextView\n              android:layout_width  =  \"wrap_content\"\n              android:layout_height  =  \"wrap_content\"\n              android:text  =  \"@{String.valueOf(employee.salary)}\"  />\n      \u003C/  LinearLayout  >\n   \n   \u003C/  layout  >\n  Тепер, передавши в біндинг об'єкт   Employee , ви зможете змінювати значення його полів:     employee.name.  set  (  \"Mark\"  );\n   employee.salary.  set  (  20000  );\n  А біндінг сам відстежить ці зміни і оновить екран.  Для колекцій є класи   ObservableArrayMap  і   ObservableArrayList .  Біндинг працюватиме, навіть якщо передавати значення в   Observable  поля не в UI потоці.  Розглянемо ще один можливий сценарій використання   ObservableField . Його можна використовувати не тільки з окремими полями об'єкта, а й з цілим об'єктом.  Є клас   Employee :     public   class   Employee   {\n   \n      public   Employee  (  long   id  ,   String   name  ,   String   address  ,   int   salary  ) {\n          this  .id   =   id;\n          this  .name   =   name;\n          this  .address   =   address;\n          this  .salary   =   salary;\n      }\n   \n      public   long   id;\n   \n      public   String   name;\n   \n      public   String   address;\n   \n      public   int   salary;\n   \n   }\n  Цілком може бути ситуація, коли нам у   ViewModel  (або в презентер) періодично «прилітає» з репозиторію новий об'єкт   Employee  і його треба відобразити в   View .  У цьому разі в   ViewModel  створюємо поле   ObservableField\u003CEmployee> :     public   class   ViewModel   {\n   \n      public   ObservableField  \u003C  Employee  > employee   =   new   ObservableField  \u003C>();\n   \n      ...\n   }\n  У це поле методом   employee.set()  репозиторій поміщатиме новий   Employee .  У   layout  як змінну використовуємо   ViewModel .     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  layout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"  >\n   \n      \u003C  data  >\n          \u003C  variable\n              name  =  \"model\"\n              type  =  \"ru.startandroid.application.data.ViewModel\"  />\n      \u003C/  data  >\n   \n      \u003C  LinearLayout\n          android:layout_width  =  \"match_parent\"\n          android:layout_height  =  \"match_parent\"\n          android:orientation  =  \"vertical\"  >\n   \n          \u003C  TextView\n              android:layout_width  =  \"wrap_content\"\n              android:layout_height  =  \"wrap_content\"\n              android:text  =  \"@{model.employee.name}\"   />\n   \n          \u003C  TextView\n              android:layout_width  =  \"wrap_content\"\n              android:layout_height  =  \"wrap_content\"\n              android:text  =  \"@{model.employee.address}\"  />\n      \u003C/  LinearLayout  >\n   \n   \u003C/  layout  >\n  Дістаємо з   model  об'єкт   employee  і використовуємо його поля в біндингу.  Тепер під час оновлення значення в   ObservableField\u003CEmployee>  будуть змінені й поля в   View  без будь-яких додаткових дій з нашого боку.  BaseObservable  Є ще один спосіб увімкнути автобіндинг для Java-об'єкта.  Робиться це наслідуванням   BaseObservable :     public   class   Employee   extends   BaseObservable   {\n   \n      private   long   id;\n      private   String   name   =   \"\"  ;\n      private   int   salary   =   0  ;\n   \n      public   Employee  (  long   id  ,   String   name  ,   int   salary  ) {\n          this  .id   =   id;\n          setName  (name);\n          setSalary  (salary);\n      }\n   \n      @  Bindable\n      public   String   getName  () {\n          return   name;\n      }\n   \n      public   void   setName  (  String   name  ) {\n          this  .name   =   name;\n          notifyPropertyChanged  (BR.name);\n      }\n   \n      @  Bindable\n      public   int   getSalary  () {\n          return   salary;\n      }\n   \n      public   void   setSalary  (  int   salary  ) {\n          this  .salary   =   salary;\n          notifyPropertyChanged  (BR.salary);\n      }\n   }\n  Поле   id  я залишив звичайним. А поля   name  і   salary  будуть відстежуватися біндингом. Для цього треба позначити   get -методи анотацією   @Bindable , а в   set -методах викликати   notifyPropertyChanged  метод, який і буде повідомляти біндинг про зміни значення поля.  У layout все буде як зазвичай.  Двосторонній біндинг  Біндинг може працювати в обидва боки. Тобто він буде не тільки передавати дані в   View , а й отримувати їх звідти.  Розглянемо на прикладі пари полів у   Employee :     public   class   Employee   {\n   \n      public   String   name   =   \"\"  ;\n      public   boolean   enabled   =   true  ;\n   \n   }\n  Поле   name  і статус   enabled . Налаштуємо біндинг цих полів в   EditText  і   CheckBox .  При цьому зробимо так, щоб біндинг працював в обидва боки. Для цього треба в рядку біндингу додати символ   =  між   @  і   {...}     \u003C  EditText\n      android  :  layout_width  =  \"wrap_content\"\n      android  :  layout_height  =  \"wrap_content\"\n      android  :  text  =  \"@={employee.name}\"  />\n   \n   \u003C  CheckBox\n      android  :  text  =  \"enabled\"\n      android  :  layout_width  =  \"wrap_content\"\n      android  :  layout_height  =  \"wrap_content\"\n      android  :  checked  =  \"@={employee.enabled}\"  />\n  Тепер при зміні тексту в   EditText , біндинг передаватиме нове значення в   employee.name . А під час увімкнення\\вимкнення чекбокса, біндинг передаватиме поточний стан цього чекбокса в поле   employee.enabled .  Тобто зміни вмісту   View  будуть відображені в   Employee  об'єкті, який ми передавали в біндинг. Якщо необхідно, можна використовувати і   Observable  поля. З ними це теж буде працювати.  До речі, якщо після передачі в біндинг ви ніде не зберігаєте у себе об'єкт   employee , то ви завжди можете отримати його назад методом   binding.getEmployee() .  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1051,"path":1052,"dir":984,"title":1053,"description":1054,"keywords":1055,"body":1064},"content:1.android:8.lesson8:8.livedata.md","/android/lesson8/livedata","LiveData","документація",[1056,1057,1058,1059,1060,1061,1062,1063],"Отримання даних із LiveData","Нюанси поведінки","Надсилання даних у LiveData","Transformations","Свій LiveData","MediatorLiveData","RxJava","Інші методи LiveData","  LiveData   документація  У   build.gradle  файл проекту додайте репозитарій   google()     allprojects   {\n       repositories   {\n           jcenter  ()\n           google  ()\n       }\n       ..  .\n   }\n  У   build.gradle  файлі модуля додайте   dependencies :     dependencies {\n       implementation   \"android.arch.lifecycle:extensions:1.0.0\"\n       annotationProcessor   \"android.arch.lifecycle:compiler:1.0.0\"\n       ...\n   }\n   LiveData  - сховище даних, що працює за принципом патерну   Observer  (спостерігач). Це сховище вміє робити дві речі:   У нього можна помістити будь-який об'єкт  На нього можна підписатися й отримувати об'єкти, які в нього поміщають.  Тобто з одного боку, хтось поміщає об'єкт у сховище, а з іншого боку, хтось підписується і отримує цей об'єкт.  Як аналогію можна навести, наприклад, канали в Telegram. Автор пише пост і відправляє його в канал, а всі підписники отримують цей пост.  Здавалося б, нічого особливого в такому сховищі немає, але є один дуже важливий нюанс.   LiveData  вміє визначати активний підписник чи ні, і   надсилати дані буде тільки активним передплатникам . Передбачається, що підписники   LiveData  будуть   Activity  і   фрагменти . А їхній стан активності визначатиметься за допомогою їхнього   Lifecycle  об'єкта, який ми уже розглядали.  Отримання даних із LiveData  Нехай у нас є якийсь синглтон клас   DataController , з якого можна отримати   LiveData\u003CString> .     LiveData  \u003C  String  > liveData   =   DataController.  getInstance  ().  getData  ();\n   DataController  періодично щось там усередині себе робить і оновлює дані в   LiveData . Як він це робить, ми подивимося трохи пізніше. Спочатку подивимося, як   Activity  може підписатися на   LiveData  і отримувати дані, які поміщає в нього   DataController .     @  Override\n   protected   void   onCreate  (  Bundle   savedInstanceState) {\n      super  .  onCreate  (savedInstanceState);\n      setContentView  (R.layout.activity_main);\n       \n      LiveData  \u003C  String  > liveData   =   DataController.  getInstance  ().  getData  ();\n    \n      liveData.  observe  (  this  ,   new   Observer  \u003C  String  >() {\n          @  Override\n          public   void   onChanged  (@  Nullable   String   value  ) {\n              textView.  setText  (value)\n          }\n      });\n   }\n  Отримуємо   LiveData  з   DataController , і методом   observe  підписуємося. У метод   observe  нам необхідно передати два параметри:  Перший - це   LifecycleOwner . Нагадаю, що   LifecycleOwner  - це інтерфейс із методом   getLifecycle .   Activity  і фрагменти в Support Library, починаючи з версії 26.1.0 реалізують цей інтерфейс, тому ми передаємо   this .   LiveData  отримає з   Activity  його   Lifecycle  і за ним визначатиме стан   Activity . Активним вважається стан   STARTED  або   RESUMED . Тобто якщо   Activity  видно на екрані, то   LiveData  вважає його активним і буде відправляти дані в його колбек.  Другий параметр - це безпосередньо підписник, тобто колбек, у який   LiveData  відправлятиме дані. У ньому тільки один метод   onChanged . У нашому прикладі туди буде приходити   String .  Тепер, коли   DataController  помістить будь-який   String -об'єкт у   LiveData , ми одразу отримаємо цей об'єкт в   Activity , якщо   Activity  перебуває в стані   STARTED  або   RESUMED .  Нюанси поведінки  Розпишу відразу кілька важливих моментів у поведінці   LiveData .   Якщо   Activity  було неактивним під час оновлення даних у   LiveData , то при поверненні в активний стан, його   observer  отримає останнє актуальне значення даних.  У момент підписки,   observer  отримає останнє актуальне значення з   LiveData .  Якщо   Activity  буде закрито, тобто перейде в статус   DESTROYED , то   LiveData  автоматично відпише від себе його   observer .  Якщо   Activity  у стані   DESTROYED  спробує підписатися, то підписку не буде виконано.  Якщо   Activity  вже підписувало свій   observer , і спробує зробити це ще раз, то просто нічого не станеться.  Ви завжди можете отримати останнє значення   LiveData  за допомогою його методу   getValue .  Як бачите, підписувати   Activity  на   LiveData  - це зручно. Поворот екрана і повне закриття   Activity  - все це коректно і зручно обробляється автоматично без будь-яких зусиль з нашого боку.  Надсилання даних у LiveData  Ми розібралися, як отримувати дані з   LiveData , і яким чином при цьому враховується стан   Activity . Тепер давайте подивимося з іншого боку - як передавати дані в   LiveData .  У класі   DataController  змінна   LiveData  матиме такий вигляд:     private   MutableLiveData  \u003C  String  > liveData   =   new   MutableLiveData  \u003C>();\n    \n   LiveData  \u003C  String  >   getData  () {\n      return   liveData;\n   }\n  Назовні ми передаємо   LiveData , який дозволить зовнішнім об'єктам тільки отримувати дані. Але всередині   DataController  ми використовуємо об'єкт   MutableLiveData , який дозволяє поміщати в нього дані.  Щоб помістити значення в   MutableLiveData , використовується метод   setValue :     liveData.  setValue  (  \"new value\"  );\n  Цей метод оновить значення   LiveData , і всі його активні підписники отримають це оновлення.  Метод   setValue  має бути викликаний з UI потоку. Для оновлення даних з інших потоків використовуйте метод   postValue . Він перенаправить виклик в UI потік. Відповідно, передплатники завжди отримуватимуть значення в основному потоці.  Transformations  Ви можете поміняти типи даних у   LiveData  за допомогою   Transformations.map  (  документація ).  Розглянемо приклад, у якому   LiveData\u003CString>  будемо перетворювати на   LiveData\u003CInteger> :     LiveData  \u003C  String  > liveData   =   ...;\n    \n   LiveData  \u003C  Integer  > liveDataInt   =   Transformations.  map  (liveData,   new   Function  \u003C  String  ,   Integer  >() {\n      @  Override\n      public   Integer   apply  (  String   input  ) {\n          return   Integer.  parseInt  (input);\n      }\n   });\n  У метод   map  передаємо наявний   LiveData\u003CString>  і функцію перетворення. У цій функції ми будемо отримувати   String  дані з   LiveData\u003CString> , і від нас вимагається перетворити їх в   Integer . У цьому випадку просто парсимо рядок у число.  На виході методу map отримаємо   LiveData\u003CInteger> . Можна сказати, що він підписаний на   LiveData\u003CString>  і всі отримані String-значення конвертуватиме в   Integer  і розсилатиме вже своїм підписникам.  Розглянемо складніший випадок. У нас є   LiveData\u003CLong> , нам необхідно з нього отримати   LiveData\u003CUser> . Конвертація   id  в   User  виглядає так:     private   LiveData  \u003C  User  >   getUser  (  long   id) {\n      // ...\n   }\n  За   id  ми отримуємо   LiveData\u003CUser>  і на нього треба буде підписуватися, щоб отримати об'єкт   User .  У цьому разі ми не можемо використовувати метод   map , тому що ми отримаємо приблизно такий результат:     LiveData  \u003C  Long  > liveDataId   =   ...;\n    \n   LiveData  \u003C  LiveData  \u003C  User  >> liveDataUser   =   Transformations.  map  (liveDataId,   new   Function  \u003C  Long  ,   LiveData  \u003C  User  >>() {\n      @  Override\n      public   LiveData  \u003C  User  >   apply  (  Long   id  ) {\n          return   getUser  (id);\n      }\n   });\n  На виході буде об'єкт   LiveData\u003CLiveData\u003CUser>> . Щоб уникнути цього, використовуємо   switchMap  замість   map .     LiveData  \u003C  Long  > liveDataId   =   ...;\n    \n   LiveData  \u003C  User  > liveDataUser   =   Transformations.  switchMap  (liveDataId,   new   Function  \u003C  Long  ,   LiveData  \u003C  User  >>() {\n      @  Override\n      public   LiveData  \u003C  User  >   apply  (  Long   id  ) {\n          return   getUser  (id);\n      }\n   });\n   switchMap  прибере вкладеність   LiveData  і ми отримаємо   LiveData\u003CUser> .  Свій LiveData  У деяких ситуаціях зручно створити свою обгортку   LiveData .  Розглянемо приклад:     public   class   LocationLiveData   extends   LiveData  \u003C  Location  > {\n    \n      LocationService  .  LocationListener   locationListener   =   new   LocationService.  LocationListener  () {\n          @  Override\n          public   void   onLocationChanged  (  Location   location) {\n              setValue  (location);\n          }\n      };\n    \n      @  Override\n      protected   void   onActive  () {\n          LocationService.  addListener  (locationListener);\n      }\n    \n      @  Override\n      protected   void   onInactive  () {\n          LocationService.  removeListener  (locationListener);\n      }\n    \n   }\n  Клас   LocationLiveData  розширює   LiveData\u003CLocation> .  Усередині нього є якийсь   locationListener  - слухач, який можна передати в   LocationService  і отримувати оновлення поточного місця розташування. При отриманні нового   Location  від   LocationService ,   locationListener  буде викликати метод   setValue  і тим самим оновлювати дані цього   LiveData .   LocationService  - це просто якийсь сервіс, який надає нам поточну локацію. Його реалізація в цьому прикладі не важлива. Головне - це те, що ми підписуємося (  addListener ) на сервіс, коли нам потрібні дані, і відписуємося (  removeListener ), коли дані більше не потрібні.  Зверніть увагу, що ми перевизначили методи   onActive  і   onInactive .   onActive  буде викликаний, коли у   LiveData  з'явиться хоча б один підписник. А   onInactive  - коли не залишиться жодного підписника. Відповідно ці методи зручно використовувати для підключення/відключення нашого слухача до   LocationService .  Вийшла зручна обгортка, яка за появи підписників сама підписуватиметься до   LocationService , отримуватиме   Location  і передаватиме його своїм підписникам. А коли підписників не залишиться, то   LocationLiveData  відпишеться від   LocationService .  Залишилося зробити з   LocationLiveData  синглтон і можна використовувати його в різних   Activity  і фрагментах.  MediatorLiveData   MediatorLiveData  дає можливість збирати дані з декількох   LiveData  в один. Це зручно, якщо у вас є кілька джерел, з яких ви хочете отримувати дані. Ви об'єднуєте їх в одне і підписуєтеся тільки на нього.  Розглянемо, як це робиться, на простому прикладі.     MutableLiveData  \u003C  String  > liveData1   =   new   MutableLiveData  \u003C>();\n   MutableLiveData  \u003C  String  > liveData2   =   new   MutableLiveData  \u003C>();\n    \n   MediatorLiveData  \u003C  String  > mediatorLiveData   =   new   MediatorLiveData  \u003C>();\n  У нас є два   LiveData\u003CString> :   liveData1  і   liveData2 . Ми хочемо об'єднати їх в один. Для цього нам знадобиться   MediatorLiveData .  Додаємо   LiveData  до   MediatorLiveData     mediatorLiveData.  addSource  (liveData1,   new   Observer  \u003C  String  >() {\n      @  Override\n      public   void   onChanged  (@  Nullable   String   s  ) {\n          mediatorLiveData.  setValue  (s);\n      }\n   });\n    \n    \n   mediatorLiveData.  addSource  (liveData2,   new   Observer  \u003C  String  >() {\n      @  Override\n      public   void   onChanged  (@  Nullable   String   s  ) {\n          mediatorLiveData.  setValue  (s);\n    \n      }\n   });\n  Метод   addSource  вимагає від нас два параметри.  Перший - це   LiveData , з якого   MediatorLiveData  збирається отримувати дані.  Другий параметр - це колбек, який буде використаний для підписки на   LiveData  з першого параметра. Зверніть увагу, що в колбеку нам треба самим передавати в   MediatorLiveData  дані, одержувані з   LiveData . Це робиться методом   setValue .  Таким чином   mediatorLiveData  буде отримувати дані з двох   LiveData  і постити їх своїм одержувачам.  Підпишемося на   mediatorLiveData     mediatorLiveData.  observe  (  this  ,   new   Observer  \u003C  String  >() {\n      @  Override\n      public   void   onChanged  (@  Nullable   String   s  ) {\n          log  (  \"onChanged \"   +   s);\n      }\n   });\n  Сюди тепер мають приходити дані з   liveData1  і   liveData2 . Будемо їх просто логувати.  Відправимо дані в   liveData1  і   liveData2 :     liveData1.  setValue  (  \"1\"  );\n   liveData2.  setValue  (  \"a\"  );\n   liveData1.  setValue  (  \"2\"  );\n   liveData2.  setValue  (  \"b\"  );\n   liveData1.  setValue  (  \"3\"  );\n   liveData2.  setValue  (  \"c\"  );\n  Дивимося лог:     onChanged   1\n   onChanged   a\n   onChanged   2\n   onChanged   b\n   onChanged   3\n   onChanged   c\n  Усі дані, що ми передавали в   liveData1  і   liveData2 , надійшли в загальний   mediatorLiveData .  Трохи ускладнимо приклад. Припустимо, нам треба відписатися від   liveData2 , коли з нього прийде значення   \"finish\" .  Код підписки   mediatorLiveData  на   liveData1  і   liveData2  матиме такий вигляд:     mediatorLiveData.  addSource  (liveData1,   new   Observer  \u003C  String  >() {\n      @  Override\n      public   void   onChanged  (@  Nullable   String   s  ) {\n          mediatorLiveData.  setValue  (s);\n      }\n   });\n    \n    \n   mediatorLiveData.  addSource  (liveData2,   new   Observer  \u003C  String  >() {\n      @  Override\n      public   void   onChanged  (@  Nullable   String   s  ) {\n          if   (  \"finish\"  .  equalsIgnoreCase  (s)) {\n              mediatorLiveData.  removeSource  (liveData2);\n              return  ;\n          }\n          mediatorLiveData.  setValue  (s);\n    \n      }\n   });\n  У випадку з   liveData1  нічого не змінюється.  А ось при отриманні даних від   liveData2  ми дивимося, що за значення прийшло. Якщо це значення \"finish\", то методом   removeSource  відписуємо   mediatorLiveData  від   liveData2  і не передаємо це значення далі.  Відправимо кілька значень     liveData1.  setValue  (  \"1\"  );\n   liveData2.  setValue  (  \"a\"  );\n   liveData2.  setValue  (  \"finish\"  );\n   liveData1.  setValue  (  \"2\"  );\n   liveData2.  setValue  (  \"b\"  );\n   liveData1.  setValue  (  \"3\"  );\n   liveData2.  setValue  (  \"c\"  );\n   liveData2  відправляє тут значення   \"a\" ,   \"finish\" ,   \"b\"  і   \"c\" . Через   mediatorLiveData  має пройти тільки   \"a\" . А значення з   liveData1  мають пройти всі.  Запускаємо, дивимося лог:     onChanged   1\n   onChanged   a\n   onChanged   2\n   onChanged   3\n  Усе правильно. Під час отримання   \"finish\"  від   liveData2 ,   mediatorLiveData  відписався від нього, і наступні його дані ми вже не отримували.  RxJava  Ми можемо конвертувати   LiveData  в   Rx  і навпаки. Для цього є інструмент    LiveDataReactiveStreams .  Щоб його використовувати додайте в   dependencies :     implementation   \"android.arch.lifecycle:reactivestreams:1.0.0\"\n  Щоб отримати   LiveData  з   Flowable  або   Observable , використовуємо метод   fromPublisher :     Flowable  \u003C  String  > flowable   =   ... ;\n   LiveData  \u003C  String  > liveData   =   LiveDataReactiveStreams.  fromPublisher  (flowable);\n   LiveData  буде підписаний на   Flowable , поки у нього (у   LiveData ) є передплатники.   LiveData  не зможе обробити або отримати onError від   Flowable . Якщо у   Flowable  виникне помилка, то буде креш.  Неважливо, в якому потоці працює   Flowable , результат у   LiveData  завжди прийде в UI потоці.  Щоб отримати   Flowable  або   Observable  з   LiveData  потрібно виконати два перетворення. Спочатку використовуємо метод   toPublisher , щоб отримати   Publisher . Потім отриманий   Publisher  передаємо в метод   Flowable.fromPublisher :     LiveData  \u003C  String  > liveData   =   … ;\n   Flowable  \u003C  String  > flowable   =   Flowable.  fromPublisher  (\n           LiveDataReactiveStreams.  toPublisher  (  this  , liveData));\n  Інші методи LiveData      hasActiveObservers  ()  - перевірка наявності активних підписників     hasObservers  ()  - перевірка наявності будь-яких підписників     observeForever  (  Observer  \u003C  T  >   observer)  - дозволяє підписатися без урахування Lifecycle. Тобто цей передплатник буде завжди вважатися активним.     removeObserver  (  Observer  \u003C  T  >   observer)  - дає змогу відписати підписника     removeObservers  (  LifecycleOwner   owner)  - дає змогу відписати всіх підписників, які зав'язані на   Lifecycle  від зазначеного   LifecycleOwner .  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1066,"path":1067,"dir":984,"title":1068,"description":1069,"keywords":1070,"body":1076},"content:1.android:8.lesson8:9.viewmodel.md","/android/lesson8/viewmodel","ViewModel","У цьому уроці розглянемо, як використовувати ViewModel. Як зберігати дані при повороті екрана. Як передати Context у ViewModel. Як передати свої дані в конструктор моделі за допомогою фабрики. Як передати дані між фрагментами. Що використовувати: ViewModel або onSavedInstanceState.",[1053,1071,1072,1073,1074,1075,1062],"Очищення ресурсів","Context","Передача об'єктів у конструктор моделі","Передача даних між фрагментами","onSavedInstanceState","  ViewModel  У цьому уроці розглянемо, як використовувати   ViewModel . Як зберігати дані при повороті екрана. Як передати Context у   ViewModel . Як передати свої дані в конструктор моделі за допомогою фабрики. Як передати дані між фрагментами. Що використовувати:   ViewModel  або   onSavedInstanceState .   ViewModel  - клас, що дає змогу   Activity  і   фрагментам  зберігати необхідні їм об'єкти живими під час повороту екрана.  Створюємо свій клас, що успадковує   ViewModel     public   class   MyViewModel   extends   ViewModel   {\n    \n   }\n  Поки що залишимо його порожнім.  Щоб дістатися до нього в   Activity , потрібен такий код:     @  Override\n   protected   void   onCreate  (  Bundle   savedInstanceState) {\n      super  .  onCreate  (savedInstanceState);\n      setContentView  (R.layout.activity_main);\n    \n      MyViewModel   model   =   ViewModelProviders.  of  (  this  ).  get  (MyViewModel.class);\n    \n      // ...\n   }\n  У метод   ViewModelProviders.of  передаємо   Activity . Тим самим ми отримаємо доступ до провайдера, який зберігає всі   ViewModel  для цього   Activity .  Методом   get  запитуємо у цього провайдера конкретну модель за ім'ям класу -   MyViewModel . Якщо провайдер ще не створював такий об'єкт раніше, то він його створює і повертає нам. І поки   Activity  остаточно не буде закрито, під час усіх наступних викликів методу   get  ми отримуватимемо цей самий об'єкт   MyViewModel .  Відповідно, під час поворотів екрана   Activity  буде перестворюватися, а об'єкт   MyViewModel  буде спокійно собі жити в провайдері. І   Activity  після перестворення зможе отримати цей об'єкт назад і продовжити роботу, ніби нічого не сталося.  Звідси випливає важливий висновок. Не зберігайте в   ViewModel  посилання на   Activity , фрагменти,   View  тощо. Це може призвести до витоків пам'яті.  На зображенні час життя (він же   scope ) моделі це має такий вигляд:\n  \nМодель жива, поки   Activity  не закриється остаточно.  У методу   get , який повертає нам модель із провайдера, є ще такий варіант виклику:     T   get   (  String   key,   Class  \u003C  T  >   modelClass)\n  Тобто ви можете створювати кілька моделей одного й того самого класу, але використовувати різні текстові ключі для їхнього зберігання в провайдері.  LiveData   LiveData  дуже зручно використовувати з   ViewModel . У минулих уроках я для роботи з LiveData використовував синглтон, але тепер ми перейдемо на   ViewModel .  Розглянемо нескладний приклад асинхронного одноразового завантаження будь-яких даних:     public   class   MyViewModel   extends   ViewModel   {\n    \n      // ...\n    \n      MutableLiveData  \u003C  String  > data;\n    \n      public   LiveData  \u003C  String  >   getData  () {\n          if   (data   ==   null  ) {\n              data   =   new   MutableLiveData  \u003C>();\n              loadData  ();\n          }\n          return   data;\n      }\n    \n      private   void   loadData  () {\n          dataRepository.  loadData  (  new   Callback  \u003C  String  >() {\n              @  Override\n              public   void   onLoad  (  String   s  ) {\n                  data.  postValue  (s);\n              }\n          });\n      }\n    \n   }\n  Основний метод тут - це   getData . Коли   Activity  захоче отримати дані, воно викличе саме цей метод. Ми перевіряємо, чи створено вже   MutableLiveData . Якщо ні, значить цей метод викликається вперше. У цьому випадку створюємо   MutableLiveData  і стартуємо асинхронний процес отримання даних методом   loadData . Далі повертаємо   LiveData .  У методі   loadData  відбувається асинхронне отримання даних з якогось репозиторію. Щойно дані будуть отримані (у методі   onLoad ), ми передаємо їх у   MutableLiveData .  Метод   loadData  має бути асинхронним, тому що він викликається з методу   getData , а   getData , своєю чергою, викликається з   Activity  і все це відбувається в UI потоці. Якщо   loadData  почне завантажувати дані синхронно, то він заблокує UI потік.  Код в   Activity  має такий вигляд:     @  Override\n   protected   void   onCreate  (  Bundle   savedInstanceState) {\n      super  .  onCreate  (savedInstanceState);\n      setContentView  (R.layout.activity_main);\n    \n      MyViewModel   model   =   ViewModelProviders.  of  (  this  ).  get  (MyViewModel.class);\n      LiveData  \u003C  String  > data   =   model.  getData  ();\n      data.  observe  (  this  ,   new   Observer  \u003C  String  >() {\n          @  Override\n          public   void   onChanged  (@  Nullable   String   s  ) {\n              // ...\n          }\n      });\n   }\n  Отримуємо від провайдера модель. Від моделі отримуємо   LiveData , на який підписуємося і чекаємо на дані.  У цьому прикладі   ViewModel  потрібен, щоб зберегти процес отримання даних під час повороту екрана. А   LiveData  - для зручного асинхронного отримання даних.  Тобто це матиме такий вигляд:    Activity  викликає метод моделі   getData  модель створює   MutableLiveData  і стартує асинхронний процес отримання даних від репозиторію   Activity  підписується на отриманий від моделі   LiveData  і чекає на дані  відбувається поворот екрана  на моделі цей поворот жодним чином не позначається, вона спокійно сидить у провайдері та чекає на відповідь від репозиторію   Activity  перестворюється, отримує ту саму модель від провайдера, отримує той самий   LiveData  від моделі, підписується на нього і чекає на дані  репозиторій повертає дані, модель передає їх у   MutableLiveData   Activity  отримує дані дані від   LiveData  Якщо репозиторій раптом надішле відповідь у той момент, коли   Activity  буде перестворюватися, то   Activity  отримає цю відповідь, щойно підпишеться на   LiveData .  Якщо ваш репозиторій сам вміє повертати   LiveData , то все значно спрощується. Ви просто віддаєте цей   LiveData  в   Activity  і воно підписується.     public   class   MyViewModel   extends   ViewModel   {\n    \n       // ...\n    \n       LiveData  \u003C  String  > data;\n    \n       public   LiveData  \u003C  String  >   getData  () {\n           if   (data   ==   null  ) {\n               data   =   dataRepository.  loadData  ();\n           }\n           return   data;\n       }\n   }\n  Очищення ресурсів  Коли   Activity  остаточно закривається, провайдер видаляє   ViewModel , попередньо викликавши його метод   onCleared     public   class   MyViewModel   extends   ViewModel   {\n    \n      // ...\n      \n      @  Override\n      protected   void   onCleared  () {\n          // clean up resources\n    \n      }\n   }\n  У цьому методі ви зможете виконати всі необхідні операції зі звільнення ресурсів, закриття з'єднань/потоків тощо.  Context  Не варто передавати   Activity  у модель як   Context . Це може призвести до витоків пам'яті.  Якщо вам у моделі знадобився об'єкт   Context , то ви можете успадковувати не   ViewModel , а   AndroidViewModel .     public   class   MyViewModel   extends   AndroidViewModel   {\n    \n      public   MyViewModel  (@  NonNull   Application   application  ) {\n          super  (application);\n      }\n    \n      public   void   doSomething  () {\n          Context   context   =   getApplication  ();\n          // ....\n      }\n    \n   }\n  Під час створення цієї моделі провайдер передасть їй у конструктор клас   Application , який є   Context . Ви зможете до нього дістатися методом   getApplication .  Код отримання цієї моделі в   Activity  залишиться тим самим.  Передача об'єктів у конструктор моделі  Буває необхідність передати моделі будь-які дані під час створення. Модель створюється провайдером і у нас є можливість втрутитися в цей процес. Для цього використовується фабрика. Ми вчимо цю фабрику створювати модель так, як нам потрібно. І провайдер скористається цією фабрикою, коли йому знадобиться створити об'єкт.  Розглянемо приклад. У нас є така модель     public   class   MyViewModel   extends   ViewModel   {\n    \n      private   final   long   id;\n    \n      public   MyViewModel  (  long   id  ) {\n          this  .id   =   id;\n      }\n    \n      // ...\n    \n   }\n  Їй потрібен   long  при створенні.  Створюємо фабрику     public   class   ModelFactory   extends   ViewModelProvider.NewInstanceFactory   {\n    \n      private   final   long   id;\n    \n      public   ModelFactory  (  long   id  ) {\n          super  ();\n          this  .id   =   id;\n      }\n    \n      @  NonNull\n      @  Override\n      public   \u003C  T   extends   ViewModel  >   T   create  (@  NonNull   Class  \u003C  T  >   modelClass  ) {\n          if   (modelClass   ==   MyViewModel.class) {\n              return   (T)   new   MyViewModel  (id);\n          }\n          return   null  ;\n      }\n   }\n  Вона має успадковувати клас   ViewModelProvider.NewInstanceFactory .  У конструктор передаємо   long , який нам необхідно буде передати в модель.  У методі   create  фабрика отримає від провайдера на вхід клас моделі, яку необхідно створити. Перевіряємо, що це клас   MyViewModel , самі створюємо модель і передаємо туди   long .  В   Activity  код отримання моделі матиме такий вигляд:     long   id   =   ...;\n    \n   MyViewModel   model   =   ViewModelProviders.  of  (  this  ,   new   ModelFactory  (id))\n          .  get  (MyViewModel.class);\n  Ми створюємо нову фабрику з потрібними нам даними і передаємо її в метод   of . Під час виклику методу   get  провайдер використає фабрику для створення моделі, тобто виконається наш код створення моделі та передавання в неї даних.  Передача даних між фрагментами   ViewModel  може бути використана для передачі даних між фрагментами, які знаходяться в одному   Activity . У документації є чудовий приклад коду:     public   class   SharedViewModel   extends   ViewModel   {\n       private   final   MutableLiveData  \u003C  Item  > selected   =   new   MutableLiveData  \u003C  Item  >();\n    \n       public   void   select  (  Item   item  ) {\n           selected.  setValue  (item);\n       }\n    \n       public   LiveData  \u003C  Item  >   getSelected  () {\n           return   selected;\n       }\n   }\n   SharedViewModel  - модель із двома методами: один дає змогу помістити дані в   LiveData , інший - дає змогу отримати цей   LiveData . Відповідно, якщо два фрагменти матимуть доступ до цієї моделі, то один зможе поміщати дані в його   LiveData , а інший - підпишеться і отримуватиме ці дані. Таким чином два фрагменти будуть обмінюватися даними нічого не знаючи один про одного.  Щоб два фрагменти могли працювати з однією і тією ж моделлю, вони можуть використовувати спільне   Activity . Код отримання моделі у фрагментах виглядає так:     SharedViewModel   model   =   ViewModelProviders.  of  (  getActivity  ()).  get  (SharedViewModel.class);\n  Для обох фрагментів   getActivity  поверне один і той самий   Activity . Метод   ViewModelProviders.of  поверне провайдера цього   Activity . Далі методом get отримуємо модель.  Код фрагментів:     public   class   MasterFragment   extends   Fragment   {\n       private   SharedViewModel   model;\n       public   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           model   =   ViewModelProviders.  of  (  getActivity  ()).  get  (SharedViewModel.class);\n           itemSelector.  setOnClickListener  (item   ->   {\n               model.  select  (item);\n           });\n       }\n   }\n    \n   public   class   DetailFragment   extends   Fragment   {\n       public   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           SharedViewModel   model   =   ViewModelProviders.  of  (  getActivity  ()).  get  (SharedViewModel.class);\n           model.  getSelected  ().  observe  (  this  , { item   ->\n              // Update the UI.\n           });\n       }\n   }\n  Фрагмент   MasterFragment  поміщає дані в   LiveData . А   DetailFragment  - підписується і отримує дані.  onSavedInstanceState  Чим   ViewModel  відрізняється від   onSavedInstanceState . Для яких даних який із них краще використовувати. Здається, що якщо є   ViewModel , який живий весь час, поки не закрито   Activity , то можна забути про   onSavedInstanceState . Але це не так.  Давайте як приклад розглянемо   Activity , яке відображає список якихось даних і може виконувати пошук за ними. Користувач відкриває   Activity  і виконує пошук.   Activity  відображає результати цього пошуку. Користувач згортає додаток. Коли він його знову відкриє, він очікує, що там усе залишиться в цьому ж стані.  Але тут раптово системі не вистачає пам'яті і вона вбиває цей згорнутий додаток. Коли користувач знову запустить його,   Activity  нічого не знатиме про пошук, і просто покаже всі дані. У цьому випадку   ViewModel  нам ніяк не допоможе, тому що модель буде вбита разом із застосунком. А ось   onSavedInstanceState  буде виконано. У ньому ми зможемо зберегти пошуковий запит, і під час подальшого запуску отримати його з об'єкта   savedInstanceState  і виконати пошук. У результаті користувач побачить той самий екран, який був, коли додаток було згорнуто.  Отже.    ViewModel  - тут зручно тримати всі дані, які потрібні вам для формування екрана. Вони житимуть під час поворотів екрана, але помруть, коли застосунок буде вбито системою.   onSavedInstanceState  - тут потрібно зберігати той мінімум даних, який знадобиться вам для відновлення стану екрана і даних у ViewModel після екстреного закриття Activity системою. Це може бути пошуковий запит, ID тощо.  Відповідно, коли ви дістаєте дані з   savedInstanceState  і пропонуєте їх моделі, це може бути у двох випадках:   Був звичайний поворот екрана. У цьому разі ваша модель має зрозуміти, що їй ці дані не потрібні, тому що під час повороту екрана модель нічого не втратила. І вже точно модель не повинна заново робити запити в БД, на сервер тощо.  Додаток було вбито, і тепер запущено заново. У цьому випадку модель бере дані з   savedInstanceState  і використовує їх, щоб відновити свої дані. Наприклад, бере ID і йде в БД за повними даними.  RxJava  На початку цього уроку ми розглянули приклад роботи   ViewModel  і   LiveData . Виникає питання, чи можна замінити   LiveData  на   Flowable ?  У   LiveData  є одна велика перевага - він враховує стан   Activity . Тобто він не буде слати дані, якщо   Activity  згорнуто. І він відпише від себе   Activity , яке закривається.  А ось   Flowable  цього не вміє. Якщо в моделі є   Flowable , і   Activity  підпишеться на нього, то цей Flowable триматиме   Activity , поки воно саме явно не відпишеться (або поки   Flowable  не завершиться).  Давайте розглянемо приклад.   ViewModel  зазвичай працює з репозиторіями, які можуть бути синглтонами. У репозиторії є якийсь об'єкт для підписки (типу   LiveData  або   Flowable ). Репозиторій періодично оновлює в ньому дані. Модель бере цей об'єкт із репозиторію і віддає його в Activity, і Activity підписується на цей об'єкт. Об'єкт тепер зберігає посилання на   Activity .  Таким чином вийшло, що репозиторій тримає посилання на   Activity  через об'єкт підписки. І якщо ми закриємо   Activity , але не відпишемо його від об'єкта підписки, то виникне витік пам'яті, тому що репозиторій може жити весь час роботи програми. І весь цей час   Activity  буде висіти в пам'яті.  Давайте розглянемо, як це вирішується у випадку з   LiveData  або   Flowable . Важливо розуміти, що відбуватиметься з підпискою під час закриття   Activity .   ViewModel  будемо розглядати тільки як інструмент передачі об'єкта з репозиторію в   Activity .    ViewModel  готовий з репозиторію надати LiveData. І ми в Activiy хотіли б працювати з LiveData.  Ланцюжок посилань:\n  Repository -> LiveData -> Activity  Тут виходить повна ідилія.   Activity  бере з моделі   LiveData , підписується на нього і все ок. Під час закриття   Activity  не буде ніяких витоків пам'яті та інших проблем з підпискою, тому що   LiveData  сам відпише   Activity  і тим самим розірве ланцюжок посилань.   ViewModel готовий повернути нам Flowable, а ми в Activity хотіли б працювати з   LiveData .  У цьому випадку конвертуємо   Flowable  у   LiveData  всередині моделі і віддаємо   LiveData  в   Activity .  Ланцюжок посилань:\n  Repository -> Flowable -> LiveData -> Activity   Activity  знову буде підписано на   LiveData . А це означає, що нам, як і в першому варіанті, не треба піклуватися про цю підписку.   LiveData  відпише від себе   Activity , і сам відпишеться від   Flowable . Ланцюжок посилань розірветься у двох місцях.    ViewModel  готовий повернути нам   LiveData , а ми в   Activity  хотіли б працювати з   Flowable .  У цьому випадку передаємо   LiveData  в   Activity  і перетворюємо його на   Flowable .  Ланцюжок посилань:\n  Repository -> LiveData -> Flowable -> Activity   Activity  буде підписано на   Flowable . А   Flowable  буде підписаний на   LiveData . При цьому підписка   Flowable  на   LiveData  працюватиме з урахуванням   Activity    LifeCycle . І коли   Activity  буде закрито,   LiveData  сам відпише від себе   Flowable .  Ланцюжок посилань розірветься, але, в будь-якому разі, гарною практикою є відписка від   Flowable  вручну при закритті   Activity .    ViewModel  готовий повернути нам   Flowable , і ми в   Activity  хотіли б працювати з   Flowable .  У цьому випадку   Activity  буде підписано на   Flowable .  Ланцюжок посилань:\n  Repository -> Flowable -> Activity  При закритті   Activity  нам самим необхідно відписати   Activity  від   Flowable .  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1078,"path":1079,"dir":1080,"title":1081,"description":1082,"keywords":1083,"body":1087},"content:1.android:9.lesson9:1.navigation.md","/android/lesson9/navigation","lesson9","Navigation Architecture Component. Вступ","На Google IO було представлено Navigation Architecture Component.",[1084,1085,1086],"Action","Activity","destination","  Navigation Architecture Component. Вступ  На Google IO було представлено   Navigation Architecture Component .  Я детально переглянув вихідні коди цього компонента, щоб точно розуміти, що він робить. Під капотом там ті самі startActivity і FragmentManager. Navigation Architecture Component - це обгортка над цими стандартними механізмами, яка покликана впорядкувати і спростити навігацію в застосунку.   Navigation  функціонал може бути вимкнений за замовчуванням. Перевірте налаштування студії   Settings > Experimental > Enable Navigation Editor . Перезапустіть студію після ввімкнення цього чекбокса.     dependencies {\n       implementation   'androidx.navigation:navigation-fragment-ktx:2.7.4'\n       implementation   'androidx.navigation:navigation-ui-ktx:2.7.4'\n       implementation   'com.google.android.material:material:1.10.0'\n   }\n     plugins {\n     // Kotlin serialization plugin for type safe routes and navigation arguments\n     kotlin(  \"plugin.serialization\"  ) version   \"2.0.21\"\n   }\n   \n   dependencies {\n     val   nav_version   =   \"2.8.5\"\n   \n     // Jetpack Compose integration\n     implementation(  \"androidx.navigation:navigation-compose:$nav_version\"  )\n   \n     // Views/Fragments integration\n     implementation(  \"androidx.navigation:navigation-fragment:$nav_version\"  )\n     implementation(  \"androidx.navigation:navigation-ui:$nav_version\"  )\n   \n     // Feature module support for Fragments\n     implementation(  \"androidx.navigation:navigation-dynamic-features-fragment:$nav_version\"  )\n   \n     // Testing Navigation\n     androidTestImplementation(  \"androidx.navigation:navigation-testing:$nav_version\"  )\n   \n     // JSON serialization library, works with the Kotlin serialization plugin\n     implementation(  \"org.jetbrains.kotlinx:kotlinx-serialization-json:1.7.3\"  )\n   }\n  Розглянемо простий приклад із   MainActivity  і трьома фрагментами:   Fragment1 ,   Fragment2 ,   Fragment3 .   MainActivity  буде по черзі відображати в собі фрагменти.  Для цього нам знадобляться такі   Navigation  інструменти:   NavController  - цей основний механізм   Navigation Component . Саме його ми будемо просити показувати на екрані фрагменти. Але щоб він міг це робити, він повинен мати список фрагментів і контейнер, у якому він буде ці фрагменти відображати.   NavGraph  - це список фрагментів, який ми будемо створювати і наповнювати.   NavController  зможе показувати фрагменти тільки з цього списку. Далі будемо називати його   графом .   NavHostFragment  - це контейнер. Усередині нього   NavController  відображатиме фрагменти.  Ще раз, коротко, для розуміння:   контролер  у   контейнері  відображає   фрагменти  з   графа .  Почнемо зі створення графа (  NavGraph ). Це звичайний   resource  файл із типом   Navigation .\n  \nПісля створення він порожній:\n  \nДавайте додавати фрагменти. У термінології   Navigation  вони називаються   destination .\n  \nТиснемо кнопку додавання, студія показує нам   фрагменти  та   Activity , які є в проєкті. Додаємо три фрагменти.  Результат\n  \nЗліва бачимо список усіх   destination  у цій графі. Позначкою   Start  відзначено стартовий   destination , який одразу буде відображено під час запуску програми. У нашому випадку це   Fragment1 .  Посередині відображено ті самі   destination , але вже не списком, а в їхньому реальному вигляді, з використанням їхнього   layout . Значком будиночка позначено стартовий   destination . Для всіх трьох фрагментів я створив однакові   layout : назва фрагмента і пара кнопок. Пізніше будемо використовувати ці кнопки для навігації.  Праворуч розташована панель атрибутів для поточного виділеного   destination . Про них ми детально поговоримо пізніше. Поки що нас цікавить атрибут   ID . Цей   ID  нам треба буде повідомляти контролеру (  NavController ), щоб він відобразив відповідний фрагмент. Цей   ID  до речі відображається в панелі посередині. Над кожним фрагментом можна побачити його   ID .  Ок, граф створено. Тепер у   MainActivity  треба додати контейнер (  NavHostFragment ), у якому   NavController  відображатиме фрагменти.  У   activity_main  додаємо   NavHostFragment :     \u003C  FrameLayout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n      xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n      xmlns:tools  =  \"http://schemas.android.com/tools\"\n      android:layout_width  =  \"match_parent\"\n      android:layout_height  =  \"match_parent\"\n      tools:context  =  \".MainActivity\"  >\n    \n      \u003C  fragment\n          android:id  =  \"@+id/nav_host_fragment\"\n          android:name  =  \"androidx.navigation.fragment.NavHostFragment\"\n          android:layout_width  =  \"match_parent\"\n          android:layout_height  =  \"match_parent\"\n          app:defaultNavHost  =  \"true\"\n          app:navGraph  =  \"@navigation/main_graph\"   />\n    \n   \u003C/  FrameLayout  >\n  Контейнер готовий. Залишається десь взяти контролер (  NavController ). Тут нам допоможе контейнер. Він при створенні сам створить контролер і трохи пізніше поділиться ним із нами.  Зверніть увагу, що в атрибуті   navGraph  ми вказали створений раніше граф   main_graph . Контейнер передасть цей граф контролеру.  Переходимо до коду.  Щоб попросити контролер у контейнера, використовуємо метод   Navigation.findNavController  із зазначенням   ID  контейнера. Цей метод за   ID  знайде контейнер   NavHostFragment  і візьме в нього контролер.  Код в   MainActivity.java     NavController   navController;\n    \n   @  Override\n   protected   void   onCreate  (  Bundle   savedInstanceState) {\n      super  .  onCreate  (savedInstanceState);\n      setContentView  (R.layout.activity_main);\n      navController   =   Navigation.  findNavController  (  this  , R.id.nav_host_fragment);\n   }\n  Тепер ми можемо використовувати цей контролер для навігації по фрагментах. Для цього є два методи:     navigate(int resId)  - щоб відкрити будь-який фрагмент із графа, треба в контролера викликати метод navigate і передати йому   ID destination . Контролер перегляне граф, визначить якому фрагменту в графі відповідає   ID  і відобразить цей фрагмент.    popBackStack  - повернення на крок назад, на попередній фрагмент.  Як ви вже бачили, у кожному з трьох фрагментів є кнопки   Back  і   Next . Після натискання на кнопку   Next  ми відкриватимемо наступний фрагмент. А після натискання на кнопку   Back  будемо повертатися на попередній. Я використовував   колбеки  й обробку натискань на ці кнопки витягнув в   Activity . Відповідно в   MainActivity  у мене   6 методів  (3 фрагменти, 2 кнопки в кожному)  У цих методах ми і будемо працювати з контролером.     @  Override\n   public   void   onFragment1NextClick  () {\n       navController.  navigate  (R.id.fragment2);\n   }\n    \n   @  Override\n   public   void   onFragment1BackClick  () {}\n    \n    \n   @  Override\n   public   void   onFragment2NextClick  () {\n       navController.  navigate  (R.id.fragment3);\n   }\n    \n   @  Override\n   public   void   onFragment2BackClick  () {\n       navController.  popBackStack  ();\n   }\n    \n    \n   @  Override\n   public   void   onFragment3NextClick  () {}\n    \n   @  Override\n   public   void   onFragment3BackClick  () {\n       navController.  popBackStack  ();\n   }\n  За назвою методу зрозуміло для якої кнопки якого фрагмента він є обробником.  Наприклад, після натискання на   Next  у   Fragment1  ми просимо контролер відкрити   destination  з   ID  =   fragment2 . Контролер знайде цей   destination  у графі, побачить, що це фрагмент   Fragment2  і в контейнері відобразить цей фрагмент.  Аналогічно після натискання на   Next  у   Fragment2  ми просимо відкрити   destination  з   ID = fragment3 , який у графі відповідає фрагменту   Fragment3 .  Після натискання на кнопки   Back , ми повертаємося на крок назад.  Запускаємо додаток. При старті одразу відобразиться   Fragment1 , бо він є стартовим у графі.  Виконуємо навігацію.\n   Системна кнопка   Back  теж працює і виконує крок назад. Це відбувається завдяки атрибуту     app:  defaultNavHost  =  \"true\"\n  який ми вказали в контейнері (  NavHostFragment ). Контейнер перехоплює натискання і показує попередній фрагмент.\nЯкщо встановити його значення в   false , то контейнер більше не буде обробляти системну кнопку   Back , і   Activity  буде закриватися.\n   Action  Під час виклику   destination  нам може знадобитися задати деякі параметри, наприклад,   анімацію ,   аргументи  тощо. Для цього використовується   action .  Давайте створимо   action , який виконуватиме перехід від   fragment1  до   fragment2    Для   destination    fragment1  ми створили   action , який веде в   destination    fragment2 .  У   action  є різні параметри, які ми можемо налаштовувати в редакторі графа. Вони будуть використані під час переходу від   destination    fragment1  до   destination    fragment2 .    Ми розберемо їх детально в наступних уроках. Поки що нас знову цікавить тільки значення атрибута   ID . Ми можемо використовувати його під час виклику методу   navigate , щоб викликати   action . Давайте зробимо це після натискання на кнопку   Next  у   Fragment1 .     @  Override\n   public   void   onFragment1NextClick  () {\n      navController.  navigate  (R.id.action_fragment1_to_fragment2);\n   }\n  Контролер зробить таке:   візьме поточний   destination  (який зараз відображається в контейнері, тобто   destination fragment1 )  знайде в нього   action  з   ID = action_fragment1_to_fragment2  визначить, що ця дія веде в   destination fragment2  визначить, що   destination fragment2  - це фрагмент   Fragment2  відобразить   Fragment2  і при цьому застосує параметри, які були задані в   action_fragment1_to_fragment2  Якщо ми спробуємо викликати   action , не перебуваючи в   destination , якому цей   action  належить, то буде   помилка . Тобто   action action_fragment1_to_fragment2  ми можемо викликати тільки перебуваючи в   destination fragment1 , тому що під час створення   action  ми малювали його з   destination fragment1 .  З одного   destination  можна створити кілька   action :    Activity  Як   destination  ми можемо використовувати не тільки   фрагменти , а й   Activity .  У цьому ж прикладі я створив   SecondActivity  і фрагменти   Fragment4  і   Fragment5 . Будемо викликати їх із   Fragment3 , що знаходиться в   MainActivity .  Відкриваємо граф   main_graph  і додаємо   SecondActivity , як новий   destination .     destination  створено, його   ID = secondActivity  При натисканні на кнопку   Next  у   Fragment3  будемо викликати цей   destination     @  Override\n   public   void   onFragment3NextClick  () {\n      navController.  navigate  (R.id.secondActivity);\n   }\n  Контролер знайде в графі, що   destination  з таким   ID  відповідає   SecondActivity  і запустить його.  На цьому повноваження графа   main_graph  закінчуються. У новому   Activity  нам потрібен новий граф.  Створюємо   second_graph  і додаємо туди   Fragment4  і   Fragment5     Fragment4  - стартовий, він буде відображений під час відкриття   SecondActivity .  У   layout activity_second  додаємо контейнер   NavHostFragment  і вказуємо граф   second_graph     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  FrameLayout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n      xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n      xmlns:tools  =  \"http://schemas.android.com/tools\"\n      android:layout_width  =  \"match_parent\"\n      android:layout_height  =  \"match_parent\"\n      tools:context  =  \".SecondActivity\"  >\n    \n      \u003C  fragment\n          android:id  =  \"@+id/nav_host_fragment\"\n          android:name  =  \"androidx.navigation.fragment.NavHostFragment\"\n          android:layout_width  =  \"match_parent\"\n          android:layout_height  =  \"match_parent\"\n          app:defaultNavHost  =  \"true\"\n          app:navGraph  =  \"@navigation/second_graph\"   />\n    \n   \u003C/  FrameLayout  >\n  У   SecondActivity  знаходимо контролер і в обробниках натискань кнопок фрагментів використовуємо його для навігації.     NavController   navController;\n    \n   @  Override\n   protected   void   onCreate  (  Bundle   savedInstanceState) {\n       super  .  onCreate  (savedInstanceState);\n       setContentView  (R.layout.activity_second);\n       navController   =   Navigation.  findNavController  (  this  , R.id.nav_host_fragment);\n   }\n    \n   @  Override\n   public   void   onFragment4NextClick  () {\n       navController.  navigate  (R.id.fragment5);\n   }\n    \n   @  Override\n   public   void   onFragment4BackClick  () {}\n    \n   @  Override\n   public   void   onFragment5NextClick  () {}\n    \n   @  Override\n   public   void   onFragment5BackClick  () {\n       navController.  popBackStack  ();\n   }\n  Запускаємо додаток\n   Із фрагмента   Fragment3  переходимо у   SecondActivity . Там відразу відкривається   Fragment4 , тому що він стартовий. З нього переходимо у   Fragment5  і назад. А ось повертатися з   SecondActivity  у   MainActivity  доводиться за допомогою системної кнопки   Back . Контролер у   SecondActivity  працює тільки в межах цього   Activity . Він нічого не знає за його межами. Він не знає, що робити, коли викликається   popBackStack  у стартовому фрагменті, тобто у   Fragment4 . Тут уже нам треба самим. Наприклад, можна в   onFragment4BackClick  викликати метод   finish , щоб закрити   Activity .  Метод   navController.popBackStack  повертає   boolean . Якщо контролер сам зміг повернутися на крок назад, то він поверне   true . Якщо ж він не знає, що робити, то поверне   false  і в цьому випадку ми самі можемо обробити цю ситуацію.  destination  Наостанок кілька слів про поняття   destination  у   Navigation Component . У грaфі у кожного   destination  є   ID , і ми вказуємо цей   ID  у методі   navigate , коли просимо контролер відкрити   destination . При цьому нам не важливо, чим є в графі цей   destination  -   Activity  або   фрагментом . Це турбота контролера. Він сам це визначить і викличе або   startActivity , або працюватиме з   FragmentManager .  Наприклад, у нас у додатку є екран конфігурації. Це фрагмент   ConfigFragment . У графі у нас цей фрагмент фігурує як   destination  з   ID = configScreen . І ми відкриваємо його викликом методу   navController.navigate(R.id.configScreen) .  Раптово ми вирішуємо, що треба екран конфігурації винести в окреме   ConfigActivity . Створюємо це   Activity , переносимо все туди і додаємо його в граф замість   ConfigFragment , під тим же   ID = configScreen .  При цьому в застосунку взагалі ніяк не змінюється код виклику екрана конфігурації. Це так і залишається виклик методу   navigate  із зазначенням   ID = configScreen . Але тепер контролер відкриватиме не   ConfigFragment  у поточному контейнері, а запустить нове   Activity , тому що ми налаштували це в графі.  А ось такий вигляд має вміст графа   main_graph.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  navigation   xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n      xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n      xmlns:tools  =  \"http://schemas.android.com/tools\"\n      app:startDestination  =  \"@id/fragment1\"  >\n      \u003C  fragment\n          android:id  =  \"@+id/fragment1\"\n          android:name  =  \"ru.startandroid.navigation.Fragment1\"\n          android:label  =  \"fragment1\"\n          tools:layout  =  \"@layout/fragment1\"   >\n          \u003C  action\n              android:id  =  \"@+id/action_fragment1_to_fragment2\"\n              app:destination  =  \"@id/fragment2\"   />\n      \u003C/  fragment  >\n      \u003C  fragment\n          android:id  =  \"@+id/fragment2\"\n          android:name  =  \"ru.startandroid.navigation.Fragment2\"\n          android:label  =  \"fragment2\"\n          tools:layout  =  \"@layout/fragment2\"   />\n      \u003C  fragment\n          android:id  =  \"@+id/fragment3\"\n          android:name  =  \"ru.startandroid.navigation.Fragment3\"\n          android:label  =  \"fragment3\"\n          tools:layout  =  \"@layout/fragment3\"   />\n      \u003C  activity\n          android:id  =  \"@+id/secondActivity\"\n          android:name  =  \"ru.startandroid.navigation.SecondActivity\"\n          android:label  =  \"activity_second\"\n          tools:layout  =  \"@layout/activity_second\"   />\n   \u003C/  navigation  >\n  Три фрагменти, одне   Activity  і в першого фрагмента є   action , який веде в другий фрагмент.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1089,"path":1090,"dir":1080,"title":1091,"description":1092,"keywords":1093,"body":1098},"content:1.android:9.lesson9:2.navigation-args.md","/android/lesson9/navigation-args","Navigation. Передання даних. Type-safe аргументи.","Щоб під час виклику destination передати дані, необхідно використовувати Bundle. Для нього залишили містечко в методі navigate.",[1094,1095,1096,1097],"Аргументи в графі","Type-safe","Відправник","Одержувач","  Navigation. Передання даних. Type-safe аргументи.  Щоб під час виклику   destination  передати дані, необхідно використовувати   Bundle . Для нього залишили містечко в методі   navigate .     Bundle   bundle   =   new   Bundle  ();\n   bundle.  putString  (  \"arg1\"  ,   \"value1\"  );\n   bundle.  putInt  (  \"arg2\"  ,   2  );\n   navController.  navigate  (R.id.fragment2, bundle);\n  Створюємо   Bundle , наповнюємо аргументами і передаємо в метод   navigate  разом з   ID    destination  (або   action ).  У фрагменті   fragment2  метод   getArguments  поверне такий   Bundle :     Bundle  [{arg1  =  value1, arg2  =  2  }]\n  Відповідно отримати дані можна стандартним шляхом:     String   arg1Value   =   getArguments  ().  getString  (  \"arg1\"  );\n   Integer   arg2Value   =   getArguments  ().  getInt  (  \"arg2\"  );\n  А якщо викликали не фрагмент, а   Activity , то так:     String   arg1Value   =   getIntent  ().  getStringExtra  (  \"arg1\"  );\n   Integer   arg2Value   =   getIntent  ().  getIntExtra  (  \"arg2\"  ,   0  );\n  Аргументи в графі  У графі ми можемо для   destination  додати аргументи і прописати їм значення за замовчуванням.    Секція   Arguments . Вказуємо ім'я аргумента, тип і значення за замовчуванням. Тип може бути   string ,   integer  і   reference .  Якщо тип   reference , то ми можемо вказати ідентифікатор будь-якого ресурсу. У цьому прикладі я вказав   dimen  і   string  ресурси. Вони мають такі значення.     \u003C  dimen   name  =  \"some_size\"  >20dp\u003C/  dimen  >\n   \u003C  string   name  =  \"app_name\"  >Navigation\u003C/  string  >\n  Давайте перевіримо, як працюють ці значення за замовчуванням. Знову викличемо   fragment2  і при цьому не задаватимемо жодних значень для аргументів, які щойно створили.     Bundle   bundle   =   new   Bundle  ();\n   bundle.  putString  (  \"arg1\"  ,   \"value1\"  );\n   bundle.  putInt  (  \"arg2\"  ,   2  );\n   navController.  navigate  (R.id.fragment2, bundle);\n  У результаті   getArguments  у фрагменті має такий вигляд:     Bundle[  {arg1=value1,   arg2=2,   arg3=defaultValue3,   arg4=52,   arg5=Navigation}]\n  Для аргументів   arg3 ,   arg4  і   arg5  прийшли дефолтні значення. Причому   reference  ідентифікатори були конвертовані у відповідні їм значення.   arg4  треба отримувати, як   Int , а   arg5  - як   String .  Значення за замовчуванням будуть приходити, якщо ми в коді не помістили в   Bundle  якесь своє значення аргументу.  Якщо для аргументу немає значення за замовчуванням у графі і в коді нічого не було задано в   Bundle , то в   destination  цей аргумент просто не прийде.  Type-safe  Студія може згенерувати нам класи і методи для зручного передавання аргументів. Для цього нам знадобиться   safeargs  плагін.  У   build.gradle  файл проєкту в секцію   buildscript > dependencies  необхідно додати   classpath     buildscript {\n       repositories {\n           google()\n       }\n       dependencies {\n           classpath   \"android.arch.navigation:navigation-safe-args-ini-plugin:1.0.0-alpha01\"\n       }\n   }\n  А в   build.gradle  модуля додаємо плагін   safeargs     apply plugin:   'com.android.application'\n   apply plugin:   'androidx.navigation.safeargs'\n    \n   android {\n      //...\n   }\n  Для повноцінного використання плагіна необхідно використовувати   action .  Додамо   action , який вестиме з   fragment1  до   fragment2  і вкажемо   ID = actionToFragment2 .    Зверніть увагу, що action підтягнув аргументи з   destination , в який він веде, тобто з   fragment2 . І ми можемо вказати для них значення за замовчуванням.  Отже, у нас у графі є три компоненти, які беруть участь у навігації:    destination , якому належить (з якого виходить) action (  ID = fragment1 )   action (ID = actionToFrgament2)   destination , у який веде action (  ID = fragment2 )  Для кожного з них буде згенеровано свій клас. Якщо класи не генеруються, натисніть   Ctrl+F9 .  Відправник  Для   fragment1  буде згенеровано клас   Fragment1Directions . Тобто як ім'я взято   ID  і додано слово   Directions . У цьому класі буде метод   actionToFragment2() , який дасть нам action   ActionToFragment2 .  action   ActionToFragment2  - згенерований клас для action   actionToFragment2 . У цього класу є методи, що відповідають аргументам цього   action  (див. скріншот вище). Тобто для аргументів   arg3 ,   arg4  і   arg5  будуть створені методи:     setArg3  (  String   arg3)\n   setArg4  (  int   arg4)\n   setArg5  (  int   arg5)\n  і ми зможемо їх використовувати, щоб задавати значення аргументів. Під капотом там все також використовується   Bundle .  Код навігації матиме такий вигляд:     Fragment1Directions  .  ActionToFragment2   action   =   Fragment1Directions.  actionToFragment2  ();\n   action.  setArg3  (  \"value3\"  ).  setArg4  (R.dimen.some_other_size).  setArg5  (R.string.hello_blank_fragment);\n   navController.  navigate  (action);\n  Отримуємо   ActionToFragment2  з   Fragment1Directions , задаємо значення аргументів і передаємо цей   action  у метод   navigate .  Одержувач  Для одержувача буде згенеровано клас   Fragment2Args . Тобто для імені використовується   ID destination + суфікс Args .  У цього класу будуть створені методи для вилучення даних з   bundle .  Статичний метод, для створення   Fragment2Args  з передачею йому   bundle .     public   static   Fragment2Args   fromBundle  (  Bundle   bundle)\n  І методи отримання значення аргументів.     public   String   getArg3  ()\n   public   int   getArg4  ()\n   public   int   getArg5  ()\n  Код вилучення аргументів матиме такий вигляд:     Fragment2Args   fragment2Args   =   Fragment2Args.  fromBundle  (  getArguments  ())\n   String   arg3Value   =   fragment2Args.  getArg3  ();\n   Integer   arg4Value   =   fragment2Args.  getArg4  ();\n   Integer   arg5Value   =   fragment2Args.  getArg5  ();\n  А якщо одержувач -   Activity , то код такий:     String   arg3Value   =   SecondActivityArgs.  fromBundle  (  getIntent  ().  getExtras  ()).  getArg3  ();\n  Ці згенеровані класи дуже прості, ви завжди можете відкрити їх і подивитися код. Загалом вони є обгорткою над   Bundle .  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1100,"path":1101,"dir":1080,"title":1102,"description":1103,"keywords":1104,"body":1109},"content:1.android:9.lesson9:3.navigation-ui.md","/android/lesson9/navigation-ui","Navigation. NavigationUI","Спочатку зроблю невелике доповнення до минулих уроків. У них уся робота з NavController велася в Activity, в якому знаходився контейнер NavHostFragment.",[1105,1106,1107,1108],"NavigationUI","Overflow menu","Navigation Drawer","BottomNavigationView","  Navigation. NavigationUI  Спочатку зроблю невелике доповнення до минулих уроків. У них уся робота з   NavController  велася в   Activity , в якому знаходився контейнер   NavHostFragment .  Код отримання контролера в   Activity  має такий вигляд:     navController   =   Navigation.  findNavController  (  this  , R.id.nav_host_fragment);\n  Але контролер може знадобиться і у фрагменті, який знаходиться в контейнері. У прикладах це були   Fragment1 ,   Fragment2  тощо.  У цих фрагментах, контролер може бути отриманий так:     navController   =   Navigation.  findNavController  (view);\n  Де   view  - це будь-який   View  у цьому фрагменті.  Приклад використання в   OnClickListener     buttonNext.  setOnClickListener  (  new   View.  OnClickListener  () {\n      @  Override\n      public   void   onClick  (  View   view) {\n          Navigation.  findNavController  (view).  navigate  (R.id.fragment2);\n      }\n   });\n  Персонально для   OnClickListener , до речі, створено окремий метод    Navigation.createNavigateOnClickListener , що дає змогу повісити обробник на кнопку так:     button.  setOnClickListener  (Navigation.  createNavigateOnClickListener  (R.id.fragment2));\n  Після натискання на кнопку буде виконано навігацію до   fragment2 .    NavigationUI   NavigationUI  - набір методів, що дають змогу інтегрувати   Navigation Component  із   меню ,   Navigation Drawer  і   BottomNavigationView .  Для використання, необхідно додати в   dependencies :     implementation   'android.arch.navigation:navigation-ui:2.8.5'\n  Overflow menu  Є таке меню     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  menu   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"  >\n    \n      \u003C  item   android:id  =  \"@+id/fragment1\"\n          android:title  =  \"Fragment 1\"  />\n    \n      \u003C  item   android:id  =  \"@+id/fragment2\"\n          android:title  =  \"Fragment 2\"  />\n    \n      \u003C  item   android:id  =  \"@+id/fragment3\"\n          android:title  =  \"Fragment 3\"  />\n    \n   \u003C/  menu  >\n  Воно відображатиметься в   Activity .  Зверніть увагу на   ID , які я використовував у меню:   @+id/fragment1 , і т.д. Ті самі   ID  використані для   destination  у графі:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  navigation   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n      xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n      xmlns:tools  =  \"http://schemas.android.com/tools\"\n      app:startDestination  =  \"@id/fragment1\"  >\n      \u003C  fragment\n          android:id  =  \"@+id/fragment1\"\n          android:name  =  \"ru.startandroid.navigation.Fragment1\"\n          android:label  =  \"@string/fragment_1_title\"\n          tools:layout  =  \"@layout/fragment1\"   />\n      \u003C  fragment\n          android:id  =  \"@+id/fragment2\"\n          android:name  =  \"ru.startandroid.navigation.Fragment2\"\n          android:label  =  \"@string/fragment_2_title\"\n          tools:layout  =  \"@layout/fragment2\"   />\n      \u003C  fragment\n          android:id  =  \"@+id/fragment3\"\n          android:name  =  \"ru.startandroid.navigation.Fragment3\"\n          android:label  =  \"@string/fragment_3_title\"\n          tools:layout  =  \"@layout/fragment3\"   />\n   \u003C/  navigation  >\n  Тепер в обробці натискань використовуємо метод    NavigationUI.onNavDestinationSelected .     @  Override\n   public   boolean   onOptionsItemSelected  (  MenuItem   item) {\n      NavigationUI.  onNavDestinationSelected  (item, navController);\n      return   super  .  onOptionsItemSelected  (item);\n   }\n  Під капотом буде виконана навігація до   destination  з   ID = item.getItemId() .  Відповідно під час натискання на пункт меню з   ID = fragment2 , буде виконано навігацію до   destination  з тим самим   ID , тобто   fragment2 .  Результат:\n   Для пунктів меню можна використовувати   ID  не тільки від   destination , а й від   action .  Navigation Drawer  Є   Drawer , який відображає таке меню     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  menu   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"  >\n    \n      \u003C  group   android:checkableBehavior  =  \"single\"  >\n    \n      \u003C  item   android:id  =  \"@+id/fragment1\"\n          android:title  =  \"Fragment 1\"  />\n    \n      \u003C  item   android:id  =  \"@+id/fragment2\"\n          android:title  =  \"Fragment 2\"  />\n    \n      \u003C  item   android:id  =  \"@+id/fragment3\"\n          android:title  =  \"Fragment 3\"  />\n    \n      \u003C/  group  >\n    \n   \u003C/  menu  >\n  Зазвичай, щоб обробляти натискання на ці пункти меню, ми вішаємо обробник на   NavigationView , який всередині   DrawerLayout .  Але замість цього ми можемо зробити так:     NavigationUI.  setupWithNavController  (navigationView, navController);\n  Цей метод сам повісить обробник на   NavigationView  і після натискання на пункти меню виконуватиме навігацію до   destination  (або   action ) з тим самим   ID , що й у натиснутого пункту меню. Також він сам виділятиме пункт меню (  setChecked ) і закриватиме   Drawer .  При цьому параметру   Pop To  буде задано стартовий   destination . Тобто системна кнопка   Back  завжди повертатиме нас у   Fragment 1 .  Результат\n   Усе ок, але можна зробити ще краще.     NavigationUI.  setupActionBarWithNavController  (  this  , navController, drawerLayout);\n  Додаємо інтеграцію   ActionBar . Тепер під час навігації в   ActionBar  буде поміщатися   Label  у   destination . І іконка змінюватиметься, якщо перебуваємо не в стартовому   destination .\n   Натискання на   Home  обробляємо самі     @  Override\n   public   boolean   onOptionsItemSelected  (  MenuItem   item) {\n      switch   (item.  getItemId  ()) {\n          case   android.R.id.home  :\n              drawerLayout.  openDrawer  (GravityCompat.START);\n              return   true  ;\n      }\n      return   super  .  onOptionsItemSelected  (item);\n   }\n  BottomNavigationView  Є   BottomNavigationView , що відображає меню:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  menu   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"  >\n    \n      \u003C  item\n          android:id  =  \"@+id/fragment1\"\n          android:title  =  \"Fragment 1\"   />\n    \n      \u003C  item\n          android:id  =  \"@+id/fragment2\"\n          android:title  =  \"Fragment 2\"   />\n    \n      \u003C  item\n          android:id  =  \"@+id/fragment3\"\n          android:title  =  \"Fragment 3\"   />\n    \n   \u003C/  menu  >\n  Щоб обробити його натискання, ми зазвичай вішаємо обробник. За нас це може зробити   Navigation .     NavigationUI.  setupWithNavController  (bottomNavigationView, navController);\n  Метод   setupWithNavController  вішає лістенер на   BottomNavigationView  і виконує навігацію при натисканні на його елементи. При цьому виконує   setChecked  для натиснутого елемента.  Результат:\n  \nСистемна кнопка   Back  завжди повертатиме нас на стартовий   destination .  Можна додати інтеграцію з   ActionBar :     NavigationUI.  setupActionBarWithNavController  (  this  , navController);\n  Тепер під час навігації в   ActionBar  буде поміщатися   Label  у   destination . І іконка змінюватиметься, якщо перебуваємо не в стартовому   destination .  У цьому випадку треба самим обробити натискання на Home.     @  Override\n   public   boolean   onOptionsItemSelected  (  MenuItem   item) {\n      switch   (item.  getItemId  ()) {\n          case   android.R.id.home  :\n              navController.  popBackStack  ();\n              return   true  ;\n      }\n    \n      return   super  .  onOptionsItemSelected  (item);\n   }\n  Результат:\n   html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1111,"path":1112,"dir":1080,"title":1113,"description":1114,"keywords":1115,"body":1119},"content:1.android:9.lesson9:4.navigation-extend.md","/android/lesson9/navigation-extend","Navigation. Вкладений граф. Global Action. Deep Link.","Вкладений граф - це граф, який може бути створений всередині іншого графа.",[1116,1117,1118],"Навігація","Global Action","Deep Link","  Navigation. Вкладений граф. Global Action. Deep Link.   Вкладений граф  - це граф, який може бути створений всередині іншого графа.  Для цього треба виділити весь   destination , який ви хочете перемістити у вкладений граф, натиснути правою кнопкою і вибрати   Move to Nested Graph > New Graph    Вкладений граф - це звичайний   destination  в основному графі. Так само, як   фрагмент  або   Activity . І в цього   destination  є параметри.\n  \nУсе тут нам уже знайоме.  Подвійним кліком можна відкрити граф\n   Повернутися назад в основний граф можна натиснувши на   Root  у лівій панелі:\n   Я не знайшов, як у дизайнері трансформувати вкладений граф назад у фрагменти в основному графі. Найпростіше це зробити руками через XML.  Так виглядає граф із вкладеним графом     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  navigation   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n      xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n      xmlns:tools  =  \"http://schemas.android.com/tools\"\n      app:startDestination  =  \"@id/fragment1\"  >\n      \u003C  fragment\n          android:id  =  \"@+id/fragment1\"\n          android:name  =  \"ru.startandroid.navigation.Fragment1\"\n          android:label  =  \"@string/fragment_1_title\"\n          tools:layout  =  \"@layout/fragment1\"   />\n      \u003C  navigation\n          android:id  =  \"@+id/navigation2\"\n          app:startDestination  =  \"@id/fragment2\"  >\n          \u003C  fragment\n              android:id  =  \"@+id/fragment2\"\n              android:name  =  \"ru.startandroid.navigation.Fragment2\"\n              android:label  =  \"@string/fragment_2_title\"\n              tools:layout  =  \"@layout/fragment2\"   />\n          \u003C  fragment\n              android:id  =  \"@+id/fragment3\"\n              android:name  =  \"ru.startandroid.navigation.Fragment3\"\n              android:label  =  \"@string/fragment_3_title\"\n              tools:layout  =  \"@layout/fragment3\"   />\n      \u003C/  navigation  >\n   \u003C/  navigation  >\n  Тобто   вкладений граф  - це тег   navigation  всередині основного   navigation  тега.  Видаляємо цей вкладений тег і фрагменти опиняються назад в основному графі.     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  navigation   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n      xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n      xmlns:tools  =  \"http://schemas.android.com/tools\"\n      app:startDestination  =  \"@id/fragment1\"  >\n      \u003C  fragment\n          android:id  =  \"@+id/fragment1\"\n          android:name  =  \"ru.startandroid.navigation.Fragment1\"\n          android:label  =  \"@string/fragment_1_title\"\n          tools:layout  =  \"@layout/fragment1\"  />\n    \n    \n    \n          \u003C  fragment\n              android:id  =  \"@+id/fragment2\"\n              android:name  =  \"ru.startandroid.navigation.Fragment2\"\n              android:label  =  \"@string/fragment_2_title\"\n              tools:layout  =  \"@layout/fragment2\"   />\n          \u003C  fragment\n              android:id  =  \"@+id/fragment3\"\n              android:name  =  \"ru.startandroid.navigation.Fragment3\"\n              android:label  =  \"@string/fragment_3_title\"\n              tools:layout  =  \"@layout/fragment3\"   />\n    \n   \u003C/  navigation  >\n  Навігація  Припустимо, ми створили вкладений граф із фрагментами   fragment2  і   fragment3 . А в основному графі залишився   fragment1 .  Тепер, перебуваючи у   fragment1  ми не можемо зробити так:     navController.  navigate  (R.id.fragment2);\n  Буде помилка:   navigation destination ru.startandroid.navigation:id/fragment2 is unknown to this NavController .  Так відбувається, тому що   fragment1  знаходиться в основній графі. І коли ми з   fragment1  намагаємося кудись перейти, то контролер намагається знайти ціль (  fragment2 ) у цьому ж графі, але там її немає. Зате там є вкладений граф з   ID = navigation2 . Ось його і треба відкривати:     navController.  navigate  (R.id.navigation2);\n  У результаті контролер знайде   destination  c   ID = navigation2 , побачить, що це граф, і відкриє його стартовий   destination , тобто   fragment2 .  Тобто із зовнішнього графа не можна викликати   destination  вкладеного графа. А ось навпаки - можна.  Додамо, наприклад,   fragment4   З будь-якого   destination  у вкладеному графі ми можемо перейти до   fragment4  звичайним шляхом:     navController.  navigate  (R.id.fragment4);\n  У цьому разі контролер спочатку буде шукати мету (  fragment4 ) у поточному графі (  navigation2 ), а якщо не знайде, то продовжить пошуки в батьківському графі і там уже знайде.  Усередині вкладених графів також можна створювати вкладені графи.  Global Action  Зазвичай у   Action  є   destination -джерело, звідки ця дія може бути викликана, і   destination -призначення, куди ця дія веде. Але можна зробити   global action , у якого немає джерела. І будь-який   destination  зможе викликати цей   action . Це зручно, якщо один і той самий   destination  викликається з різних місць, але при цьому використовуються одні й ті самі параметри.   global action  створюється так:\n  \nВін має ті самі атрибути, що й звичайний   action  \nВикликається він теж, як звичайний   action     navController.  navigate  (R.id.action_global_fragment3);\n  Deep Link   Deep Link  призначений для відкриття програми відразу на певному екрані. За допомогою Navigation Component ми можемо присвоювати такі посилання необхідним   destination .  Наприклад для   fragment3 , ми присвоїмо посилання:   app://myapp/frag3  \nДалі, якщо у вас студія версії 3.2, то в маніфесті в тег   Activity , необхідно додати тег   nav-graph     \u003C  activity\n      android:name  =  \".MainActivity\"\n      android:label  =  \"MainActivity\"  >\n      \n      ...\n    \n      \u003C  nav-graph   android:value  =  \"@navigation/main_graph\"   />\n   \u003C/  activity  >\n  І студія сама налаштує   Intent Filter .  Якщо ж у вас студія старішої версії, то необхідно вручну налаштувати   Intent Filter  під цей   deep link .  Перевірити посилання можна за допомогою adb команди:     adb   shell   am   start   -a   android.intent.action.VIEW   -d   \"app://myapp/frag3\"\n  При виклику цієї команди буде відкрито застосунок, а в ньому відразу   fragment3 .  У   deep link  посиланні можна використовувати параметри. Наприклад, якщо для фрагмента задано таке посилання:     app://myapp/frag3/  {id}\n  то після виклику посилання     app://myapp/frag3/100\n  ми у фрагменті, що відкрився, можемо отримати   id  з аргументів.     String   id   =   getArguments  ().  getString  (  \"id\"  );\n  Символ   .*  дає змогу замінити частину посилання  Тобто якщо посилання задано таким чином:     app://myapp/frag3/.*/  {id}\n  то фрагмент буде відкрито при виклику посилання:     app://myapp/frag3/test1/100\n  або     app://myapp/frag3/test1/test2/100\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1121,"path":1122,"dir":1080,"title":1123,"description":1124,"keywords":1125,"body":1126},"content:1.android:9.lesson9:5.view-pager.md","/android/lesson9/view-pager","Перегортання сторінок і ViewPager2","Нерідко можна зустріти додатки, які реалізують систему перегортання, а сам додаток постає у вигляді набору сторінок, які можна перегортати ліворуч і праворуч. У додатку Android для створення подібного ефекту можна використовувати елемент ViewPager2 з комплекту JetPack. Для створення ефекту сторінок ViewPager2 використовує фрагменти.",[],"  Перегортання сторінок і ViewPager2  Нерідко можна зустріти додатки, які реалізують систему перегортання, а сам додаток постає у вигляді набору сторінок, які можна перегортати ліворуч і праворуч. У додатку Android для створення подібного ефекту можна використовувати елемент   ViewPager2  з комплекту   JetPack . Для створення ефекту сторінок   ViewPager2  використовує   фрагменти .  Отже, створимо новий проєкт. Додамо в папку   res/layout  файл розмітки для фрагмента, який представлятиме сторінку. Назвемо його   fragment_page.xml  і визначимо в ньому такий код:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n       \u003C  TextView\n           android:id  =  \"@+id/displayText\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:textSize  =  \"22sp\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Фрагмент відображатиме текстове поле з номером сторінки.  Тепер додамо в проєкт сам клас фрагмента. Назвемо його   PageFragment :     package   com.example.viewpagerapp  ;\n    \n   import   android.os.Bundle  ;\n   import   android.view.LayoutInflater  ;\n   import   android.view.View  ;\n   import   android.view.ViewGroup  ;\n   import   android.widget.TextView  ;\n    \n   import   androidx.fragment.app.Fragment  ;\n    \n   public   class   PageFragment   extends   Fragment   {\n    \n       private   int   pageNumber;\n    \n       public   static   PageFragment   newInstance  (  int   page  ) {\n           PageFragment   fragment   =   new   PageFragment  ();\n           Bundle   args  =new   Bundle  ();\n           args.  putInt  (  \"num\"  , page);\n           fragment.  setArguments  (args);\n           return   fragment;\n       }\n    \n       public   PageFragment  () {\n       }\n    \n       @  Override\n       public   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           pageNumber   =   getArguments  ()   !=   null   ?   getArguments  ().  getInt  (  \"num\"  )   :   1  ;\n       }\n    \n       @  Override\n       public   View   onCreateView  (  LayoutInflater   inflater  ,   ViewGroup   container  ,\n                                Bundle   savedInstanceState  ) {\n           View   result  =  inflater.  inflate  (R.layout.fragment_page, container,   false  );\n           TextView   pageHeader   =   result.  findViewById  (R.id.displayText);\n           String   header   =   \"Фрагмент \"   +   (pageNumber  +  1  );\n           pageHeader.  setText  (header);\n           return   result;\n       }\n   }\n  Змінна   pageNumber  вказує на номер поточної сторінки. Номер сторінки буде передаватися ззовні через фабричний метод   newInstance() . Передача номера відбувається шляхом додавання значення в аргумент   \"num\"  Потім при створенні фрагмента в методі   onCreate()  цей номер буде витягуватися з аргументу   \"num\"  (якщо аргументи визначені):     pageNumber   =   getArguments  ()   !=   null   ?   getArguments  ().  getInt  (  \"num\"  )   :   1  ;\n  У методі   onCreateView()  отриманий номер сторінки буде відображатися в текстовому полі.  Сам по собі фрагмент ще не створює функціональність посторінкової навігації. Для цього нам потрібен один із класів   PagerAdapter . Android SDK містить низку вбудованих реалізацій   PagerAdapter , зокрема, клас   FragmentStateAdapter . Цей клас є абстрактним, тому напряму ми його використовувати не можемо, і нам потрібно створити клас-спадкоємець. Для цього додамо в проєкт новий клас, який назвемо   MyAdapter :     package   com.example.viewpagerapp  ;\n    \n   import   androidx.annotation.NonNull  ;\n   import   androidx.fragment.app.Fragment  ;\n   import   androidx.fragment.app.FragmentActivity  ;\n   import   androidx.viewpager2.adapter.FragmentStateAdapter  ;\n    \n   public   class   MyAdapter   extends   FragmentStateAdapter   {\n       public   MyAdapter  (  FragmentActivity   fragmentActivity  ) {\n           super  (fragmentActivity);\n       }\n    \n       @  NonNull\n       @  Override\n       public   Fragment   createFragment  (  int   position  ) {\n           return  (PageFragment.  newInstance  (position));\n       }\n    \n       @  Override\n       public   int   getItemCount  () {\n           return   10  ;\n       }\n   }\n  Клас   FragmentStateAdapter  визначає два методи:     int   getItemCount  () : повертає кількість сторінок, які будуть у   ViewPager2  (у нашому випадку 10)    Fragment   createFragment  (  int   position) : за номером сторінки, що передається як параметр   position , повертає об'єкт   фрагмента  Варто зазначити, що як параметр конструктор   FragmentStateAdapter  приймає контекст виконання - зазвичай це об'єкт   FragmentActivity , але також це може бути об'єкт   Fragment  На завершення встановимо у файлі   activity_main.xml  елемент   ViewPager2 :     \u003C  androidx.viewpager2.widget.ViewPager2\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:id  =  \"@+id/pager\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"    />\n  І також змінимо код   MainActivity :     package   com.example.viewpagerapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   androidx.viewpager2.adapter.FragmentStateAdapter  ;\n   import   androidx.viewpager2.widget.ViewPager2  ;\n    \n   import   android.os.Bundle  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           ViewPager2   pager   =   findViewById  (R.id.pager);\n           FragmentStateAdapter   pageAdapter   =   new   MyAdapter  (  this  );\n           pager.  setAdapter  (pageAdapter);\n       }\n   }\n  Клас   MainActivity  наслідує   AppCompatActivity  - класу, який своєю чергою наслідує   FragmentActivity , і тому її поточний об'єкт ми можемо передати як параметр у конструктор   MyAdapter  (а через нього - у конструктор   FragmentStateAdapter ). Щоб перегортання запрацювало, для   ViewPager2  встановлюється адаптер   MyAdapter .  І запустивши проєкт, ми зможемо за допомогою перегортання переміщатися сторінками:\n   html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1128,"path":1129,"dir":1080,"title":1130,"description":1131,"keywords":1132,"body":1133},"content:1.android:9.lesson9:6.tab-layout.md","/android/lesson9/tab-layout","Заголовки сторінок і TabLayout","У минулій темі ми розглянули, як створити функціональність перегортання сторінок. Тепер підемо далі і додамо до сторінок заголовки, за допомогою яких ми можемо додатково переміщатися по сторінках.",[],"  Заголовки сторінок і   TabLayout  У минулій темі ми розглянули, як створити функціональність перегортання сторінок. Тепер підемо далі і додамо до сторінок заголовки, за допомогою яких ми можемо додатково переміщатися по сторінках.  Для додавання заголовків ми можемо використовувати вбудований віджет   TabLayout , який створює деяку подобу вкладки над сторінкою.  Використовуємо   TabLayout . Для цього візьмемо проект із минулої теми. І насамперед нам треба додати в проєкт підтримку для цього віджета. Для цього у файлі   build.gradle  додамо залежність:     implementation   \"com.google.android.material:material:1.4.0\"\n  Далі змінимо файл   activity_main.xml :     \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n       \u003C  com.google.android.material.tabs.TabLayout\n           android:id  =  \"@+id/tab_layout\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/pager\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"  />\n            \n       \u003C  androidx.viewpager2.widget.ViewPager2\n           android:id  =  \"@+id/pager\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/tab_layout\"  />\n            \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  У цьому випадку над елементом   ViewPager2  розташовується елемент   TabLayout , який визначає заголовок для певної сторінки у   ViewPager2 .  Потім необхідно зв'язати   ViewPager2  і   TabLayout . Для цього застосовується клас   TabLayoutMediator . Отже, змінимо код   MainActivity , щоб зв'язати   ViewPager2  і   TabLayout :     package   com.example.viewpagerapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n   import   androidx.viewpager2.adapter.FragmentStateAdapter  ;\n   import   androidx.viewpager2.widget.ViewPager2  ;\n    \n   import   android.os.Bundle  ;\n    \n   import   com.google.android.material.tabs.TabLayout  ;\n   import   com.google.android.material.tabs.TabLayoutMediator  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n           ViewPager2   pager   =   findViewById  (R.id.pager);\n           FragmentStateAdapter   pageAdapter   =   new   MyAdapter  (  this  );\n           pager.  setAdapter  (pageAdapter);\n    \n           TabLayout   tabLayout   =   findViewById  (R.id.tab_layout);\n           TabLayoutMediator   tabLayoutMediator  =   new   TabLayoutMediator  (tabLayout, pager,   new   TabLayoutMediator.  TabConfigurationStrategy  (){\n    \n               @  Override\n               public   void   onConfigureTab  (TabLayout.Tab tab,   int   position) {\n                   tab.  setText  (  \"Страница \"   +   (position   +   1  ));\n               }\n           });\n           tabLayoutMediator.  attach  ();\n       }\n   }\n  Конструктор   TabLayoutMediator  приймає три параметри: об'єкти   ViewPager2  і   TabLayout  та реалізацію інтерфейсу   TabConfigurationStrategy , яка за допомогою методу   onConfigureTab()  отримує окрему вкладку у вигляді об'єкта   Tab  та номер сторінки і дає змогу налаштувати вигляд вкладки, наприклад, встановити заголовок вкладки.  Після створення об'єкта   TabLayoutMediator  необхідно викликати в нього метод   attach() . Все інше залишається без змін. Запустимо проєкт на виконання і побачимо інтерактивні вкладки-заголовки поверх сторінок.  Вигляд програми за трьох вкладок:\n   html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1135,"path":1136,"dir":1137,"title":1138,"description":1139,"keywords":1140,"body":1148},"content:1.android:10.lesson10:1.work-manager.md","/android/lesson10/work-manager","lesson10","WorkManager. Вступ","Важлива частина роботи програми - це фонова робота. Це може бути завантаження або аплоад, стиснення або розпакування, синхронізація тощо. Колись давно для фонової роботи були призначені сервіси. Але в Android 8 їх дуже сильно обмежили: якщо застосунок не активний, то і сервіс буде зупинений через якийсь час. Та й ще задовго до Android 8 розробники почали використовувати такі інструменти як JobScheduler або Firebase JobDispatcher для запуску фонових завдань.",[1141,1142,1143,1144,1145,1146,1072,1147],"Завдання","Статус завдання","Скасування завдання","Tag","setInitialDelay","Періодичне завдання","Перезавантаження","  WorkManager. Вступ  Важлива частина роботи програми - це фонова робота. Це може бути   завантаження  або   аплоад ,   стиснення  або   розпакування ,   синхронізація  тощо. Колись давно для фонової роботи були призначені   сервіси . Але в Android 8 їх дуже сильно обмежили: якщо застосунок не активний, то і сервіс буде зупинений через якийсь час. Та й ще задовго до Android 8 розробники почали використовувати такі інструменти як   JobScheduler  або   Firebase JobDispatcher  для запуску фонових завдань.   WorkManager  - \"новий інструмент\". Він дає змогу запускати фонові завдання послідовно або паралельно, передавати в них дані, отримувати з них результат, відстежувати статус виконання і запускати тільки за дотримання заданих умов. При цьому він дуже простий у використанні.  Завдання  Давайте створимо і запустимо фонове завдання.  Додайте в   dependencies     implementation   \"android.arch.work:work-runtime:2.9.1\"\n  Створюємо клас, що наслідує клас   Worker :     public   class   MyWorker   extends   Worker   {\n    \n       static   final   String   TAG   =   \"workmng\"  ;\n    \n       @  NonNull\n       @  Override\n       public   WorkerResult   doWork  () {\n           Log.  d  (TAG,   \"doWork: start\"  );\n    \n           try   {\n               TimeUnit.SECONDS.  sleep  (  10  );\n           }   catch   (  InterruptedException   e  ) {\n               e.  printStackTrace  ();\n           }\n    \n           Log.  d  (TAG,   \"doWork: end\"  );\n    \n           return   WorkerResult.SUCCESS;\n       }\n   }\n  У метод   doWork  нам пропонується помістити код, який буде виконано. Я тут просто ставлю паузу в 10 секунд і повертаю результат   SUCCESS , що означає, що все пройшло успішно. Нам не треба морочитися з потоками, тому що код буде виконано не в UI потоці.  Завдання готове. Тепер нам потрібно   MyWorker  обернути в   WorkRequest :     OneTimeWorkRequest   myWorkRequest   =   new   OneTimeWorkRequest.  Builder  (MyWorker.class).  build  ();\n   WorkRequest  дає нам змогу задати умови запуску та вхідні параметри до завдання. Поки що ми нічого не задаємо, а просто створюємо   OneTimeWorkRequest , якому говоримо, що запускати треба буде завдання   MyWorker .   OneTimeWorkRequest  не дарма має таку назву. Це завдання буде виконано один раз. Є ще   PeriodicWorkRequest , але про нього трохи пізніше.  Тепер можна запускати завдання:     WorkManager.  getInstance  ().  enqueue  (myWorkRequest);\n  Беремо   WorkManager  і в його метод   enqueue  передаємо   WorkRequest . Після цього завдання буде запущено.  Дивимося лог:     20:37:36.567     5369-5444     doWork:   start\n   20:37:46.568     5369-5444     doWork:   end\n  Видно, що завдання виконувалося   10  секунд, і код виконувався не в UI потоці.  Статус завдання   WorkManager  надає можливість відстежувати статус виконання завдання. Наприклад, в   Activity  пишемо:     WorkManager.  getInstance  ().  getStatusById  (myWorkRequest.  getId  ()).  observe  (  this  ,   new   Observer  \u003C  WorkStatus  >() {\n      @  Override\n      public   void   onChanged  (@  Nullable   WorkStatus   workStatus  ) {\n          Log.  d  (TAG,   \"onChanged: \"   +   workStatus.  getState  ());\n      }\n   });\n  У метод   getStatusById  необхідно передати   ID  завдання, який може бути отриманий методом   WorkRequest.getId . У результаті ми отримуємо   LiveData , підписуємося на нього і в метод   onChanged  нам будуть приходити всі зміни статусу нашого завдання. Методом   WorkStatus.getState  будемо отримувати поточний стан.  Запускаємо     20:52:54.189     6060-6060     onChanged:   ENQUEUED\n   20:52:54.199     6060-6087     doWork:   start\n   20:52:54.203     6060-6060     onChanged:   RUNNING\n   20:53:04.200     6060-6087     doWork:   end\n   20:53:04.211     6060-6060     onChanged:   SUCCEEDED\n  Відразу після виклику методу enqueue завдання перебуває в статусі   ENQUEUED . Потім   WorkManager  визначає, що завдання можна запускати і виконує наш код. У цей момент статус змінюється на   RUNNING . Після виконання статус буде   SUCCEEDED , тому що ми повернули такий статус у методі doWork.  Статус нам приходить в UI потоці.  Тепер ще раз запустимо завдання і закриємо додаток:     20:58:19.402     doWork:   start\n   20:58:19.424     onChanged:   ENQUEUED\n   20:58:19.462     onChanged:   RUNNING\n   20:58:29.403     doWork:   end\n  Зверніть увагу, завдання завершилося, а статус   SUCCEEDED  не прийшов. Чому? Тому що, закривши   Activity , ми всього лише відписалися від   LiveData , який передавав нам статуси завдання. Але саме завдання нікуди не поділося. Воно ніяк не залежить від застосунку і буде виконуватися, навіть якщо застосунок закрито.  Результат  Ми в нашому завданні повертали статус   WorkerResult.SUCCESS , тим самим повідомляючи, що все ок. Є ще два варіанти:    FAILURE  - у цьому випадку після завершення завдання   workStatus.getState  поверне   FAILED . Для нас це сигнал, що завдання не було виконано.   RETRY  - а цей результат є сигналом для WorkManager, що завдання треба повторити. У цьому випадку   workStatus.getState  поверне нам статус   ENQUEUED  - тобто завдання знову заплановане.  Я протестував на емуляторі поведінку під час   RETRY : перший раз завдання було перезапущено приблизно через одну хвилину після попереднього завершення. З кожним наступним перезапуском інтервал збільшувався:     21:10:22.637   doWork:   start\n   21:10:32.638   doWork:   end\n   21:11:32.655   doWork:   start\n   21:11:42.657   doWork:   end\n   21:14:07.538   doWork:   start\n   21:14:17.543   doWork:   end\n   21:18:17.561   doWork:   start\n   21:18:27.602   doWork:   end\n   21:26:27.618   doWork:   start\n   21:26:37.653   doWork:   end\n  Скасування завдання  Ми можемо скасувати завдання методом   cancelWorkById , передавши   ID  завдання     WorkManager.  getInstance  ().  cancelWorkById  (myWorkRequest.  getId  ());\n  При цьому в класі   MyWorker  буде викликано метод   onStopped  (якщо ви його реалізували). Також у класі   MyWorker  ми завжди можемо використовувати   boolean  метод   isStopped  для перевірки того, що завдання було скасовано.  Якщо відстежуємо статус завдання, то   WorkStatus.getState  поверне   Cancelled .  Також є метод   cancelAllWork , який скасує всі ваші завдання. Але хелп попереджає, що він вкрай небажаний до використання, тому що може зачепити роботу бібліотек, які ви використовуєте.  Tag  Завданню можна присвоїти тег методом   addTag :     OneTimeWorkRequest   myWorkRequest   =   new   OneTimeWorkRequest.  Builder  (MyWorker.class)\n          .  addTag  (  \"mytag\"  )\n          .  build  ();\n  Одному завданню можна додавати кілька тегів.  У   WorkStatus  є метод   getTags , який поверне всі теги, які присвоєні цьому завданню.  Присвоївши один тег кільком завданням, ми можемо всіх їх скасувати методом   cancelAllWorkByTag :     WorkManager.  getInstance  ().  cancelAllWorkByTag  (  \"mytag\"  );\n   setInitialDelay  Виконання завдання можна відкласти на зазначений час     OneTimeWorkRequest   myWorkRequest   =   new   OneTimeWorkRequest.  Builder  (MyWorker.class)\n          .  setInitialDelay  (  10  , TimeUnit.SECONDS)\n          .  build  ();\n  У методі   setInitialDelay  ми вказали, що завдання слід запустити через   10  секунд після передачі його в   WorkManager.enqueue  Періодичне завдання  Розглянутий нами   OneTimeWorkRequest  - це разове завдання. А якщо потрібно багаторазове виконання через певний період часу, то можна використовувати   PeriodicWorkRequest :     PeriodicWorkRequest   myWorkRequest   =   new   PeriodicWorkRequest.  Builder  (MyWorker.class,   30  , TimeUnit.MINUTES)\n          .  build  ();\n  У білдері задаємо інтервал у   30  хвилин. Тепер завдання буде виконуватися з цим інтервалом.  Мінімально доступний інтервал -   15  хвилин. Якщо поставите менше,   WorkManager  сам підвищить до   15  хвилин.   WorkManager  гарантує, що завдання буде запущено один раз протягом зазначеного інтервалу. І це може статися в будь-який момент інтервалу - через   1  хвилину, через   10  або через   29 .  За допомогою параметра   flex  можна обмежити дозволений діапазон часу запуску.     PeriodicWorkRequest   myWorkRequest   =   new   PeriodicWorkRequest.  Builder  (MyWorker.class,   30  , TimeUnit.MINUTES,   25  , TimeUnit.MINUTES)\n          .  build  ();\n  Крім інтервалу в   30  хвилин додатково передаємо в білдер   flex  параметр   25  хвилин. Тепер завдання буде запущено не в будь-який момент   30 -хвилинного інтервалу, а тільки після   25 -ї хвилини. Тобто між   25  і   30  хвилинами.  Context  Щоб отримати   Context  у класі   Worker , використовуйте метод   getApplicationContext .  Перезавантаження  Що відбувається із запланованими завданнями під час перезавантаження пристрою? Я протестував цей кейс на емуляторі і з'ясував, що всі завдання зберігаються. Тобто   OneTimeWorkRequest  з відкладеним запуском,   OneTimeWorkRequest  з результатом   RETRY ,   PeriodicWorkRequest  - всі ці завдання будуть знову запущені після перезавантаження пристрою.  Тому дійте обдумано і зберігайте десь у себе ID або тег завдання, щоб ви могли його скасувати, якщо воно вам більше не потрібне.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1150,"path":1151,"dir":1137,"title":1152,"description":1153,"keywords":1154,"body":1161},"content:1.android:10.lesson10:2.work-manager-start.md","/android/lesson10/work-manager-start","WorkManager. Критерії запуску завдання.","WorkManager дає нам змогу задати критерії запуску завдання, наприклад - увімкнений інтернет на девайсі. Коли ви передасте таке завдання в WorkManager.enqueue, то буде виконана перевірка, що є інтернет. Якщо він є, то завдання запуститься. А якщо його немає, то завдання висітиме в статусі ENQUEUED, поки інет не з'явиться.",[1155,1156,1157,1158,1159,1160],"setRequiresCharging(boolean requiresCharging)","setRequiresBatteryNotLow (boolean requiresBatteryNotLow)","setRequiredNetworkType (NetworkType networkType)","setRequiresDeviceIdle (boolean requiresDeviceIdle)","setRequiresStorageNotLow (boolean requiresStorageNotLow)","addContentUriTrigger (Uri uri, boolean triggerForDescendants)","  WorkManager. Критерії запуску завдання.   WorkManager  дає нам змогу задати критерії запуску завдання, наприклад - увімкнений інтернет на девайсі. Коли ви передасте таке завдання в   WorkManager.enqueue , то буде виконана перевірка, що є інтернет. Якщо він є, то завдання запуститься. А якщо його немає, то завдання висітиме в статусі   ENQUEUED , поки інет не з'явиться.  Якщо завдання запущене і інтернет з якихось причин зник, то завдання буде зупинено і знову заплановано (  ENQUEUED ).  Давайте розглянемо, які критерії ми можемо задати.  Для прикладу будемо використовувати таке завдання.     public   class   MyWorker   extends   Worker   {\n    \n      static   final   String   TAG   =   \"workmng\"  ;\n    \n      @  NonNull\n      @  Override\n      public   WorkerResult   doWork  () {\n          Log.  d  (TAG,   \"doWork: start\"  );\n    \n          try   {\n              for   (  int   i   =   0  ; i   \u003C   10  ; i  ++  ) {\n                  TimeUnit.SECONDS.  sleep  (  1  );\n                  Log.  d  (TAG, i   +   \", isStopped \"   +   isStopped  ());\n                  if   (  isStopped  ())   return   WorkerResult.FAILURE;\n              }\n          }   catch   (  InterruptedException   e  ) {\n              e.  printStackTrace  ();\n          }\n    \n          Log.  d  (TAG,   \"doWork: end\"  );\n    \n          return   WorkerResult.SUCCESS;\n      }\n    \n      @  Override\n      public   void   onStopped  () {\n          super  .  onStopped  ();\n          Log.  d  (TAG,   \"onStopped\"  );\n      }\n    \n   }\n  Цикл із 10 пауз і логування статусу   isStopped . Якщо завдання було зупинено, то виходимо зі статусом   FAILURE .  Також логуємо метод   onStopped .  В   Activity  код для відстеження статусу завдання:     WorkManager.  getInstance  ()\n          .  getStatusById  (myWorkRequest.  getId  ())\n          .  observe  (  this  ,   new   Observer  \u003C  WorkStatus  >() {\n              @  Override\n              public   void   onChanged  (@  Nullable   WorkStatus   workStatus  ) {\n                  Log.  d  (TAG,   \"onChanged: \"   +   workStatus.  getState  ());\n              }\n          });\n   setRequiresCharging(boolean requiresCharging)  Критерій: зарядний пристрій має бути підключений.  Код додавання критерію має такий вигляд:     Constraints   constraints   =   new   Constraints.  Builder  ()\n          .  setRequiresCharging  (  true  )\n          .  build  ();\n    \n   OneTimeWorkRequest   myWorkRequest   =   new   OneTimeWorkRequest.  Builder  (MyWorker.class)\n          .  setConstraints  (constraints)\n              .  build  ();\n    \n   WorkManager.  getInstance  ().  enqueue  (myWorkRequest);\n  У   Constraints.Builder  включаємо критерій   setRequiresCharging , створюємо об'єкт   Constraints  і передаємо його в   OneTimeWorkRequest.Builder  у метод   setConstraints .  Для тесту я запустив завдання при вимкненому зарядному пристрої, потім увімкнув зарядку, потім знову вимкнув зарядку.     21:06:40.077   onChanged:   ENQUEUED\n   21:06:57.866   doWork:   start\n   21:06:57.872   onChanged:   RUNNING\n   21:06:58.867   0,   isStopped   false\n   21:06:59.868   1,   isStopped   false\n   21:07:00.869   2,   isStopped   false\n   21:07:01.871   3,   isStopped   false\n   21:07:02.266   onStopped\n   21:07:02.279   onChanged:   ENQUEUED\n   21:07:02.872   4,   isStopped   true\n   21:06:40 \nПід час запуску завдання було поставлено в очікування, тому що критерії запуску не були виконані - зарядний пристрій не було підключено.   21:06:57 \nЯ підключив зарядний пристрій і WorkManager запустив завдання. Вона почала виконуватися, статус   isStopped = false .   21:07:02 \nЯ відключив зарядний пристрій. Критерій не виконано, завдання зупинено (  onStopped ) і знову заплановано (  ENQUEUED ).\nПрапор   isStopped  тепер дорівнює true, ми це обробляємо і виходимо з циклу.  Зверніть увагу, що статус   FAILURE  нам не прийшов. Тобто під час зупинки завдання повністю ігнорується його результат.  Про всяк випадок нагадаю, що заплановане завдання ніяк не залежить від застосунку. Можна запустити завдання і закрити додаток. Потім через якийсь час увімкнути зарядник і завдання почне виконуватися.  Решта критеріїв встановлюються і поводяться аналогічно, тому я вже не буду наводити код, а тільки коротко опишу.  setRequiresBatteryNotLow (boolean requiresBatteryNotLow)  Критерій: рівень батареї не нижче критичного.  Я перевірив цей критерій на AVD емуляторі. Завдання починає виконуватися за рівня заряду понад 20, а зупиняється за менше ніж 16.  setRequiredNetworkType (NetworkType networkType)  Критерій: наявність інтернет.  Ми можемо вказати, який саме тип мережі інтернет (  NetworkType ) має бути під час запуску завдання:   CONNECTED - WiFi або Mobile Data  UNMETERD - тільки WiFi  METERED - тільки Mobile Data  NOT_ROAMING - інтернет має бути не роумінговий  NOT_REQUIRED - інтернет не потрібен  setRequiresDeviceIdle (boolean requiresDeviceIdle)  Критерій: девайс не використовується якийсь час і пішов у сплячку. Працює на API 23 і вище.  setRequiresStorageNotLow (boolean requiresStorageNotLow)  Критерій: на девайсі має бути вільне місце, не менше критичного порога. Не придумав, як це можна швидко протестувати, тому не можу підказати скільки це в мегабайтах.  addContentUriTrigger (Uri uri, boolean triggerForDescendants)  Критерій: завдання запуститься, коли оновиться вміст зазначеного   Uri . Що означає прапор   triggerForDescendants  - я поки що не знаю. Щойно з'ясую, напишу. Працює на API 24 і вище.  Для одного завдання можна задавати відразу кілька критеріїв.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1163,"path":1164,"dir":1137,"title":1165,"description":1166,"keywords":1167,"body":1169},"content:1.android:10.lesson10:3.work-manager-sequence-of-tasks.md","/android/lesson10/work-manager-sequence-of-tasks","WorkManager. Послідовність виконання завдань.","Буває необхідність запускати завдання в певному порядку. Наприклад, є завдання - завантажити архів із файлами, розпакувати його і якимось чином обробити файли. Це може бути виконано трьома послідовними завданнями:",[1168],"Unique work","  WorkManager. Послідовність виконання завдань.  Буває необхідність запускати завдання в певному порядку. Наприклад, є завдання - завантажити архів із файлами, розпакувати його і якимось чином обробити файли. Це може бути виконано трьома послідовними завданнями:   завантаження архіву  розпакування архіву  обробка файлів  Давайте подивимося, як можна запускати завдання послідовно.  Для початку переконаємося, що завдання, запущені звичайним шляхом, будуть виконані паралельно.  Для тестових прикладів я зробив завдання, які просто ставлять потік на паузу кодом   TimeUnit.SECONDS.sleep  і логують початок і кінець роботи. Завдання   MyWorker1  працюватиме одну секунду,   MyWorker2  -   2  секунди і т.д.  Усі завдання обгорнуті в   OneTimeWorkRequest  без будь-яких критеріїв.  Запускаємо відразу три завдання.     WorkManager.  getInstance  ().  enqueue  (myWorkRequest1, myWorkRequest2, myWorkRequest3);\n  Дивимося лог     20:46:38.120   2737-4244   MyWorker1   start\n   20:46:38.124   2737-2808   MyWorker3   start\n   20:46:38.130   2737-4245   MyWorker2   start\n   20:46:39.122   2737-4244   MyWorker1   end\n   20:46:40.132   2737-4245   MyWorker2   end\n   20:46:41.125   2737-2808   MyWorker3   end\n  Завдання почали роботу в один час -   20:46:38 , виконувалися паралельно в різних потоках і закінчили кожне у свій час.  Ми побачили паралельне виконання. Тепер давайте виконаємо їх послідовно.     WorkManager.  getInstance  ()\n          .  beginWith  (myWorkRequest1)\n          .  then  (myWorkRequest2)\n          .  then  (myWorkRequest3)\n          .  enqueue  ();\n  У метод   beginWith  передаємо перше завдання і тим самим створюємо початок послідовності завдань. Далі викликами методу   then  додаємо до послідовності друге і третє завдання. І методом enqueue відправляємо цю послідовність на запуск.  Результат:     21:08:31.899   4518-4614   MyWorker1   start\n   21:08:32.901   4518-4614   MyWorker1   end\n   21:08:32.929   4518-4616   MyWorker2   start\n   21:08:34.931   4518-4616   MyWorker2   end\n   21:08:34.951   4518-4617   MyWorker3   start\n   21:08:37.952   4518-4617   MyWorker3   end\n  З логів видно, що завдання виконувалися одне за одним і саме в тій послідовності, що ми вказали.  Як критерії вплинуть на виконання послідовності завдань? Завдання, яке не може зараз бути запущено, буде чекати. І, відповідно, всі інші завдання, які в послідовності знаходяться після цього завдання, також чекатимуть.  Розглянемо на прикладі. Нехай у другого завдання є критерій - наявність інтернету. Вимикаємо інет на девайсі і стартуємо послідовність. Першому завданню все одно, воно виконується. Настає черга другого завдання, але інету немає, тому друге завдання ставиться в очікування. А третє завдання може бути запущено тільки після завершення другого. Тому йому доводиться чекати. Вмикаємо інет, друге завдання виконується, а за ним виконується третє.  Якщо якесь завдання в послідовності завершиться статусом   FAILURE , то весь ланцюжок буде зупинено.  Ми можемо комбінувати послідовне і паралельне виконання завдань.     WorkManager.  getInstance  ()\n          .  beginWith  (myWorkRequest1, myWorkRequest2)\n          .  then  (myWorkRequest3, myWorkRequest4)\n          .  then  (myWorkRequest5)\n          .  enqueue  ();\n  Ми тут формуємо послідовність, але при цьому вказуємо по два завдання для першого (  beginWith ) і другого (перший   then ) кроку послідовності.  У результаті спочатку будуть виконані завдання   myWorkRequest1  і   myWorkRequest2 , причому вони будуть виконані паралельно. Після цього будуть виконані   myWorkRequest3  і   myWorkRequest4 , також паралельно одне одному. А після цього -   myWorkRequest5 .  У логах це матиме такий вигляд:     21:35:14.851   5379-5420   MyWorker1   start\n   21:35:14.853   5379-5421   MyWorker2   start\n   21:35:15.852   5379-5420   MyWorker1   end\n   21:35:16.854   5379-5421   MyWorker2   end\n   21:35:16.882   5379-5425   MyWorker3   start\n   21:35:16.884   5379-5420   MyWorker4   start\n   21:35:19.882   5379-5425   MyWorker3   end\n   21:35:20.885   5379-5420   MyWorker4   end\n   21:35:20.910   5379-5421   MyWorker5   start\n   21:35:25.911   5379-5421   MyWorker5   end\n  Перше і друге завдання стартують одночасно. Коли вони обидва завершені, стартують третє і четверте, також одночасно. Коли вони обидва завершені, стартує п'яте завдання.  Розглянемо інший випадок. Припустимо, нам потрібно, щоб друге завдання виконалося після першого, а четверте після третього. Тобто у нас є дві послідовності, і вони можуть бути запущені паралельно. А коли дві ці послідовності буде виконано, необхідно запустити п'яте завдання.  Це робиться так:     WorkContinuation   chain12   =   WorkManager.  getInstance  ()\n          .  beginWith  (myWorkRequest1)\n          .  then  (myWorkRequest2);\n   \n   WorkContinuation   chain34   =   WorkManager.  getInstance  ()\n          .  beginWith  (myWorkRequest3)\n          .  then  (myWorkRequest4);\n   \n   WorkContinuation.  combine  (chain12, chain34)\n          .  then  (myWorkRequest5)\n          .  enqueue  ();\n   WorkContinuation  - це послідовність завдань. Ми створюємо послідовність   chain12 , що складається з першого і другого завдань, і послідовність   chain34 , що складається з третього і четвертого завдань. Щоб ці послідовності були запущені паралельно одна одній, ми передаємо їх у метод   combine . Потім у метод   then  передаємо п'яте завдання, яке стартує після того, як будуть виконані всі послідовності з   combine .  Результат:     21:45:50.470   5578-5623   MyWorker1   start\n   21:45:50.470   5578-5624   MyWorker3   start\n   21:45:51.471   5578-5623   MyWorker1   end\n   21:45:51.500   5578-5625   MyWorker2   start\n   21:45:53.470   5578-5624   MyWorker3   end\n   21:45:53.486   5578-5623   MyWorker4   start\n   21:45:53.502   5578-5625   MyWorker2   end\n   21:45:57.486   5578-5623   MyWorker4   end\n   21:45:57.534   5578-5625   MyWorker5   start\n   21:46:02.535   5578-5625   MyWorker5   end\n  Стартують перше і третє завдання, тобто послідовності починають працювати паралельно. Коли обидві послідовності виконані, стартує п'яте завдання.  Unique work  Ми можемо зробити послідовність завдань унікальною. Для цього починаємо послідовність методом   beginUniqueWork .     WorkManager.  getInstance  ()\n   .  beginUniqueWork  (  \"work123\"  , ExistingWorkPolicy.REPLACE, myWorkRequest1)\n   .  then  (myWorkRequest3)\n   .  then  (myWorkRequest5)\n   .  enqueue  ();\n  Вказуємо ім'я послідовності, режим і перше завдання послідовності.  Як режим ми вказали   REPLACE . Це означає, що, якщо послідовність із таким ім'ям уже перебуває в роботі, то ще один запуск призведе до того, що поточну послідовність, що виконується, буде зупинено, а нову запущено.  Я додав логування виклику методу enqueue, який запускає послідовність. Давайте подивимося в логах, що відбувається.     22:17:21.443   6261-6261   enqueue,   REPLACE\n   22:17:21.502   6261-6301   MyWorker1   start\n   22:17:22.504   6261-6301   MyWorker1   end\n   22:17:22.531   6261-6303   MyWorker3   start\n   22:17:25.532   6261-6303   MyWorker3   end\n   22:17:25.557   6261-6304   MyWorker5   start\n   22:17:27.139   6261-6261   enqueue,   REPLACE\n   22:17:27.144   6261-6283   MyWorker5   onStopped\n   22:17:27.197   6261-6301   MyWorker1   start\n   22:17:28.198   6261-6301   MyWorker1   end\n   22:17:28.223   6261-6301   MyWorker3   start\n   22:17:30.557   6261-6304   MyWorker5   end\n   22:17:31.225   6261-6301   MyWorker3   end\n   22:17:31.243   6261-6303   MyWorker5   start\n   22:17:36.245   6261-6303   MyWorker5   end\n   22:17:21  - це перший запуск послідовності. Завдання починають виконуватися одне за одним.   22:17:27  - під час роботи   MyWorker5  я створюю і стартую таку саму послідовність із тим самим ім'ям -   work123 . Поточна виконувана послідовність зупиняється, і нова починається.  Режим   KEEP  залишить у роботі поточну виконувану послідовність. А нова буде проігнорована.  Код:     WorkManager.  getInstance  ()\n          .  beginUniqueWork  (  \"work123\"  , ExistingWorkPolicy.KEEP, myWorkRequest1)\n          .  then  (myWorkRequest3)\n          .  then  (myWorkRequest5)\n          .  enqueue  ();\n     22:18:22.215   6351-6351   enqueue,   KEEP\n   22:18:22.282   6351-6392   MyWorker1   start\n   22:18:23.284   6351-6392   MyWorker1   end\n   22:18:23.309   6351-6393   MyWorker3   start\n   22:18:26.311   6351-6393   MyWorker3   end\n   22:18:26.334   6351-6394   MyWorker5   start\n   22:18:27.837   6351-6351   enqueue,   KEEP\n   22:18:31.336   6351-6394   MyWorker5   end\n   22:18:27  - я знову спробував запустити послідовність, але мене проігнорували, тому що в роботі вже є послідовність із таким ім'ям.  Режим   APPEND  запустить нову послідовність після виконання поточної.  Код:     WorkManager.  getInstance  ()\n          .  beginUniqueWork  (  \"work123\"  , ExistingWorkPolicy.APPEND, myWorkRequest1)\n          .  then  (myWorkRequest3)\n          .  then  (myWorkRequest5)\n          .  enqueue  ();\n  Логи:     22:19:01.376   6450-6450   enqueue,   APPEND\n   22:19:01.440   6450-6478   MyWorker1   start\n   22:19:02.441   6450-6478   MyWorker1   end\n   22:19:02.464   6450-6479   MyWorker3   start\n   22:19:05.465   6450-6479   MyWorker3   end\n   22:19:05.496   6450-6480   MyWorker5   start\n   22:19:06.911   6450-6450   enqueue,   APPEND\n   22:19:10.496   6450-6480   MyWorker5   end\n   22:19:10.517   6450-6480   MyWorker1   start\n   22:19:11.518   6450-6480   MyWorker1   end\n   22:19:11.541   6450-6479   MyWorker3   start\n   22:19:14.542   6450-6479   MyWorker3   end\n   22:19:14.561   6450-6478   MyWorker5   start\n   22:19:19.562   6450-6478   MyWorker5   end\n   22:19:06  - поточну послідовність не було перервано, а нову було запущено відразу після закінчення поточної.  Акуратніше з цим режимом, оскільки помилка в поточній послідовності може призвести до того, що нова послідовність не запуститься.  У цих останніх прикладах я створював і перезапускав однакову послідовність, але поточна і нова послідовності можуть складатися з різних завдань. Головне тут - однакове ім'я послідовностей.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1171,"path":1172,"dir":1137,"title":1173,"description":1174,"keywords":1175,"body":1180},"content:1.android:10.lesson10:4.work-manager-args.md","/android/lesson10/work-manager-args","WorkManager. Передавання та отримання даних","Коли ми запускаємо завдання, нам може знадобитися передати в нього дані й отримати назад результат. Давайте подивимося, як це можна зробити.",[1176,1177,1178,1179],"Вхідні дані","Вихідні дані","Дані між завданнями","Custom merger","  WorkManager. Передавання та отримання даних  Коли ми запускаємо завдання, нам може знадобитися передати в нього дані й отримати назад результат. Давайте подивимося, як це можна зробити.  Вхідні дані  Спочатку розглянемо як передати в задачу вхідні дані:     Data   myData   =   new   Data.  Builder  ()\n          .  putString  (  \"keyA\"  ,   \"value1\"  )\n          .  putInt  (  \"keyB\"  ,   1  )\n          .  build  ();\n   \n   OneTimeWorkRequest   myWorkRequest1   =   new   OneTimeWorkRequest.  Builder  (MyWorker1.class)\n          .  setInputData  (myData)\n          .  build  ();\n  Дані поміщаємо в об'єкт   Data  за допомогою його білдера. Далі цей об'єкт передаємо в метод   setInputData  білдера   WorkRequest .  Коли завдання буде запущено, то всередині нього (у   MyWorker1.java ) ми можемо отримати ці вхідні дані так:     String   valueA   =   getInputData  ().  getString  (  \"keyA\"  ,   \"\"  );\n   int   valueB   =   getInputData  ().  getInt  (  \"keyB\"  ,   0  );\n  Вихідні дані  Щоб завдання повернуло дані, необхідно передати їх у метод   setOutputData . Код у   MyWorker1.java  буде таким:     Data   output   =   new   Data.  Builder  ()\n          .  putString  (  \"keyC\"  ,   \"value11\"  )\n          .  putInt  (  \"keyD\"  ,   11  )\n          .  build  ();\n   setOutputData  (output);\n  Ці вихідні дані ми зможемо дістати з   WorkStatus     workStatus.  getOutputData  ().  getString  (  \"keyC\"  ,   \"\"  )\n  У об'єкта   Data , який зберігає дані, є метод   getKeyValueMap , який поверне вам   immutable Map , що містить усі дані цього   Data .  А у   Data.Builder  є метод   putAll(Map\u003CString, Object> values) , в який ви можете передати   Map , всі дані з якого будуть поміщені в   Data .  Дані між завданнями  Якщо ви створюєте послідовність завдань, то вихідні дані попереднього завдання передаватимуться як вхідні в наступне завдання.  Наприклад, запускаємо послідовність із першого та другого завдань     WorkManager.  getInstance  ()\n          .  beginWith  (myWorkRequest1)\n          .  then  (myWorkRequest2)\n          .  enqueue  ();\n  Якщо перша задача повертає такі вихідні дані:     Data   output   =   new   Data.  Builder  ()\n          .  putString  (  \"keyA\"  ,   \"value1\"  )\n          .  putInt  (  \"keyB\"  ,   1  )\n          .  build  ();\n   setOutputData  (output);\n  То в другій вони прийдуть, як вхідні і ми можемо отримати їх звичайним шляхом     String   valueA   =   getInputData  ().  getString  (  \"keyA\"  ,   \"\"  );\n   int   valueB   =   getInputData  ().  getInt  (  \"keyB\"  ,   0  );\n  Трохи ускладнимо приклад:     WorkManager.  getInstance  ()\n          .  beginWith  (myWorkRequest1, myWorkRequest2)\n          .  then  (myWorkRequest3)\n          .  enqueue  ();\n  Перше і друге завдання виконуються паралельно, потім виконується третє. У результаті вихідні дані з першої та другої задач потраплять у третю. Давайте подивимося, як це вийде.  Нехай перше завдання повертає такі дані:     Data   output   =   new   Data.  Builder  ()\n          .  putString  (  \"keyA\"  ,   \"value1\"  )\n          .  putInt  (  \"keyB\"  ,   1  )\n          .  putString  (  \"keyC\"  ,   \"valueC\"  )\n          .  build  ();\n   setOutputData  (output);\n  А друга - такі     Data   output   =   new   Data.  Builder  ()\n          .  putString  (  \"keyA\"  ,   \"value2\"  )\n          .  putInt  (  \"keyB\"  ,   2  )\n          .  putString  (  \"keyD\"  ,   \"valueD\"  )\n          .  build  ();\n   setOutputData  (output);\n  Зверніть увагу, я спеціально зробив однакові ключі:   keyA  і   keyB , щоб перевірити, які значення цих ключів надійдуть до третьої задачі - з першої задачі чи з другої.  Виводжу в лог вхідні дані третього завдання:     Log.  d  (TAG,   \"work3, data \"   +   getInputData  ().  getKeyValueMap  ());\n  Результат:     work3,   data   {keyA=value2,   keyB=2,   keyC=valueC,   keyD=valueD}\n  В однакових ключах (  keyA  і   keyB ) ми бачимо, що прийшли дані з другого завдання. Спочатку я вирішив, що так сталося, тому що друге завдання виконується трохи довше за перше, і логічно, що його значення просто перезатерли значення з першого завдання під час збігу ключів. Але потім я знову запустив цю послідовність і отримав такий результат.     work3,   data   {keyA=value1,   keyB=1,   keyC=valueC,   keyD=valueD}\n  Тепер ми бачимо значення першого завдання в ключах   keyA  і   keyB .  Тобто якщо завдання виконуються паралельно, то в разі збігу ключів невідомо, з якого саме завдання ви отримаєте значення. Тому тут будьте акуратніше.   InputMerger \nЩоб перетворити кілька вихідних результатів в один вхідний, використовується   InputMerger . Існує кілька його реалізацій, за замовчуванням використовується   OverwritingInputMerger . Ми вже подивилися, як він працює. Якщо ключ збігається, то залишиться тільки одне значення.  Розглянемо ще один   InputMerger  -   ArrayCreatingInputMerger . Він у разі збігу ключів створить масив, у який помістить усі значення цього ключа.  Давайте для третього завдання вкажемо його методом   setInputMerger :     OneTimeWorkRequest   myWorkRequest3   =   new   OneTimeWorkRequest.  Builder  (MyWorker3.class)\n          .  setInputMerger  (ArrayCreatingInputMerger.class)\n          .  build  ();\n  Тепер під час злиття вихідних даних із попередніх завдань у вхідні дані третього завдання буде використовуватися   ArrayCreatingInputMerger .  Результат його роботи - це завжди масив, навіть якщо не було збігів ключів     String  [] valueA   =   getInputData  ().  getStringArray  (  \"keyA\"  );\n   int  [] valueB   =   getInputData  ().  getIntArray  (  \"keyB\"  );\n   String  [] valueC   =   getInputData  ().  getStringArray  (  \"keyC\"  );\n   String  [] valueD   =   getInputData  ().  getStringArray  (  \"keyD\"  );\n  Для перевірки використовуємо той самий приклад:     WorkManager.  getInstance  ()\n          .  beginWith  (myWorkRequest1, myWorkRequest2)\n          .  then  (myWorkRequest3)\n          .  enqueue  ();\n  Перше і друге завдання виконуються паралельно і їхні вихідні дані формуватимуть вхідні дані для третього завдання  Перше завдання поверне такі дані:     Data   output   =   new   Data.  Builder  ()\n          .  putString  (  \"keyA\"  ,   \"value1\"  )\n          .  putInt  (  \"keyB\"  ,   1  )\n          .  putString  (  \"keyC\"  ,   \"valueC\"  )\n          .  build  ();\n   setOutputData  (output);\n  а друга - такі     Data   output   =   new   Data.  Builder  ()\n          .  putString  (  \"keyA\"  ,   \"value2\"  )\n          .  putInt  (  \"keyB\"  ,   2  )\n          .  putString  (  \"keyD\"  ,   \"valueD\"  )\n          .  build  ();\n   setOutputData  (output);\n  У третій ми отримаємо такі вхідні дані:     valueA   =   [value1,   value2]\n   valueB   =   [1,   2]\n   valueC   =   [valueC]\n   valueD   =   [valueD]\n  Тепер у разі збігу ключів дані не перезатираються, а складаються в масив.  Custom merger  За необхідності ми можемо написати свій   InputMerger . Для цього треба просто успадкувати клас   InputMerger  і реалізувати його метод:     Data   merge  (@  NonNull   List  \u003C  Data  >   inputs)\n  На вхід ми отримуємо кілька вихідних даних із попередніх завдань, і від нас вимагається смержити їх у вхідні дані для наступного завдання.  Далі залишається тільки передати свій   Merger  у   setInputMerger .  Ось приклад свого   Merger :     public   class   MyMerger   extends   InputMerger   {\n   \n       @  Override\n       public   @  NonNull\n       Data   merge  (@  NonNull   List  \u003C  Data  >   inputs  ) {\n           Data  .  Builder   output   =   new   Data.  Builder  ();\n           Map  \u003C  String  ,   Object  > mergedValues   =   new   HashMap  \u003C>();\n   \n           for   (  Data   input   :   inputs) {\n               mergedValues.  putAll  (input.  getKeyValueMap  ());\n           }\n   \n           output.  putAll  (mergedValues);\n           output.  putInt  (  \"input_data_count\"  , inputs.  size  ()   -   1  );\n           return   output.  build  ();\n       }\n   \n   }\n  Код майже повністю повторює   OverwritingInputMerger .  Створюємо   Map  і в циклі складаємо в нього дані з усіх   Data , що надійшли. У разі збігу ключів, значення будуть перезаписані. Далі цей   Map  передаємо в білдер   output . І від себе додаємо ключ   input_data_count , у який поміщаємо кількість об'єктів   Data , що прийшли нам. Тим самим вхідні дані наступного завдання міститимуть кількість паралельно виконаних попередніх завдань.  Мінус 1 потрібен тому, що список, який йде на вхід методу merge, містить   Data , не тільки ті, що надійшли з попередніх завдань, а й   Data , задані в білдері WorkRequest (метод   setInputData ) завдання, яке використовує цей   Merger . Навіть якщо ми явно його не задавали, він існує і прийде порожній.  Готуємо список паралельних завдань:     List  \u003C  OneTimeWorkRequest  > workRequests   =   new   LinkedList  \u003C>();\n   workRequests.  add  (myWorkRequest1);\n   workRequests.  add  (myWorkRequest2);\n   workRequests.  add  (myWorkRequest3);\n  Задачі, яка отримуватиме результати, задаємо   MyMerger :     OneTimeWorkRequest   myWorkRequest4   =   new   OneTimeWorkRequest.  Builder  (MyWorker4.class)\n           .  setInputMerger  (MyMerger.class)\n           .  build  ();\n  Запускаємо це все:     WorkManager.  getInstance  ()\n           .  beginWith  (workRequests)\n           .  then  (myWorkRequest4)\n           .  enqueue  ();\n  І в   MyWorker4  отримуємо змерзлі дані та   count=3 .  Ну і наостанок опишу ще один випадок:     WorkManager.  getInstance  ()\n          .  beginWith  (myWorkRequest1, myWorkRequest2)\n          .  then  (myWorkRequest3, myWorkRequest4)\n          .  enqueue  ();\n  Після першої та другої задач запускаємо паралельно третю і четверту. У цьому випадку і в третю, і в четверту задачу надійдуть вхідні дані, отримані з першої та другої задач.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1182,"path":1183,"dir":1137,"title":1184,"description":1185,"keywords":1186,"body":1187},"content:1.android:10.lesson10:5.services.md","/android/lesson10/services","Коротко про сервіси Android","Сервіси являють собою особливу організацію програми. На відміну від activity вони не вимагають наявності візуального інтерфейсу. Сервіси дають змогу виконувати довготривалі завдання без втручання користувача.",[],"  Коротко про сервіси Android   Сервіси  являють собою особливу організацію програми. На відміну від activity вони не вимагають наявності візуального інтерфейсу. Сервіси дають змогу виконувати довготривалі завдання без втручання користувача.  Усі сервіси успадковуються від класу   Service  і проходять такі етапи життєвого циклу:    Метод onCreate() : викликається під час створення сервісу   Метод onStartCommand() : викликається при отриманні сервісом команди, відправленої за допомогою методу   startService()   Метод onBind() : викликається при закріпленні клієнта за сервісом за допомогою методу   bindService()  Метод   onDestroy() : викликається при завершенні роботи сервісу  Створимо найпростіший додаток із сервісом. Наш сервіс буде відтворювати музичний файл. І спочатку додамо в проєкт у каталог   res  папку   raw . Для цього натиснемо правою кнопкою миші на каталог   res  і в контекстному меню виберемо пункт   New -> Android Resource Directory .    Далі вкажемо як тип папки -   raw :\n   І помістимо в цю папку (  res/raw ) який-небудь   mp3 -файл.  Потім додамо новий клас сервісу. Назвемо його   MediaService . У підсумку вийде наступний проєкт:\n  \nДля відтворення аудіо-файлу визначимо в класі   MediaService  такий код:     package   com.example.soundserviceapp  ;\n    \n   import   android.app.Service  ;\n   import   android.content.Intent  ;\n   import   android.media.MediaPlayer  ;\n   import   android.os.IBinder  ;\n    \n   public   class   MediaService   extends   Service   {\n       MediaPlayer   ambientMediaPlayer;\n       @  Override\n       public   IBinder   onBind  (  Intent   intent  ) {\n    \n           throw   new   UnsupportedOperationException  (  \"Not yet implemented\"  );\n       }\n       @  Override\n       public   void   onCreate  (){\n           ambientMediaPlayer  =  MediaPlayer.  create  (  this  , R.raw.music);\n           ambientMediaPlayer.  setLooping  (  true  );\n       }\n       @  Override\n       public   int   onStartCommand  (  Intent   intent  ,   int   flags  ,   int   startId  ){\n           ambientMediaPlayer.  start  ();\n           return   START_STICKY;\n       }\n       @  Override\n       public   void   onDestroy  () {\n           ambientMediaPlayer.  stop  ();\n       }\n   }\n  Для відтворення музичного файлу сервіс використовуватиме компонент   MediaPlayer .  У сервісі перевизначаються всі чотири методи життєвого циклу. Але по суті метод   onBind()  не має жодної реалізації.  У методі   onCreate()  ініціалізується медіа-програвач за допомогою музичного ресурсу, який додано в папку   res/raw .  У методі   onStartCommand()  починається відтворення.  Метод   onStartCommand()  може повертати одне зі значень, яке передбачає різну поведінку в разі, якщо процес сервісу був несподівано завершений системою:    START_STICKY : у цьому разі сервіс знову повертається до запущеного стану, так, начебто якби знову був би викликаний метод onStartCommand() без передання в цей метод об'єкта Intent   START_REDELIVER_INTENT : у цьому разі сервіс знову повертається до запущеного стану, так, начебто якби знову було б викликано метод onStartCommand() з передачею в цей метод об'єкта Intent   START_NOT_STICKY : сервіс залишається в зупиненому положенні  Метод   onDestroy()  завершує відтворення.  Щоб керувати сервісом, змінимо activity. Спочатку додамо у файл   activity_main.xml  кілька кнопок для керування сервісом:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  Button\n           android:id  =  \"@+id/start\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Старт\"\n           android:onClick  =  \"click\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toLeftOf  =  \"@id/stop\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n       \u003C  Button\n           android:id  =  \"@+id/stop\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Стоп\"\n           android:onClick  =  \"click\"\n           app:layout_constraintLeft_toRightOf  =  \"@id/start\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  І змінимо код   MainActivity :     package   com.example.soundserviceapp  ;\n    \n   import   androidx.appcompat.app.AppCompatActivity  ;\n    \n   import   android.content.Intent  ;\n   import   android.os.Bundle  ;\n   import   android.view.View  ;\n    \n   public   class   MainActivity   extends   AppCompatActivity   {\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n    \n       public   void   click  (  View   v  ) {\n           Intent   i  =new   Intent  (  this  , MediaService.class);\n           if   (v.  getId  ()  ==  R.id.start) {\n               startService  (i);\n           }\n           else   {\n               stopService  (i);\n           }\n       }\n   }\n  Для запуску сервісу використовується об'єкт   Intent :     Intent   i  =new   Intent  (  this  , MediaService.class);\n  Для запуску сервісу в класі   Activity  визначено метод   startService() , у який передається об'єкт   Intent . Цей метод надсилатиме команду сервісу і викликатиме його метод   onStartCommand() , а також вказуватиме системі, що сервіс має продовжувати працювати доти, доки не буде викликано метод   stopService() .  Метод   stopService()  також визначений у класі Activity і приймає об'єкт   Intent . Він зупиняє роботу сервісу, викликаючи його метод   onDestroy()  І наприкінці нам треба зареєструвати сервіс у файлі маніфесту:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  manifest   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       package  =  \"com.example.soundserviceapp\"  >\n    \n       \u003C  application\n           android:allowBackup  =  \"true\"\n           android:icon  =  \"@mipmap/ic_launcher\"\n           android:label  =  \"@string/app_name\"\n           android:roundIcon  =  \"@mipmap/ic_launcher_round\"\n           android:supportsRtl  =  \"true\"\n           android:theme  =  \"@style/Theme.SoundServiceApp\"  >\n    \n           \u003C  service\n               android:name  =  \".MediaService\"\n               android:enabled  =  \"true\"\n               android:exported  =  \"true\"   >\n           \u003C/  service  >\n    \n           \u003C  activity   android:name  =  \".MainActivity\"  >\n               \u003C  intent-filter  >\n                   \u003C  action   android:name  =  \"android.intent.action.MAIN\"   />\n    \n                   \u003C  category   android:name  =  \"android.intent.category.LAUNCHER\"   />\n               \u003C/  intent-filter  >\n           \u003C/  activity  >\n       \u003C/  application  >\n    \n   \u003C/  manifest  >\n  Реєстрація сервісу проводиться у вузлі   application  за допомогою додавання елемента   \u003Cservice> . У ньому визначається атрибут   android:name , який зберігає назву класу сервісу. І крім того може приймати ще низку атрибутів:    android:enabled : якщо має значення   \"true\" , то сервіс може створюватися системою. Значення за замовчуванням -   \"true\" .   android:exported : вказує, чи можуть компоненти інших додатків звертатися до сервісу. Якщо має значення   \"true\" , то можуть, якщо має значення   \"false\" , то ні.   android:icon : значок сервісу, являє собою посилання на ресурс   drawable   android:isolatedProcess : якщо має значення   true , то сервіс може бути запущений як спеціальний процес, ізольований від решти системи.   android:label : назва сервісу, яка відображається користувачеві   android:permission : набір дозволів, які має застосовувати додаток для запуску сервісу   android:process : назва процесу, в якому запущено сервіс. Як правило, має ту саму назву, що й пакет застосунку.  Запустимо додаток і натиснемо на кнопку запуску сервісу:    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1189,"path":1190,"dir":1137,"title":1191,"description":1192,"keywords":1193,"body":1196},"content:1.android:10.lesson10:6.handler-intro.md","/android/lesson10/handler-intro","Handler. Трохи теорії. Наочний приклад використання","В Android до потоку (thread) може бути прив'язана черга повідомлень. Ми можемо поміщати туди повідомлення, а система буде за чергою стежити і відправляти повідомлення на обробку. При цьому ми можемо вказати, щоб повідомлення пішло на обробку не відразу, а через певну кількість часу.",[1194,1195],"Простий приклад","Приклад з більш змістовними повідомленнями","    Handler . Трохи теорії. Наочний приклад використання  В Android до потоку (thread) може бути прив'язана черга повідомлень. Ми можемо поміщати туди повідомлення, а система буде за чергою стежити і відправляти повідомлення на обробку. При цьому ми можемо вказати, щоб повідомлення пішло на обробку не відразу, а через певну кількість часу.   Handler  - це механізм, який дає змогу працювати з чергою повідомлень. Він прив'язаний до конкретного потоку (thread) і працює з його чергою.   Handler  вміє поміщати повідомлення в чергу. При цьому він ставить самого себе як одержувача цього повідомлення. І коли настає час, система дістає повідомлення з черги і відправляє його адресату (тобто в   Handler ) на обробку.   Handler  дає нам дві цікаві та корисні можливості:   реалізувати відкладене за часом виконання коду  виконання коду не у своєму потоці  У цьому уроці зробимо невеликий додаток. Він буде емулювати будь-яку довгу дію, наприклад закачування файлів і в   TextView  виводитиме кількість закачаних файлів. За допомогою цього прикладу ми побачимо, навіщо може бути потрібен   Handler .  strings.xml:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  resources  >\n       \u003C  string   name  =  \"app_name\"  >`Handler`\u003C/  string  >\n       \u003C  string   name  =  \"start\"  >Start\u003C/  string  >\n       \u003C  string   name  =  \"test\"  >Test\u003C/  string  >\n   \u003C/  resources  >\n  main.xml:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  LinearLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"fill_parent\"\n       android:layout_height  =  \"fill_parent\"\n       android:orientation  =  \"vertical\"  >\n       \u003C  ProgressBar\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:indeterminate  =  \"true\"  >\n       \u003C/  ProgressBar  >\n       \u003C  TextView\n           android:id  =  \"@+id/tvInfo\"\n           android:layout_width  =  \"fill_parent\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"\"  >\n       \u003C/  TextView  >\n       \u003C  Button\n           android:id  =  \"@+id/btnStart\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:onClick  =  \"onclick\"\n           android:text  =  \"@string/start\"  >\n       \u003C/  Button  >\n       \u003C  Button\n           android:id  =  \"@+id/btnTest\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:onClick  =  \"onclick\"\n           android:text  =  \"@string/test\"  >\n       \u003C/  Button  >\n   \u003C/  LinearLayout  >\n   ProgressBar  у нас буде крутитися завжди. Пізніше стане зрозуміло, навіщо.   TextView  - для виведення інформації про закачування файлів. Кнопка   Start  стартуватиме закачування. Кнопка   Test  буде просто виводити в лог слово   test .  Кодим   MainActivity.java :     public   class   MainActivity   extends   Activity   {\n    \n     final   String   LOG_TAG   =   \"myLogs\"  ;\n    \n     Handler   h;\n     TextView   tvInfo;\n     Button   btnStart;\n    \n     public   void   onCreate  (  Bundle   savedInstanceState  ) {\n       super  .  onCreate  (savedInstanceState);\n       setContentView  (R.layout.main);\n       tvInfo   =   (TextView)   findViewById  (R.id.tvInfo);\n     }\n    \n     public   void   onclick  (  View   v  ) {\n       switch   (v.  getId  ()) {\n       case   R.id.btnStart  :\n         for   (  int   i   =   1  ; i   \u003C=   10  ; i  ++  ) {\n           // довгий процес\n           downloadFile  ();\n           // оновлюємо TextView\n           tvInfo.  setText  (  \"Закачано файлов: \"   +   i);\n           // пишемо лог\n           Log.  d  (LOG_TAG,   \"Закачано файлов: \"   +   i);\n         }\n         break  ;\n       case   R.id.btnTest  :\n         Log.  d  (LOG_TAG,   \"test\"  );\n         break  ;\n       default:\n         break  ;\n       }\n     }\n    \n     void   downloadFile  () {\n       // пауза - 1 секунда\n       try   {\n         TimeUnit.SECONDS.  sleep  (  1  );\n       }   catch   (  InterruptedException   e  ) {\n         e.  printStackTrace  ();\n       }\n     }\n   }\n  В обробнику кнопки   Start  ми організуємо цикл для закачування файлів. У кожній ітерації циклу виконуємо метод   downloadFile  (який емулює закачування файлу), оновлюємо   TextView  і пишемо в лог інформацію про те, що кількість закачаних файлів змінилася. Разом у нас мають закачатися   10  файлів і після закачування кожного з них лог і екран мають показувати, скільки файлів уже закачано.  Після натискання кнопки   Test  - просто виводимо в лог повідомлення.   downloadFile  - емулює закачування файлу, це просто пауза в одну секунду.  Ми бачимо, що   ProgressBar  крутиться. Натискаємо на кнопку   Test , у логах з'являється   test . Усе гаразд, додаток відгукується на наші дії.  Якщо ми натиснемо кнопку   Start , то маємо спостерігати, як оновлюється   TextView  і пишеться лог після закачування чергового файлу. Але на ділі буде трохи не так. Наш застосунок просто \"зависне\" і перестане реагувати на натискання. Зупиниться   ProgressBar , не буде оновлюватися   TextView , і не буде натискатися кнопка   Test . Тобто UI (екран) для нас стане недоступним. І тільки за логами буде зрозуміло, що застосунок насправді працює і файли закачуються. Натисніть   Start  і переконайтеся.  Екран \"висить\", а логи йдуть. Щойно всі 10 файлів буде закачано, застосунок оживе і знову почне реагувати на ваші натискання.  А все чому? Тому що робота екрана забезпечується   основним потоком програми . А ми зайняли весь цей основний потік під свої потреби. У нашому випадку, начебто під закачування файлів. І щойно ми закінчили закачувати файли - потік звільнився, і екран став знову оновлюватися і реагувати на натискання.  Тут треба зрозуміти одну річ - основний потік програми відповідає за екран. Цей потік у жодному разі не можна вантажити чимось важким - екран просто перестає оновлюватися і реагувати на натискання. Якщо у вас є довгограючі завдання - їх треба винести в окремий потік. Спробуємо це зробити.  Перепишемо   onclick :     public   void   onclick  (  View   v) {\n     switch   (v.  getId  ()) {\n     case   R.id.btnStart  :\n       Thread   t   =   new   Thread  (  new   Runnable  () {\n         public   void   run  () {\n           for   (  int   i   =   1  ; i   \u003C=   10  ; i  ++  ) {\n             // довгий процес\n             downloadFile  ();\n             // оновлюємо TextView\n             tvInfo.  setText  (  \"Закачано файлов: \"   +   i);\n             // пишемо лог\n             Log.  d  (LOG_TAG,   \"i = \"   +   i);\n           }\n         }\n       });\n       t.  start  ();\n       break  ;\n     case   R.id.btnTest  :\n       Log.  d  (LOG_TAG,   \"test\"  );\n       break  ;\n     default:\n       break  ;\n     }\n   }\n  Тобто ми просто поміщаємо весь цикл у новий потік і запускаємо його. Тепер закачування файлів піде в цьому новому потоці. А основний потік буде не зайнятий і зможе без проблем промальовувати екран і реагувати на натискання. А отже, ми бачитимемо зміну   TextView  після кожного закачаного файлу і   ProgressBar , що крутиться. І, взагалі, зможемо повноцінно взаємодіяти з додатком. Здавалося б, ось воно щастя :)  Все збережемо і запустимо додаток. Тиснемо   Start .\n   Додаток вилетів із помилкою. Дивимося лог помилок у   LogCat . Там є рядки:   android.view.ViewRoot$CalledFromWrongThreadException: Лише оригінальний потік, який створив ієрархію подання, може торкатися її подань.  і   at com.arakviel.develop.p0801 Handler  .MainActivity$1.run(MainActivity.java:37)  Дивимося, що за код у нас у   MainActivity.java  в 37-му рядку:     tvInfo.  setText  (  \"Закачано файлів: \"   +   i);\n  При спробі виконати цей код (не в основному потоці) ми отримали помилку \"  Only the original thread that created a view hierarchy can touch its views\"  (\"Тільки оригінальний потік, який створив view-компоненти, може взаємодіяти з ними\"). Тобто робота з view-компонентами доступна тільки з основного потоку. А нові потоки, які ми створюємо, не мають доступу до елементів екрана.  Тобто з одного боку, не можна завантажувати основний потік важкими завданнями, щоб не \"вішався\" екран. З іншого боку - нові потоки, створені для виконання важких завдань, не мають доступу до екрана, і ми не зможемо з них показати користувачеві, що наше важке завдання якось рухається.  Тут нам допоможе   Handler . План такий:   ми створюємо в основному потоці   Handler  у потоці закачування файлів звертаємося до   Handler  і з його допомогою поміщаємо в чергу повідомлення для нього ж самого  система бере це повідомлення, бачить, що адресат -   Handler , і відправляє повідомлення на опрацювання в   Handler   Handler , отримавши повідомлення, оновить   TextView  Чим це відрізняється від нашої попередньої спроби оновити   TextView  з іншого потоку? Тим, що   Handler  був створений в основному потоці, і обробляти повідомлення, що надходять до нього, він буде в основному потоці, а отже, матиме доступ до екранних компонентів і зможе змінити текст у   TextView . Отримати доступ до   Handler  з будь-якого іншого потоку ми зможемо без проблем, оскільки основний потік монополізує тільки доступ до UI. А елементи класів (у нашому випадку це   Handler  у   MainActivity.java ) доступні в будь-яких потоках. Таким чином   Handler  виступить як   «міст»  між потоками.     public   void   onCreate  (  Bundle   savedInstanceState) {\n     super  .  onCreate  (savedInstanceState);\n     setContentView  (R.layout.main);\n     tvInfo   =   (TextView)   findViewById  (R.id.tvInfo);\n     btnStart   =   (Button)   findViewById  (R.id.btnStart);\n     h   =   new   Handler  () {\n       public   void   handleMessage  (  android  .  os  .  Message   msg  ) {\n         // оновлюємо TextView\n         tvInfo.  setText  (  \"Закачано файлов: \"   +   msg.what);\n         if   (msg.what   ==   10  ) btnStart.  setEnabled  (  true  );\n       };\n     };\n   }\n  Тут ми створюємо   Handler  і в ньому реалізуємо метод обробки повідомлень   handleMessage . Ми витягуємо з повідомлення атрибут   what  - це кількість закачаних файлів. Якщо вона дорівнює   10 , тобто всі файли закачані, ми активуємо кнопку   Start . (кількість закачаних файлів ми самі кладемо в повідомлення - зараз побачите, як)  Метод   onclick  перепишемо так:     public   void   onclick  (  View   v) {\n     switch   (v.  getId  ()) {\n     case   R.id.btnStart  :\n       btnStart.  setEnabled  (  false  );\n       Thread   t   =   new   Thread  (  new   Runnable  () {\n         public   void   run  () {\n           for   (  int   i   =   1  ; i   \u003C=   10  ; i  ++  ) {\n             // довгий процес\n             downloadFile  ();\n             h.  sendEmptyMessage  (i);\n             // пишемо лог\n             Log.  d  (LOG_TAG,   \"i = \"   +   i);\n           }\n         }\n       });\n       t.  start  ();\n       break  ;\n     case   R.id.btnTest  :\n       Log.  d  (LOG_TAG,   \"test\"  );\n       break  ;\n     default:\n       break  ;\n     }\n   }\n  Ми деактивуємо кнопку   Start  перед запуском закачування файлів. Це просто захист, щоб не можна було запустити кілька закачувань одночасно. А в процесі закачування, після кожного закачаного файлу, відправляємо (  sendEmptyMessage ) для   Handler  повідомлення з кількістю вже закачаних файлів.   Handler  це повідомлення прийме, витягне з нього кількість файлів і оновить   TextView .  Усе зберігаємо і запускаємо додаток. Тиснемо кнопку   Start .  Кнопка   Start  стала неактивною, оскільки ми її самі вимкнули. А   TextView  оновлюється,   ProgressBar  крутиться і кнопка   Test  натискається. Тобто і закачування файлів триває, і застосунок продовжує працювати без проблем, відображаючи статус закачування.  Коли всі файли закачаються, кнопка   Start  знову стане активною.  Підсумуємо все вищесказане.   Спочатку ми спробували вантажити додаток важким завданням в основному потоці. Це призвело до того, що ми втратили екран - він перестав оновлюватися і відповідати на натискання. Сталося це тому, що за екран відповідає основний потік програми, а він був сильно завантажений.  Ми створили окремий потік і виконали весь важкий код там. І це б спрацювало, але нам треба було оновлювати екран у процесі роботи. А з не основного потоку доступу до екрану немає.  Екран доступний тільки з основного потоку.  Ми створили   Handler  в основному потоці. А з нового потоку відправляли для   Handler  повідомлення, щоб він нам оновлював екран. У підсумку   Handler  допоміг нам оновлювати екран не з основного потоку.  Простий приклад  Як ми пам'ятаємо,   Handler  дає змогу класти в чергу повідомлення і сам же вміє їх обробляти. Фішка тут у тому, що покласти повідомлення він може з одного потоку, а прочитати з іншого.  Повідомлення може містити в собі   атрибути . Розглянемо найпростіший варіант, атрибут   what .  Напишемо простий додаток-клієнт. Він, начебто, буде підключатися до сервера, виконувати якусь роботу і відключатися. На екрані ми спостерігатимемо, як змінюється статус підключення і як крутиться   ProgressBar  під час підключення.  При змінах стану підключення ми будемо відправляти повідомлення для   Handler . А в атрибут   what  будемо класти поточний статус.   Handler  під час обробки повідомлення прочитає з нього   what  і виконає будь-які дії.   strings.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  resources  >\n       \u003C  string   name  =  \"app_name\"  >HandlerSimpleMessage\u003C/  string  >\n       \u003C  string   name  =  \"connect\"  >Connect\u003C/  string  >\n   \u003C/  resources  >\n  main.xml:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  LinearLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"fill_parent\"\n       android:layout_height  =  \"fill_parent\"\n       android:orientation  =  \"vertical\"  >\n       \u003C  Button\n           android:id  =  \"@+id/btnConnect\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:onClick  =  \"onclick\"\n           android:text  =  \"@string/connect\"  >\n       \u003C/  Button  >\n       \u003C  TextView\n           android:id  =  \"@+id/tvStatus\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"\"  >\n       \u003C/  TextView  >\n       \u003C  ProgressBar\n           android:id  =  \"@+id/pbConnect\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:indeterminate  =  \"true\"\n           android:visibility  =  \"gone\"  >\n       \u003C/  ProgressBar  >\n   \u003C/  LinearLayout  >\n  Кнопка для старту підключення,   TextView  для виведення інформації про статус підключення і   ProgressBar , що працює в процесі підключення.   MainActivity.java :     public   class   MainActivity   extends   Activity   {\n    \n     final   String   LOG_TAG   =   \"myLogs\"  ;\n    \n     final   int   STATUS_NONE   =   0  ;\n     final   int   STATUS_CONNECTING   =   1  ;\n     final   int   STATUS_CONNECTED   =   2  ;\n    \n     Handler   h;\n    \n     TextView   tvStatus;\n     ProgressBar   pbConnect;\n     Button   btnConnect;\n   \n     public   void   onCreate  (  Bundle   savedInstanceState  ) {\n       super  .  onCreate  (savedInstanceState);\n       setContentView  (R.layout.main);\n    \n       tvStatus   =   (TextView)   findViewById  (R.id.tvStatus);\n       pbConnect   =   (ProgressBar)   findViewById  (R.id.pbConnect);\n       btnConnect   =   (Button)   findViewById  (R.id.btnConnect);\n    \n       h   =   new   Handler  () {\n         public   void   handleMessage  (  android  .  os  .  Message   msg  ) {\n           switch   (msg.what) {\n           case   STATUS_NONE  :\n             btnConnect.  setEnabled  (  true  );\n             tvStatus.  setText  (  \"Not connected\"  );\n             break  ;\n           case   STATUS_CONNECTING  :\n             btnConnect.  setEnabled  (  false  );\n             pbConnect.  setVisibility  (View.VISIBLE);\n             tvStatus.  setText  (  \"Connecting\"  );\n             break  ;\n           case   STATUS_CONNECTED  :\n             pbConnect.  setVisibility  (View.GONE);\n             tvStatus.  setText  (  \"Connected\"  );\n             break  ;\n           }\n         };\n       };\n       h.  sendEmptyMessage  (STATUS_NONE);\n     }\n    \n     public   void   onclick  (  View   v  ) {\n       Thread   t   =   new   Thread  (  new   Runnable  () {\n         public   void   run  () {\n           try   {\n             // встановлюємо підключення\n             h.  sendEmptyMessage  (STATUS_CONNECTING);\n             TimeUnit.SECONDS.  sleep  (  2  );\n    \n             // встановлено\n             h.  sendEmptyMessage  (STATUS_CONNECTED);\n    \n             // виконується якась робота\n             TimeUnit.SECONDS.  sleep  (  3  );\n    \n             // розриваємо підключення\n             h.  sendEmptyMessage  (STATUS_NONE);\n    \n           }   catch   (  InterruptedException   e  ) {\n             e.  printStackTrace  ();\n           }\n         }\n       });\n       t.  start  ();\n     }\n    \n   }\n   STATUS_NONE ,   STATUS_CONNECTING ,   STATUS_CONNECTED  - це константи статусу. Їх будемо передавати в повідомленні, в атрибуті   what . Зрозуміло, назви і значення цих констант довільні і взяті з голови. Ви можете придумати і використовувати свої.  В   onCreate  ми створюємо   Handler  і реалізуємо його метод   handleMessage . Цей метод відповідає за обробку повідомлень, які призначені для цього   Handler . Відповідно на вхід методу йде повідомлення -   Message . Ми читаємо атрибут   what  і залежно від статусу підключення змінюємо екран:    STATUS_NONE  - немає підключення. Кнопка підключення активна,   TextView  відображає статус підключення.   STATUS_CONNECTING  - у процесі підключення. Кнопка підключення неактивна, показуємо   ProgressBar ,   TextView  відображає статус підключення.   STATUS_CONNECTED  - підключено. Приховуємо   ProgressBar ,   TextView  відображає статус підключення.  В   onCreate  після створення   Handler  ми відразу відправляємо йому повідомлення зі статусом   STATUS_NONE . Для цього ми використовуємо метод   sendEmptyMessage . У цьому методі створюється повідомлення, заповнюється його атрибут   what  (значенням, яке ми передаємо в   sendEmptyMessage ), встановлюється   Handler  як адресат і повідомлення надсилається в чергу.  У методі   onclick  ми створюємо і запускаємо новий потік. У ньому ми, за допомогою   sleep , емулюємо процес під'єднання до сервера, виконання роботи і вимкнення. І, в міру виконання дій, відправляємо повідомлення зі статусами для   Handler . Тобто виходить, що після натискання на кнопку   Connect  статус змінюється на   STATUS_CONNECTING , дві секунди йде підключення, статус змінюється на   STATUS_CONNECTED ,   3  секунди виконуються дії і статус змінюється на   STATUS_NONE . Давайте перевіримо.  Усе збережемо і запустимо застосунок.  Тобто для простого оновлення статусу з нового потоку нам вистачило атрибута   what . Але крім   what  повідомлення може мати ще кілька атрибутів.  Приклад з більш змістовними повідомленнями  Ми використовували метод   sendEmptyMessage . Цей метод сам створював повідомлення   Message , заповнював його атрибут   what  і відправляв у чергу. Крім   what  у повідомлення є ще атрибути   arg1  і   arg2  типу   int , і   obj  типу   Object . У цьому уроці ми самі створюватимемо повідомлення, заповнюватимемо атрибути та відправлятимемо.  Створимо застосунок, який буде підключатися до сервера, запитувати кількість файлів, готових для завантаження, емулювати завантаження і відображати на екрані перебіг дій, використовуючи горизонтальний   ProgressBar  і   TextView .   strings.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  resources  >\n       \u003C  string   name  =  \"app_name\"  >HandlerAdvMessage\u003C/  string  >\n       \u003C  string   name  =  \"connect\"  >Connect\u003C/  string  >\n   \u003C/  resources  >\n   main.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  LinearLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"fill_parent\"\n       android:layout_height  =  \"fill_parent\"\n       android:orientation  =  \"vertical\"  >\n       \u003C  Button\n           android:id  =  \"@+id/btnConnect\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:onClick  =  \"onclick\"\n           android:text  =  \"@string/connect\"  >\n       \u003C/  Button  >\n       \u003C  TextView\n           android:id  =  \"@+id/tvStatus\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"\"  >\n       \u003C/  TextView  >\n       \u003C  ProgressBar\n           android:id  =  \"@+id/pbDownload\"\n           style  =  \"?android:attr/progressBarStyleHorizontal\"\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"wrap_content\"\n           android:visibility  =  \"gone\"  >\n       \u003C/  ProgressBar  >\n   \u003C/  LinearLayout  >\n   MainActivity.java :     public   class   MainActivity   extends   Activity   {\n    \n     final   String   LOG_TAG   =   \"myLogs\"  ;\n    \n     final   int   STATUS_NONE   =   0  ;   // нет подключения\n     final   int   STATUS_CONNECTING   =   1  ;   // подключаемся\n     final   int   STATUS_CONNECTED   =   2  ;   // подключено\n     final   int   STATUS_DOWNLOAD_START   =   3  ;   // загрузка началась\n     final   int   STATUS_DOWNLOAD_FILE   =   4  ;   // файл загружен\n     final   int   STATUS_DOWNLOAD_END   =   5  ;   // загрузка закончена\n     final   int   STATUS_DOWNLOAD_NONE   =   6  ;   // нет файлов для загрузки\n    \n     Handler   h;\n    \n     TextView   tvStatus;\n     ProgressBar   pbDownload;\n     Button   btnConnect;\n    \n     public   void   onCreate  (  Bundle   savedInstanceState  ) {\n       super  .  onCreate  (savedInstanceState);\n       setContentView  (R.layout.main);\n    \n       tvStatus   =   (TextView)   findViewById  (R.id.tvStatus);\n       pbDownload   =   (ProgressBar)   findViewById  (R.id.pbDownload);\n       btnConnect   =   (Button)   findViewById  (R.id.btnConnect);\n    \n       h   =   new   Handler  () {\n         public   void   handleMessage  (  android  .  os  .  Message   msg  ) {\n           switch   (msg.what) {\n           case   STATUS_NONE  :\n             btnConnect.  setEnabled  (  true  );\n             tvStatus.  setText  (  \"Not connected\"  );\n             pbDownload.  setVisibility  (View.GONE);\n             break  ;\n           case   STATUS_CONNECTING  :\n             btnConnect.  setEnabled  (  false  );\n             tvStatus.  setText  (  \"Connecting\"  );\n             break  ;\n           case   STATUS_CONNECTED  :\n             tvStatus.  setText  (  \"Connected\"  );\n             break  ;\n           case   STATUS_DOWNLOAD_START  :\n             tvStatus.  setText  (  \"Start download \"   +   msg.arg1   +   \" files\"  );\n             pbDownload.  setMax  (msg.arg1);\n             pbDownload.  setProgress  (  0  );\n             pbDownload.  setVisibility  (View.VISIBLE);\n             break  ;\n           case   STATUS_DOWNLOAD_FILE  :\n             tvStatus.  setText  (  \"Downloading. Left \"   +   msg.arg2   +   \" files\"  );\n             pbDownload.  setProgress  (msg.arg1);\n             saveFile  ((  byte  []) msg.obj);\n             break  ;\n           case   STATUS_DOWNLOAD_END  :\n             tvStatus.  setText  (  \"Download complete!\"  );\n             break  ;\n           case   STATUS_DOWNLOAD_NONE  :\n             tvStatus.  setText  (  \"No files for download\"  );\n             break  ;\n           }\n         };\n       };\n       h.  sendEmptyMessage  (STATUS_NONE);\n     }\n    \n     public   void   onclick  (  View   v  ) {\n    \n       Thread   t   =   new   Thread  (  new   Runnable  () {\n         Message   msg;\n         byte  [] file;\n         Random   rand   =   new   Random  ();\n    \n         public   void   run  () {\n           try   {\n             // встановлюємо підключення\n             h.  sendEmptyMessage  (STATUS_CONNECTING);\n             TimeUnit.SECONDS.  sleep  (  1  );\n    \n             // підключення встановлено\n             h.  sendEmptyMessage  (STATUS_CONNECTED);\n    \n             // визначаємо кількість файлів\n             TimeUnit.SECONDS.  sleep  (  1  );\n             int   filesCount   =   rand.  nextInt  (  5  );\n    \n             if   (filesCount   ==   0  ) {\n               // повідомляємо, що файлів для завантаження немає\n               h.  sendEmptyMessage  (STATUS_DOWNLOAD_NONE);\n               // і відключаємося\n               TimeUnit.MILLISECONDS.  sleep  (  1500  );\n               h.  sendEmptyMessage  (STATUS_NONE);\n               return  ;\n             }\n    \n             // завантаження починається\n             // створюємо повідомлення, з інформацією про кількість файлів\n             msg   =   h.  obtainMessage  (STATUS_DOWNLOAD_START, filesCount,   0  );\n             // відправляємо\n             h.  sendMessage  (msg);\n    \n             for   (  int   i   =   1  ; i   \u003C=   filesCount; i  ++  ) {\n               // завантажується файл\n               file   =   downloadFile  ();\n               // створюємо повідомлення з інформацією про порядковий номер\n               // файла,\n               // кількістю тих, що залишилися, і самим файлом\n               msg   =   h.  obtainMessage  (STATUS_DOWNLOAD_FILE, i,\n                   filesCount   -   i, file);\n               // відправляємо\n               h.  sendMessage  (msg);\n             }\n    \n             // завантаження завершено\n             h.  sendEmptyMessage  (STATUS_DOWNLOAD_END);\n    \n             // відключаємося\n             TimeUnit.MILLISECONDS.  sleep  (  1500  );\n             h.  sendEmptyMessage  (STATUS_NONE);\n    \n           }   catch   (  InterruptedException   e  ) {\n             e.  printStackTrace  ();\n           }\n         }\n       });\n       t.  start  ();\n     }\n    \n     byte  []   downloadFile  ()   throws   InterruptedException   {\n       TimeUnit.SECONDS.  sleep  (  2  );\n       return   new   byte  [  1024  ];\n     }\n    \n     void   saveFile  (  byte  []   file  ) {\n    \n     }\n    \n   }\n  В   onCreate  ми створюємо   Handler  і в його методі обробки (  handleMessage ) прописуємо всю логіку зміни екрана залежно від повідомлень, які надходять. Не буду детально це розписувати, там усе просто - змінюємо текст, вмикаємо/вимикаємо кнопку, показуємо/прикриваємо   ProgressBar , змінюємо значення   ProgressBar . З цікавого тут варто зазначити, що читаємо ми цього разу не тільки   what , а й інші атрибути повідомлення -   arg1 ,   arg2 ,   obj . А як вони заповнюються, побачимо далі.  В   onclick  створюємо новий потік для завантаження файлів. Встановлюємо підключення, отримуємо кількість готових для завантаження файлів. Якщо файлів для завантаження немає, надсилаємо відповідне повідомлення в   Handler  і відключаємося. Якщо ж файли є, ми створюємо повідомлення   Message  за допомогою методу    getMessage  (  int   what,   int   arg1,   int   arg2) . Він приймає на вхід атрибути   what ,   arg1  і   arg2 . У   what  ми кладемо статус, в   arg1  - кількість файлів,   arg2  - не потрібен, там просто нуль.  Далі починаємо завантаження. Після завантаження кожного файлу ми створюємо повідомлення   Message  за допомогою методу    getMessage  (  int   what,   int   arg1,   int   arg2,   Object   obj) , заповнюємо його атрибути:   what  - статус,   arg1  - порядковий номер файлу,   arg2  - к-ть файлів, що залишилися,   obj  - файл. І відправляємо.  По завершенню завантаження відправляємо відповідне повідомлення і відключаємося.    downloadFile  - емулює завантаження файлу. чекає дві секунди і повертає масив із 1024 байтів.   saveFile  - метод збереження файлу на диск. Просто заглушка. Нічого не робить.  Все зберігаємо і запускаємо. Тиснемо   Connect .  Використовуючи різні атрибути крім   what , ми змогли передати в основний потік і використовувати там більш різноманітні дані.  Ми створюємо повідомлення за допомогою різних реалізацій методу   getMessage . А чому б не створювати безпосередньо об'єкт   Message  за допомогою його конструкторів? У принципі можна, але офіційний хелп рекомендує користуватися методами   getMessage , тому що це ефективніше і швидше. У цьому випадку повідомлення дістається з глобального пулу повідомлень, а не створюється з нуля.   Тут  ви можете подивитися всі реалізації методу   getMessage  для формування повідомлень і використовувати той, який підходить для ситуації. Вони різняться різними комбінаціями вхідних параметрів.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1198,"path":1199,"dir":1137,"title":1200,"description":1201,"keywords":1202,"body":1206},"content:1.android:10.lesson10:7.handler-extend.md","/android/lesson10/handler-extend","Handler. Відкладені повідомлення, видалення з черги, Handler.Callback","Ми відправляли повідомлення в чергу, а система відразу ж діставала їх і перенаправляла в Handler на обробку. Але ми можемо налаштувати повідомлення так, щоб система відправила його на обробку не відразу, а із затримкою. Для цього використовуються методи sendEmptyMessageDelayed (якщо використовуєте тільки what) і sendMessageDelayed (повне повідомлення). У них ми можемо вказати паузу в мілісекундах. Система вичекає цю паузу і тільки потім відправить повідомлення в Handler.",[1203,1204,1205],"Обробка Runnable","Ще кілька способів виконання коду в UI-потоці","Доповнення до AsyncTask","  Handler. Відкладені повідомлення, видалення з черги, Handler.Callback  Ми відправляли повідомлення в чергу, а система відразу ж діставала їх і перенаправляла в   Handler  на обробку. Але ми можемо налаштувати повідомлення так, щоб система відправила його на обробку не відразу, а із затримкою. Для цього використовуються методи   sendEmptyMessageDelayed  (якщо використовуєте тільки   what ) і   sendMessageDelayed  (повне повідомлення). У них ми можемо вказати паузу в мілісекундах. Система вичекає цю паузу і тільки потім відправить повідомлення в   Handler .  Якщо раптом помістили таке відкладене повідомлення в чергу, а потім вирішили, що воно не повинно піти на обробку, то його можна з черги видалити. Для цього використовується метод   removeMessages .  Ми створювали свій   Handler , і в його методі   handleMessage  кодили свій алгоритм обробки повідомлень. Крім цього способу   Handler  також може використовувати для обробки повідомлень об'єкт, що реалізує інтерфейс   Handler.Callback . В інтерфейсу всього один метод   handleMessage  - у ньому і прописуємо всю логіку обробки повідомлень.     public   class   MainActivity   extends   Activity   {\n    \n     final   String   LOG_TAG   =   \"myLogs\"  ;\n    \n     Handler   h;\n    \n     Handler  .  Callback   hc   =   new   Handler.  Callback  () {\n       public   boolean   handleMessage  (  Message   msg) {\n         Log.  d  (LOG_TAG,   \"what = \"   +   msg.what);\n         return   false  ;\n       }\n     };\n   \n     public   void   onCreate  (  Bundle   savedInstanceState  ) {\n       super  .  onCreate  (savedInstanceState);\n       setContentView  (R.layout.main);\n    \n       h   =   new   Handler  (hc);\n       sendMessages  ();\n     }\n    \n     void   sendMessages  () {\n       Log.  d  (LOG_TAG,   \"send messages\"  );\n       h.  sendEmptyMessageDelayed  (  1  ,   1000  );\n       h.  sendEmptyMessageDelayed  (  2  ,   2000  );\n       h.  sendEmptyMessageDelayed  (  3  ,   3000  );\n     }\n   }\n  Ми створюємо об'єкт   hc  типу   Handler.Callback . У нього є метод   handleMessage , в якому ми будемо обробляти повідомлення. У нашому випадку просто читаємо атрибут   what  і виводимо значення в лог.  В   onCreate  створюємо   handler , використовуючи конструктор    Handler  (Handler.Callback callback) . На вхід передаємо створений раніше   hc . І тепер   Handler  оброблятиме повідомлення не сам, а передоручить це об'єкту   hc . Далі ми виконуємо метод   sendMessages  , який кладе три повідомлення в чергу повідомлень. Для цього використовується метод   sendEmptyMessageDelayed . Це аналог знайомого нам методу   sendEmptyMessage  з минулого уроку. Він теж заповнює в повідомленні тільки атрибут   what , але при цьому він дає змогу вказати затримку в обробці повідомлення. Тобто повідомлення буде витягнуто з черги і відправлено на обробку через зазначену кількість мілісекунд.  Отже, ми поміщаємо три повідомлення:    what = 1, обробка через 1000 мс.   what = 2, обробка через 2000 мс.   what = 3, обробка через 3000 мс.  Зауважу, що відлік затримки починається після поміщення в чергу, а не після обробки попереднього повідомлення. Тобто ці повідомлення по відношенню одне до одного спрацюють з інтервалом в одну секунду.  Усе збережемо і запустимо застосунок. У логах один за одним з'являтимуться записи:     10:21:07.759:   D/myLogs  (  332  )  :   send   messages\n   10:21:08.786:   D/myLogs  (  332  )  :   what   =   1\n   10:21:09.765:   D/myLogs  (  332  )  :   what   =   2\n   10:21:10.776:   D/myLogs  (  332  )  :   what   =   3\n  Зверніть увагу на час цих записів. Перший спрацьовує через   1000  мс після поміщення в чергу (  send messages ), другий - через дві секунди, третій - через три.  Тепер спробуємо видалити повідомлення з черги. Перепишемо метод   sendMessages :     void   sendMessages  () {\n     h.  sendEmptyMessageDelayed  (  1  ,   1000  );\n     h.  sendEmptyMessageDelayed  (  2  ,   2000  );\n     h.  sendEmptyMessageDelayed  (  3  ,   3000  );\n     h.  removeMessages  (  2  );\n   }\n  Використовуємо метод   removeMessages , у якому вказуємо значення атрибута   what . Цей метод знаходить у черзі повідомлення з атрибутом   what , що дорівнює   2 , і видаляє його з черги.  Усе зберігаємо, запускаємо додаток. Дивимося лог:     10:24:49.916:   D/myLogs  (  434  )  :   send   messages\n   10:24:50.927:   D/myLogs  (  434  )  :   what   =   1\n   10:24:52.948:   D/myLogs  (  434  )  :   what   =   3\n  Як бачимо, повідомлення з   what = 2  не спрацювало.  А якщо буде кілька повідомлень з однаковим значенням   what ? Система видалить перше-ліпше чи всі?  Перевіримо. Перепишемо   sendMessages :     void   sendMessages  () {\n     Log.  d  (LOG_TAG,   \"send messages\"  );\n     h.  sendEmptyMessageDelayed  (  1  ,   1000  );\n     h.  sendEmptyMessageDelayed  (  2  ,   2000  );\n     h.  sendEmptyMessageDelayed  (  3  ,   3000  );\n     h.  sendEmptyMessageDelayed  (  2  ,   4000  );\n     h.  sendEmptyMessageDelayed  (  5  ,   5000  );\n     h.  sendEmptyMessageDelayed  (  2  ,   6000  );\n     h.  sendEmptyMessageDelayed  (  7  ,   7000  );\n     h.  removeMessages  (  2  );\n   }\n  Будемо поміщати в чергу купу повідомлень. З них кілька з   what = 2 . Перевіримо, які видалить система.  Запускаємо додаток і дивимося лог:     10:29:23.297:   D/myLogs  (  467  )  :   send   messages\n   10:29:24.372:   D/myLogs  (  467  )  :   what   =   1\n   10:29:26.307:   D/myLogs  (  467  )  :   what   =   3\n   10:29:28.364:   D/myLogs  (  467  )  :   what   =   5\n   10:29:30.332:   D/myLogs  (  467  )  :   what   =   7\n  Усі повідомлення з   what = 2  було видалено. Не забувайте це. А то захочете видалити одне останнє повідомлення, а система знайде всі відповідні, які очікують на обробку, і знесе їх.  У методу   removeMessages  є ще реалізація з використанням   obj . Тут усе так само, тільки система шукає для видалення з черги повідомлення із зазначеними атрибутами   what  і   obj .  Якщо хочете запланувати повноцінне повідомлення, а не просто   what , то використовуйте метод   sendMessageDelayed  - на вхід даєте повідомлення і вказуєте затримку обробки.  Є ще методи   sendEmptyMessageAtTime  і   sendMessageAtTime . Вони теж дають змогу вказати затримку обробки. Але ця затримка буде відрахована від часу останнього старту системи, а не від часу поміщення в чергу. Якщо повідомлення виявиться простроченим на момент поміщення в чергу, воно виконується відразу.  Обробка Runnable  Крім обробки повідомлень, ми можемо попросити   Handler  виконати шматок коду -   Runnable . Ми працювали з повідомленнями, які містили   атрибути . Ми їх обробляли в   Handler  і залежно від значень атрибутів виконували ті чи інші дії.   Runnable  же - це шматок коду, який ми надішлемо замість атрибутів повідомлення, і він буде виконаний у потоці, з яким працює   Handler . Нам уже нічого не треба обробляти.  Для відправлення коду в роботу використовується метод   post . Як і повідомлення, Runnable може бути виконаний із затримкою (  postDelayed ), і може бути вилучений з черги (  removeCallbacks ). Напишемо додаток, який продемонструє всі ці можливості.   strings.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  resources  >\n       \u003C  string   name  =  \"app_name\"  >HandlerRunnable\u003C/  string  >\n       \u003C  string   name  =  \"info\"  >Подробно\u003C/  string  >\n   \u003C/  resources  >\n   main.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  LinearLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:layout_width  =  \"fill_parent\"\n       android:layout_height  =  \"fill_parent\"\n       android:orientation  =  \"vertical\"  >\n       \u003C  ProgressBar\n           android:id  =  \"@+id/pbCount\"\n           style  =  \"?android:attr/progressBarStyleHorizontal\"\n           android:layout_width  =  \"match_parent\"\n           android:layout_height  =  \"wrap_content\"\n           android:layout_marginTop  =  \"20dp\"  >\n       \u003C/  ProgressBar  >\n       \u003C  CheckBox\n           android:id  =  \"@+id/chbInfo\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"@string/info\"  >\n       \u003C/  CheckBox  >\n       \u003C  TextView\n           android:id  =  \"@+id/tvInfo\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"\"\n           android:visibility  =  \"gone\"  >\n       \u003C/  TextView  >\n   \u003C/  LinearLayout  >\n   ProgressBar , що відображає поточний прогрес.   CheckBox , який вмикатиме відображення додаткової інформації в   TextView .   MainActivity.java :     public   class   MainActivity   extends   Activity   {\n    \n     ProgressBar   pbCount;\n     TextView   tvInfo;\n     CheckBox   chbInfo;\n     int   cnt;\n    \n     final   String   LOG_TAG   =   \"myLogs\"  ;\n     final   int   max   =   100  ;\n    \n     Handler   h;\n   \n     public   void   onCreate  (  Bundle   savedInstanceState  ) {\n       super  .  onCreate  (savedInstanceState);\n       setContentView  (R.layout.main);\n    \n       h   =   new   Handler  ();\n    \n       pbCount   =   (ProgressBar)   findViewById  (R.id.pbCount);\n       pbCount.  setMax  (max);\n       pbCount.  setProgress  (  0  );\n    \n       tvInfo   =   (TextView)   findViewById  (R.id.tvInfo);\n    \n       chbInfo   =   (CheckBox)   findViewById  (R.id.chbInfo);\n       chbInfo.  setOnCheckedChangeListener  (  new   OnCheckedChangeListener  () {\n         public   void   onCheckedChanged  (  CompoundButton   buttonView  ,\n             boolean   isChecked  ) {\n           if   (isChecked) {\n             tvInfo.  setVisibility  (View.VISIBLE);\n             // показуємо інформацію\n             h.  post  (showInfo);\n           }   else   {\n             tvInfo.  setVisibility  (View.GONE);\n             // скасовуємо показ інформації\n             h.  removeCallbacks  (showInfo);\n           }\n         }\n       });\n    \n       Thread   t   =   new   Thread  (  new   Runnable  () {\n         public   void   run  () {\n           try   {\n             for   (cnt   =   1  ; cnt   \u003C   max; cnt  ++  ) {\n               TimeUnit.MILLISECONDS.  sleep  (  100  );\n               // оновлюємо ProgressBar\n               h.  post  (updateProgress);\n             }\n           }   catch   (  InterruptedException   e  ) {\n             e.  printStackTrace  ();\n           }\n         }\n       });\n       t.  start  ();\n    \n     }\n    \n     // оновлення ProgressBar\n     Runnable   updateProgress   =   new   Runnable  () {\n       public   void   run  () {\n         pbCount.  setProgress  (cnt);\n       }\n     };\n    \n     // показ інформації\n     Runnable   showInfo   =   new   Runnable  () {\n       public   void   run  () {\n         Log.  d  (LOG_TAG,   \"showInfo\"  );\n         tvInfo.  setText  (  \"Count = \"   +   cnt);\n         // планує сам себе через 1000 мсек\n         h.  postDelayed  (showInfo,   1000  );\n       }\n     };\n   }\n  В   onCreate  ми прописуємо обробник для   CheckBox . У разі ввімкнення прапорця відображається   TextView  і в роботу відправляється завдання showInfo. У разі вимкнення прапорця - завдання   showInfo  видаляється з черги.  Далі в новому потоці емулюємо будь-яку дію - запускаємо лічильник із паузами. У кожній ітерації циклу відправляємо в роботу завдання   updateProgress , яке оновлює   ProgressBar .    updateProgress  - код, який оновлює значення   ProgressBar .   showInfo  - код, який оновлює   TextView  і сам себе планує на виконання через   1000  мсек. Тобто ми вмикаємо   CheckBox ,   showInfo  спрацьовує перший раз і саме себе планує на наступний раз. Тобто цей код лежить у черзі повідомлень, обробляється і знову кладе себе туди. Так триває, поки ми явно його не видалимо з черги (  removeCallbacks ), вимкнувши   CheckBox .  Будемо виводити що-небудь у лог із   showInfo , щоб побачити, коли він працює, а коли ні.  Ще кілька способів виконання коду в UI-потоці  Ми детально розглянули   Handler  і побачили, що він вміє. Головна його перевага - це вміння виконувати код в UI-потоці. Існує ще пара способів виконувати   Runnable  в UI-потоці. Це методи:     Activity.  runOnUiThread  (Runnable)    View.  post  (Runnable)    View.  postDelayed  (Runnable,   long  )  Перші два схожі і відправляють   Runnable  на негайну обробку. А третій метод дозволяє вказати затримку виконання   Runnable .  main.xml:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  LinearLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       android:id  =  \"@+id/llMain\"\n       android:layout_width  =  \"fill_parent\"\n       android:layout_height  =  \"fill_parent\"\n       android:orientation  =  \"vertical\"  >\n       \u003C  TextView\n           android:id  =  \"@+id/tvInfo\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"\"  >\n       \u003C/  TextView  >\n   \u003C/  LinearLayout  >\n   TextView , яке будемо оновлювати з нового потоку.     public   class   MainActivity   extends   Activity   {\n    \n     final   String   LOG_TAG   =   \"myLogs\"  ;\n    \n     TextView   tvInfo;\n    \n     /** Called when the activity is first created. */\n     public   void   onCreate  (  Bundle   savedInstanceState  ) {\n       super  .  onCreate  (savedInstanceState);\n       setContentView  (R.layout.main);\n    \n       tvInfo   =   (TextView)   findViewById  (R.id.tvInfo);\n    \n       Thread   t   =   new   Thread  (  new   Runnable  () {\n         public   void   run  () {\n           try   {\n             TimeUnit.SECONDS.  sleep  (  2  );\n             runOnUiThread  (runn1);\n             TimeUnit.SECONDS.  sleep  (  1  );\n             tvInfo.  postDelayed  (runn3,   2000  );\n             tvInfo.  post  (runn2);\n           }   catch   (  InterruptedException   e  ) {\n             e.  printStackTrace  ();\n           }\n         }\n       });\n       t.  start  ();\n     }\n    \n     Runnable   runn1   =   new   Runnable  () {\n       public   void   run  () {\n         tvInfo.  setText  (  \"runn1\"  );\n       }\n     };\n    \n     Runnable   runn2   =   new   Runnable  () {\n       public   void   run  () {\n         tvInfo.  setText  (  \"runn2\"  );\n       }\n     };\n    \n     Runnable   runn3   =   new   Runnable  () {\n       public   void   run  () {\n         tvInfo.  setText  (  \"runn3\"  );\n       }\n     };\n   }\n  В   onCreate  створюємо новий потік. У ньому ми через паузи виконуємо   runn1  і   runn2 , і плануємо   runn3  із затримкою у   2000  мсек, використовуючи вищезгадані методи.   runn1 ,   runn2  і   runn3  - це просто   Runnable , які оновлюють текст у   TextView . Вони повинні бути виконані в UI-потоці.  Тим самим, якщо ваші алгоритми не особливо складні, можна використовувати ці методи для виконання коду в UI-потоці. Якщо ж потрібні навороти й алгоритм досить складний, то використовуємо   Handler .  Доповнення до AsyncTask  Ми вводили їх в окремий потік і використовували   Handler  для зворотного зв'язку та оновлення екрана. Творці Android вирішили, що ці механізми варто виділити в окремий клас -   AsyncTask . Тобто його мета - це виконання важких завдань і передача в UI-потік результатів роботи. Але при цьому нам не треба замислюватися про створення   Handler  і нового потоку.`  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1208,"path":1209,"dir":1137,"title":1210,"description":1211,"keywords":1212,"body":1214},"content:1.android:10.lesson10:8.working-with-contacts.md","/android/lesson10/working-with-contacts","Провайдери контенту","Наш додаток може зберігати різноманітну інформацію про користувача, якісь пов'язані дані у файлах чи налаштуваннях. Однак ОС Android уже зберігає низку важливої інформації, пов'язаної з користувачем, до якої маємо доступ і яку ми можемо використовувати. Це і списки контактів, і файли збережених зображень та відеоматеріалів, і якісь позначки про дзвінки тощо, тобто певний контент. А для доступу до цього контенту в OC Android визначені провайдери контенту (content provider)",[1213],"Робота з контактами","  Провайдери контенту  Наш додаток може зберігати різноманітну інформацію про користувача, якісь пов'язані дані у файлах чи налаштуваннях. Однак ОС Android уже зберігає низку важливої інформації, пов'язаної з користувачем, до якої маємо доступ і яку ми можемо використовувати. Це і   списки контактів , і   файли збережених зображень  та   відеоматеріалів , і якісь   позначки про дзвінки  тощо, тобто певний контент. А для доступу до цього контенту в OC Android визначені провайдери контенту (  content provider )  В Android є такі вбудовані провайдери, визначені в пакеті   android.content :    AlarmClock : управління будильником   Browser : історія браузера та закладки   CalendarContract : каледар та інформація про події   CallLog : інформація про дзвінки   ContactsContract : контакти   MediaStore : медіа-файли   SearchRecentSuggestions : підказки щодо пошуку   Settings : системні налаштування   UserDictionary : словник слів, які використовуються для швидкого набору   VoicemailContract : записи голосової пошти  Робота з контактами  Контакти в Android мають вбудований API, який дозволяє отримувати і змінювати список контактів. Усі контакти зберігаються в базі даних SQLite, однак вони не становлять єдиної таблиці. Для контактів відведено три таблиці, пов'язаних відношенням один-до-багатьої: таблиця для зберігання інформації про людей, таблиця їхніх телефонів і таблиця адрес їхніх електронних пошт. Але завдяки Android API ми можемо абстрагуватися від зв'язків між таблицями.  Загальна форма отримання контактів має такий вигляд:     ArrayList  \u003C  String  > contacts   =   new   ArrayList  \u003C  String  >();\n   ContentResolver   contentResolver   =   getContentResolver  ();\n   Cursor   cursor   =   contentResolver.  query  (ContactsContract.Contacts.CONTENT_URI,   null  ,   null  ,   null  ,   null  );\n   if  (cursor  !=  null  ) {\n       while   (cursor.  moveToNext  ()) {\n    \n           // отримуємо кожен контакт\n           String   contact   =   cursor.  getString  (cursor.  getColumnIndex  (ContactsContract.Contacts.DISPLAY_NAME_PRIMARY));\n           // додаємо контакт до списку\n           contacts.  add  (contact);\n       }\n       cursor.  close  ();\n   }\n  Усі контакти та супутній функціонал зберігаються в спеціальних базах даних SQLite. Але нам не треба безпосередньо працювати з ними. Ми можемо скористатися об'єктом класу   Cursor . Щоб його отримати, спочатку викликається метод   getContentResolver() , який повертає об'єкт   ContentResolver . Потім по ланцюжку викликається метод   query() . У цей метод передається низка параметрів, перший з яких представляє   URI  - ресурс, який ми хочемо отримати. Для звернення до бази даних контактів використовується константа   ContactsContract.Contacts.CONTENT_URI  Метод   contactsCursor.moveToNext()  дає змогу послідовно переміщатися по записах контактів, зчитуючи по одному контакту через виклик   contactsCursor.getString() .  Таким чином, отримувати контакти не складно. Головна складність у роботі з контактами, та й з будь-якими іншими провайдерами контенту, полягає у встановленні дозволів. До Android API 23 достатньо було встановити відповідний дозвіл у файлі маніфесту додатка. Починаючи ж з API 23 (  Android Marshmallow ) Google змінив схему роботи з дозволами. І тепер користувач сам повинен вирішити, чи буде він давати дозволи додатку. У зв'язку з чим розробники повинні додавати додатковий код.  Отже, для доступу до контактів нам треба встановити дозвіл   android.permission.READ_CONTACTS  у файлі маніфесту додатка:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  manifest   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       package  =  \"com.example.contactsapp\"  >\n        \n       \u003C  uses-permission   android:name  =  \"android.permission.READ_CONTACTS\"    />\n        \n       \u003C  application\n           android:allowBackup  =  \"true\"\n           android:icon  =  \"@mipmap/ic_launcher\"\n           android:label  =  \"@string/app_name\"\n           android:roundIcon  =  \"@mipmap/ic_launcher_round\"\n           android:supportsRtl  =  \"true\"\n           android:theme  =  \"@style/Theme.ContactsApp\"  >\n           \u003C  activity   android:name  =  \".MainActivity\"  >\n               \u003C  intent-filter  >\n                   \u003C  action   android:name  =  \"android.intent.action.MAIN\"   />\n    \n                   \u003C  category   android:name  =  \"android.intent.category.LAUNCHER\"   />\n               \u003C/  intent-filter  >\n           \u003C/  activity  >\n       \u003C/  application  >\n    \n   \u003C/  manifest  >\n  Для виведення списку контактів у файлі   activity_main.xml  визначимо таку розмітку інтерфейсу:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  TextView\n           android:id  =  \"@+id/header\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Контакты\"\n           android:textSize  =  \"18sp\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/contactList\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n       \u003C  ListView\n           android:id  =  \"@+id/contactList\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/header\"   />\n        \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Для виведення списку контактів скористаємося елементом   ListView . І в класі   MainActivity  отримаємо контакти:     public   class   MainActivity   extends   AppCompatActivity   {\n    \n       private   static   final   int   REQUEST_CODE_READ_CONTACTS  =  1  ;\n       private   static   boolean   READ_CONTACTS_GRANTED   =  false  ;\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n           // отримуємо дозволи\n           int   hasReadContactPermission   =   ContextCompat.  checkSelfPermission  (  this  , Manifest.permission.READ_CONTACTS);\n           // якщо пристрій до API 23, встановлюємо роздільну здатність\n           if  (hasReadContactPermission   ==   PackageManager.PERMISSION_GRANTED){\n               READ_CONTACTS_GRANTED   =   true  ;\n           }\n           else  {\n               // викликаємо діалогове вікно для встановлення дозволів\n               ActivityCompat.  requestPermissions  (  this  ,   new   String  []{Manifest.permission.READ_CONTACTS}, REQUEST_CODE_READ_CONTACTS);\n           }\n           // якщо дозвіл встановлено, завантажуємо контакти\n           if   (READ_CONTACTS_GRANTED){\n               loadContacts  ();\n           }\n       }\n    \n       @  Override\n       public   void   onRequestPermissionsResult  (  int   requestCode  ,   String  []   permissions  ,   int  []   grantResults  ){\n    \n           super  .  onRequestPermissionsResult  (requestCode, permissions, grantResults);\n            \n           if   (requestCode   ==   REQUEST_CODE_READ_CONTACTS) {\n               if   (grantResults.length   >   0   &&   grantResults[  0  ]   ==   PackageManager.PERMISSION_GRANTED) {\n                   READ_CONTACTS_GRANTED   =   true  ;\n               }\n           }\n           if  (READ_CONTACTS_GRANTED){\n               loadContacts  ();\n           }\n           else  {\n               Toast.  makeText  (  this  ,   \"Потрібно встановити дозволи\"  , Toast.LENGTH_LONG).  show  ();\n           }\n       }\n    \n       private   void   loadContacts  (){\n           ContentResolver   contentResolver   =   getContentResolver  ();\n           Cursor   cursor   =   contentResolver.  query  (ContactsContract.Contacts.CONTENT_URI,   null  ,   null  ,   null  ,   null  );\n           ArrayList  \u003C  String  > contacts   =   new   ArrayList  \u003C  String  >();\n    \n           if  (cursor  !=  null  ){\n               while   (cursor.  moveToNext  ()) {\n    \n                   // отримуємо кожен контакт\n                   String   contact   =   cursor.  getString  (\n                           cursor.  getColumnIndex  (ContactsContract.Contacts.DISPLAY_NAME_PRIMARY));\n                   // додаємо контакт до списку\n                   contacts.  add  (contact);\n               }\n               cursor.  close  ();\n           }\n    \n           // створюємо адаптер\n           ArrayAdapter  \u003C  String  > adapter   =   new   ArrayAdapter  \u003C>(  this  ,\n                   android.R.layout.simple_list_item_1, contacts);\n    \n           ListView   contactList   =   findViewById  (R.id.contactList);\n           // встановлюємо для списку адаптер\n           contactList.  setAdapter  (adapter);\n       }\n   }\n  Крім власне завантаження контактів і передавання їх через адаптер   ArrayAdapter  у список   ListView  тут додано багато коду з управління дозволами. Спочатку визначено змінну   READ_CONTACTS_GRANTED , яка вказує, чи було видано дозвіл. І тут є два варіанти дій.  Перший варіант передбачає, що пристрій має версію Android, нижчу за   Marshmallow  (нижче API 23). Для цього ми просто дізнаємося, чи є дозвіл для   READ_CONTACTS  і якщо він є, то встановлюємо для змінної   READ_CONTACTS_GRANTED  значення   true :     int   hasReadContactPermission   =   ContextCompat.  checkSelfPermission  (  this  , Manifest.permission.READ_CONTACTS);\n   if  (hasReadContactPermission   ==   PackageManager.PERMISSION_GRANTED){\n       READ_CONTACTS_GRANTED   =   true  ;\n   }\n  Інакше нам треба відобразити користувачеві діалогове вікно, де він має вирішити, чи треба дати додатку дозвіл:     ActivityCompat.  requestPermissions  (  this  , \n                                   new   String  []{Manifest.permission.READ_CONTACTS}, \n                                   REQUEST_CODE_READ_CONTACTS);\n  У цей метод передаються три параметри. Перший - поточний контекст, тобто поточний об'єкт   Activity .  Другий параметр представляє набір дозволів, які треба отримати, у вигляді масиву рядків. Нам треба отримати в даному випадку тільки один дозвіл -   Manifest.permission.READ_CONTACTS .  Третій параметр представляє код запиту, через який ми зможемо отримати відповідь користувача.  Якщо ми хочемо отримати вибір користувача під час встановлення дозволів, то нам треба перевизначити в класі   Activity  метод   onRequestPermissionsResult :     public   void   onRequestPermissionsResult  (  int   requestCode,   String  [] permissions,   int  [] grantResults){\n    \n       super  .  onRequestPermissionsResult  (requestCode, permissions, grantResults);\n        \n       if   (requestCode   ==   REQUEST_CODE_READ_CONTACTS) {\n           if   (grantResults.length   >   0   &&   grantResults[  0  ]   ==   PackageManager.PERMISSION_GRANTED) {\n               READ_CONTACTS_GRANTED   =   true  ;\n           }\n       }\n       if  (READ_CONTACTS_GRANTED){\n           loadContacts  ();\n       }\n       else  {\n           Toast.  makeText  (  this  ,   \"Потрібно встановити дозволи\"  , Toast.LENGTH_LONG).  show  ();\n       }\n   }\n  Перший параметр методу   requestCode  - це той код запиту, який передавався як третій параметр в   ActivityCompat.requestPermissions() . Другий параметр - масив рядків, для яких встановлювалися дозволи. Тобто одномоментно ми можемо встановлювати відразу кілька дозволів.  Третій параметр власне зберігає числові коди дозволів. Оскільки ми запитуємо тільки один дозвіл, то перший елемент масиву буде зберігати його код. Через умовний вираз ми можемо перевірити цей код:   grantResults[0] == PackageManager.PERMISSION_GRANTED . І залежно від результату перевірки змінити змінну   READ_CONTACTS_GRANTED .  І під час запуску програми нам спочатку відобразиться вікно для видачі дозволу, а після видачі підтверджень - список контактів:    Після видачі дозволу під час повторних запусків застосунку повторювати дозвіл не потрібно, тому метод   onRequestPermissionsResult()  у такому разі спрацьовуватиме тільки один раз. А змінна   READ_CONTACTS_GRANTED  у цьому випадку вже матиме значення   true .  Інша ситуація - якщо ми відхилимо дозвіл. У цьому разі під час повторного запуску застосунку повторно відображатиметься це вікно.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1216,"path":1217,"dir":1137,"title":1218,"description":1219,"keywords":1220,"body":1221},"content:1.android:10.lesson10:9.add-conctacts.md","/android/lesson10/add-conctacts","Додавання контактів","Продовжимо роботу з проектом з минулої теми і додамо в нього можливість додавання нових контактів. Додавання контактів являє собою запит на зміну списку контактів, тобто його запис. Тому нам треба встановити відповідний дозвіл у файлі маніфесту. Візьмемо проєкт із минулої теми і додамо в нього у файл AndroidManifest.xml дозвіл android.permission.WRITE_CONTACTS:",[],"  Додавання контактів  Продовжимо роботу з проектом з минулої теми і додамо в нього можливість додавання нових контактів. Додавання контактів являє собою запит на зміну списку контактів, тобто його запис. Тому нам треба встановити відповідний дозвіл у файлі маніфесту. Візьмемо проєкт із минулої теми і додамо в нього у файл   AndroidManifest.xml  дозвіл   android.permission.WRITE_CONTACTS :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  manifest   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       package  =  \"com.example.contactsapp\"  >\n        \n       \u003C  uses-permission   android:name  =  \"android.permission.READ_CONTACTS\"    />\n       \u003C  uses-permission   android:name  =  \"android.permission.WRITE_CONTACTS\"   />\n        \n       \u003C  application\n           android:allowBackup  =  \"true\"\n           android:icon  =  \"@mipmap/ic_launcher\"\n           android:label  =  \"@string/app_name\"\n           android:roundIcon  =  \"@mipmap/ic_launcher_round\"\n           android:supportsRtl  =  \"true\"\n           android:theme  =  \"@style/Theme.ContactsApp\"  >\n           \u003C  activity   android:name  =  \".MainActivity\"  >\n               \u003C  intent-filter  >\n                   \u003C  action   android:name  =  \"android.intent.action.MAIN\"   />\n    \n                   \u003C  category   android:name  =  \"android.intent.category.LAUNCHER\"   />\n               \u003C/  intent-filter  >\n           \u003C/  activity  >\n       \u003C/  application  >\n    \n   \u003C/  manifest  >\n  Для додавання контакту додамо змінимо файл   activity_main.xml , визначивши в ньому текстове поле для введення даних:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"  >\n    \n       \u003C  EditText\n           android:id  =  \"@+id/newContact\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/header\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toLeftOf  =  \"@id/addBtn\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n       \u003C  Button\n           android:id  =  \"@+id/addBtn\"\n           android:text  =  \"Add\"\n           android:layout_width  =  \"wrap_content\"\n           android:layout_height  =  \"wrap_content\"\n           android:onClick  =  \"onAddContact\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/header\"\n           app:layout_constraintLeft_toRightOf  =  \"@id/newContact\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n       \u003C  TextView\n           android:id  =  \"@+id/header\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Контакты\"\n           android:textSize  =  \"18sp\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/contactList\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/newContact\"   />\n    \n       \u003C  ListView\n           android:id  =  \"@+id/contactList\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"0dp\"\n           app:layout_constraintBottom_toBottomOf  =  \"parent\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@+id/header\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  У коді   MainActivity  пропишемо обробник   onAddContact  із додаванням контакту:     public   class   MainActivity   extends   AppCompatActivity   {\n    \n       private   static   final   int   REQUEST_CODE_READ_CONTACTS  =  1  ;\n       private   static   boolean   READ_CONTACTS_GRANTED   =  false  ;\n       ArrayList  \u003C  String  > contacts   =   new   ArrayList  \u003C>();\n       Button   addBtn;\n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n    \n           addBtn   =   findViewById  (R.id.addBtn);\n           // отримуємо дозволи\n           int   hasReadContactPermission   =   ContextCompat.  checkSelfPermission  (  this  , Manifest.permission.READ_CONTACTS);\n           // якщо пристрій до API 23, встановлюємо роздільну здатність\n           if  (hasReadContactPermission   ==   PackageManager.PERMISSION_GRANTED){\n               READ_CONTACTS_GRANTED   =   true  ;\n           }\n           else  {\n               // викликаємо діалогове вікно для встановлення дозволів\n               ActivityCompat.  requestPermissions  (  this  ,   new   String  []{Manifest.permission.READ_CONTACTS, Manifest.permission.WRITE_CONTACTS}, REQUEST_CODE_READ_CONTACTS);\n           }\n           // якщо дозвіл встановлено, завантажуємо контакти\n           if   (READ_CONTACTS_GRANTED){\n               loadContacts  ();\n           }\n    \n           addBtn.  setEnabled  (READ_CONTACTS_GRANTED);\n       }\n    \n       @  Override\n       public   void   onRequestPermissionsResult  (  int   requestCode  , @  NonNull   String  []   permissions  , @  NonNull   int  []   grantResults  ){\n    \n           super  .  onRequestPermissionsResult  (requestCode, permissions, grantResults);\n            \n           if   (requestCode   ==   REQUEST_CODE_READ_CONTACTS) {\n               if   (grantResults.length   >   0   &&   grantResults[  0  ]   ==   PackageManager.PERMISSION_GRANTED) {\n                   READ_CONTACTS_GRANTED   =   true  ;\n               }\n               addBtn.  setEnabled  (READ_CONTACTS_GRANTED);\n           }\n           if  (READ_CONTACTS_GRANTED){\n               loadContacts  ();\n           }\n           else  {\n               Toast.  makeText  (  this  ,   \"Потрібно встановити дозволи\"  , Toast.LENGTH_LONG).  show  ();\n           }\n       }\n       public   void   onAddContact  (  View   v  ) {\n           ContentValues   contactValues   =   new   ContentValues  ();\n           EditText   contactText   =   findViewById  (R.id.  new  Contact);\n           String   newContact   =   contactText.  getText  ().  toString  ();\n           contactText.  setText  (  \"\"  );\n           contactValues.  put  (ContactsContract.RawContacts.ACCOUNT_NAME, newContact);\n           contactValues.  put  (ContactsContract.RawContacts.ACCOUNT_TYPE, newContact);\n           Uri   newUri   =   getContentResolver  ().  insert  (ContactsContract.RawContacts.CONTENT_URI, contactValues);\n           long   rawContactsId   =   ContentUris.  parseId  (newUri);\n           contactValues.  clear  ();\n           contactValues.  put  (ContactsContract.Data.RAW_CONTACT_ID, rawContactsId);\n           contactValues.  put  (ContactsContract.Data.MIMETYPE, ContactsContract.CommonDataKinds.StructuredName.CONTENT_ITEM_TYPE);\n           contactValues.  put  (ContactsContract.CommonDataKinds.StructuredName.DISPLAY_NAME, newContact);\n           getContentResolver  ().  insert  (ContactsContract.Data.CONTENT_URI, contactValues);\n           Toast.  makeText  (  getApplicationContext  (), newContact   +   \" добавлен в список контактов\"  , Toast.LENGTH_LONG).  show  ();\n           loadContacts  ();\n       }\n       private   void   loadContacts  (){\n           contacts.  clear  ();\n           ContentResolver   contentResolver   =   getContentResolver  ();\n           Cursor   cursor   =   contentResolver.  query  (ContactsContract.Contacts.CONTENT_URI,   null  ,   null  ,   null  ,   null  );\n           if  (cursor  !=  null  ){\n               while   (cursor.  moveToNext  ()) {\n    \n                   // отримуємо кожен контакт\n                   String   contact   =   cursor.  getString  (\n                           cursor.  getColumnIndex  (ContactsContract.Contacts.DISPLAY_NAME_PRIMARY));\n                   // додаємо контакт до списку\n                   contacts.  add  (contact);\n               }\n               cursor.  close  ();\n           }\n           // створюємо адаптер\n           ArrayAdapter  \u003C  String  > adapter   =   new   ArrayAdapter  \u003C>(  this  ,\n                   android.R.layout.simple_list_item_1, contacts);\n           // встановлюємо для списку адаптер\n           ListView   contactList   =   findViewById  (R.id.contactList);\n           contactList.  setAdapter  (adapter);\n       }\n   }\n  Одразу варто зазначити, що для роботи з контактами не треба окремо отримувати дозволи на читання і окремо на зміну контактів. Користувач один раз дає згоду для встановлення одразу двох дозволів. Однак на рівні коду нам необхідно перерахувати через кому встановлювані дозволи:     // викликаємо діалогове вікно для встановлення дозволів\n   ActivityCompat.  requestPermissions  (  this  ,   new   String  []{\n           Manifest.permission.READ_CONTACTS, \n           Manifest.permission.WRITE_CONTACTS\n       }, \n       REQUEST_CODE_READ_CONTACTS);\n  Однак ми знову ж таки можемо керувати дозволом, наприклад, встановити доступність кнопки:     addBtn.  setEnabled  (READ_CONTACTS_GRANTED);\n  Якщо дозвіл не отримано, то змінна   READ_CONTACTS_GRANTED  матиме значення   false , і відповідно кнопка буде недоступна, і ми не зможемо додати новий контакт.  Весь код додавання знаходиться в обробнику натискання кнопки   onAddContact . В Android контакти розподіляються за трьома таблицями:   contacts ,   raw contacts  і   data . І нам треба додати новий контакт у дві останні таблиці. У таблицю   contact  через налаштування ми додати не можемо, але це й не потрібно.  Дані контакту представляють об'єкт   ContentValues , який складається з ключів та їхніх значень, тобто об'єкт словника. Після його створення відбувається додавання в нього пари елементів:     contactValues.  put  (RawContacts.ACCOUNT_NAME, newContact);\n   contactValues.  put  (RawContacts.ACCOUNT_TYPE, newContact);\n  Тут встановлюється назва і тип контакту. Як ключі виставляються значення   RawContacts.ACCOUNT_NAME  і   RawContacts.ACCOUNT_TYPE , а як їхні значення - текст із текстового поля.  Далі цей об'єкт додається в таблицю   RawContacts  за допомогою методу   insert() :     Uri   newUri   =   getContentResolver  ().  insert  (RawContacts.CONTENT_URI, contactValues);\n  Метод   insert()  повертає   URI  - посилання на доданий об'єкт у таблиці, у якого ми можемо отримати   id . Потім після очищення ми готуємо об'єкт для доабвления в таблицю   Data , знову наповнюючи його даними:     contactValues.  put  (Data.RAW_CONTACT_ID, rawContactsId);\n   contactValues.  put  (Data.MIMETYPE, StructuredName.CONTENT_ITEM_TYPE);\n   contactValues.  put  (StructuredName.DISPLAY_NAME, newContact);\n  І знову додавання здійснює метод   insert() :     getContentResolver  ().  insert  (Data.CONTENT_URI, contactValues);\n  Перед запуском, якщо раніше (у минулій темі) застосунок було встановлено, то його необхідно видалити, щоб встановити для застосунку нові дозволи (дозвіл на запис контактів).  Запустимо додаток і додамо новий контакт:\n   html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1223,"path":1224,"dir":1137,"title":1225,"description":7,"keywords":1226,"body":1235},"content:1.android:10.lesson10:10.create-content-provider.md","/android/lesson10/create-content-provider","Створення провайдера контенту",[1227,1228,1229,1230,1231,1232,1233,1228,1229,1231,1230,1234],"Визначення контракту","Отримання даних","Додавання даних","Видалення даних","Оновлення даних","AndroidManifest","Використання провайдера","Асинхронне завантаження даних","  Створення провайдера контенту  Визначення контракту   Контент-провайдери  (content providers) дають змогу звертатися одним додаткам до даних інших додатків. І ми також можемо зробити, щоб інші додатки могли звертатися до даних нашого додатка через деякий API. Для цього нам треба створити свій контент-провайдер. Розглянемо як це зробити.  Спочатку додамо в проєкт клас   FriendsContract , який буде описувати основні значення, стовпці, адреси   uri , використовувані в контент-провайдері.     public   class   FriendsContract   {\n    \n       static   final   String   TABLE_NAME   =   \"friends\"  ;\n       static   final   String   CONTENT_AUTHORITY   =   \"com.example.friendsprovider\"  ;\n       static   final   Uri   CONTENT_AUTHORITY_URI   =   Uri.  parse  (  \"content://\"   +   CONTENT_AUTHORITY);\n    \n       static   final   String   CONTENT_TYPE   =   \"vnd.android.cursor.dir/vnd.\"   +   CONTENT_AUTHORITY   +   \".\"   +   TABLE_NAME;\n       static   final   String   CONTENT_ITEM_TYPE  =   \"vnd.android.cursor.item/vnd.\"   +   CONTENT_AUTHORITY   +   \".\"   +   TABLE_NAME;\n    \n       public   static   class   Columns  {\n           public   static   final   String   _ID   =   \"_id\"  ;\n           public   static   final   String   NAME   =   \"Name\"  ;\n           public   static   final   String   EMAIL   =   \"Email\"  ;\n           public   static   final   String   PHONE   =   \"Phone\"  ;\n    \n           private   Columns  (){\n    \n           }\n       }\n       static   final   Uri   CONTENT_URI   =   Uri.  withAppendedPath  (CONTENT_AUTHORITY_URI, TABLE_NAME);\n       // створює uri за допомогою id\n       static   Uri   buildFriendUri  (  long   taskId  ){\n           return   ContentUris.  withAppendedId  (CONTENT_URI, taskId);\n       }\n       // отримує id з uri\n       static   long   getFriendId  (  Uri   uri  ){\n           return   ContentUris.  parseId  (uri);\n       }\n    \n   }\n  За допомогою константи   TABLE_NAME  визначається ім'я таблиці, до якої відбуватиметься звернення. А вкладений статичний клас   Columns  описує стовпці цієї таблиці. Тобто таблиця називатиметься   \"friends\" , а стовпці -   \"_id\" ,   \"Name\" ,   \"Email\" ,   \"Phone\" . Тобто, умовно кажучи, у таблиці зберігатимуться дані про друзів - ім'я, електронна адреса та номер телефону.  Константа   CONTENT_AUTHORITY  описує назву контент-провайдера. Тобто в моєму випадку провайдер називатиметься   \"com.example.friendsprovider\" . За допомогою імені провайдера створюється константа   CONTENT_AUTHORITY_URI  - універсальний локатор або своєрідний шлях, через який ми звертатимемося до провайдера під час виконання з ним різних операцій.  Також клас визначає дві константи   CONTENT_TYPE  і CONTENT_ITEM_TYPE, які визначають тип вмісту, що повертається. Тут є два варіанти: повернення набору даних і повернення одного об'єкта. Значення, що визначає набір даних, будується за принципом   \"vnd.android.cursor.dir/vnd.[name].[table]\" , де як   [name]  зазвичай виступає глобально унікальний ідентифікатор, наприклад, назва провайдера або ім'я пакета провайдера. А як   [type] , як правило, використовується ім'я таблиці. За схожою схемою будується друге значення, тільки замість   \"dir\"  ставиться   \"item\" .  Також у класі визначається допоміжна константа   CONTENT_URI , яка описує шлях для доступу до таблиці   friends . І також визначаємо два допоміжних методи:   buildFriendUri()  (повертає   uri  для доступу до об'єкта за певним   id ) і   getFriendId  (для вилучення   id  з переданого шляху   uri ).  Далі додамо в проєкт новий клас   AppDatabase :     public   class   AppDatabase   extends   SQLiteOpenHelper   {\n    \n       public   static   final   String   DATABASE_NAME   =   \"friends.db\"  ;\n       public   static   final   int   DATABASE_VERSION   =   1  ;\n    \n       private   static   AppDatabase   instance   =   null  ;\n    \n       private   AppDatabase  (  Context   context  ){\n           super  (context, DATABASE_NAME,   null  , DATABASE_VERSION);\n       }\n    \n       static   AppDatabase   getInstance  (  Context   context  ){\n           if  (instance   ==   null  ){\n               instance   =   new   AppDatabase  (context);\n           }\n           return   instance;\n       }\n   \n       @  Override\n       public   void   onCreate  (  SQLiteDatabase   db  ) {\n    \n           String   sql   =   \"CREATE TABLE \"   +   FriendsContract.TABLE_NAME   +   \"(\"   +\n                   FriendsContract.Columns._ID   +   \" INTEGER PRIMARY KEY NOT NULL, \"   +\n                   FriendsContract.Columns.NAME   +   \" TEXT NOT NULL, \"   +\n                   FriendsContract.Columns.EMAIL   +   \" TEXT, \"   +\n                   FriendsContract.Columns.PHONE   +   \" TEXT NOT NULL)\"  ;\n           db.  execSQL  (sql);\n    \n           // додавання початкових даних\n           db.  execSQL  (  \"INSERT INTO \"  +   FriendsContract.TABLE_NAME   +  \" (\"   +   FriendsContract.Columns.NAME\n                   +   \", \"   +   FriendsContract.Columns.PHONE    +   \") VALUES ('Tom', '+12345678990');\"  );\n           db.  execSQL  (  \"INSERT INTO \"  +   FriendsContract.TABLE_NAME   +  \" (\"   +   FriendsContract.Columns.NAME\n                   +   \", \"   +   FriendsContract.Columns.EMAIL    +   \", \"   +   FriendsContract.Columns.PHONE   +\n                   \" ) VALUES ('Bob', 'bob@gmail.com', '+13456789102');\"  );\n       }\n    \n       @  Override\n       public   void   onUpgrade  (  SQLiteDatabase   db  ,   int   oldVersion  ,   int   newVersion  ) {\n    \n       }\n   }\n  Цей клас за патерном синглтона організовує доступ до бази даних і, крім того, створює саму базу даних і додає в неї початкові дані.  Додамо в проєкт, клас   AppProvider , який власне і буде представляти провайдер контенту:     public   class   AppProvider   extends   ContentProvider   {\n    \n       private   AppDatabase   mOpenHelper;\n       private   static   final   UriMatcher   sUriMatcher   =   buildUriMatcher  ();\n    \n       public   static   final   int   FRIENDS   =   100  ;\n       public   static   final   int   FRIENDS_ID   =   101  ;\n    \n       private   static   UriMatcher   buildUriMatcher  () {\n           final   UriMatcher   matcher   =   new   UriMatcher  (UriMatcher.NO_MATCH);\n           // content://com.example.friendsprovider/FRIENDS\n           matcher.  addURI  (FriendsContract.CONTENT_AUTHORITY, FriendsContract.TABLE_NAME, FRIENDS);\n           // content://com.example.friendsprovider/FRIENDS/8\n           matcher.  addURI  (FriendsContract.CONTENT_AUTHORITY, FriendsContract.TABLE_NAME   +   \"/#\"  , FRIENDS_ID);\n           return   matcher;\n       }\n    \n       @  Override\n       public   boolean   onCreate  () {\n           mOpenHelper   =   AppDatabase.  getInstance  (  getContext  ());\n           return   true  ;\n       }\n    \n       @  Nullable\n       @  Override\n       public   Cursor   query  (@  NonNull   Uri   uri  , @  Nullable   String  []   projection  , @  Nullable   String   selection  , @  Nullable   String  []   selectionArgs  , @  Nullable   String   sortOrder  ) {\n           final   int   match   =   sUriMatcher.  match  (uri);\n           SQLiteQueryBuilder   queryBuilder   =   new   SQLiteQueryBuilder  ();\n           switch  (match) {\n               case   FRIENDS  :\n                   queryBuilder.  setTables  (FriendsContract.TABLE_NAME);\n                   break  ;\n               case   FRIENDS_ID  :\n                   queryBuilder.  setTables  (FriendsContract.TABLE_NAME);\n                   long   taskId   =   FriendsContract.  getFriendId  (uri);\n                   queryBuilder.  appendWhere  (FriendsContract.Columns._ID   +   \" = \"   +   taskId);\n                   break  ;\n               default:\n                   throw   new   IllegalArgumentException  (  \"Unknown URI: \"  +   uri);\n           }\n           SQLiteDatabase   db   =   mOpenHelper.  getReadableDatabase  ();\n           return   queryBuilder.  query  (db, projection, selection, selectionArgs,   null  ,   null  , sortOrder);\n       }\n    \n       @  Nullable\n       @  Override\n       public   String   getType  (@  NonNull   Uri   uri  ) {\n    \n           final   int   match   =   sUriMatcher.  match  (uri);\n           switch  (match){\n               case   FRIENDS  :\n                   return   FriendsContract.CONTENT_TYPE;\n               case   FRIENDS_ID  :\n                   return   FriendsContract.CONTENT_ITEM_TYPE;\n               default:\n                   throw   new   IllegalArgumentException  (  \"Unknown URI: \"  +   uri);\n           }\n       }\n    \n       @  Nullable\n       @  Override\n       public   Uri   insert  (@  NonNull   Uri   uri  , @  Nullable   ContentValues   values  ) {\n    \n           final   int   match   =   sUriMatcher.  match  (uri);\n           final   SQLiteDatabase   db;\n           Uri   returnUri;\n           long   recordId;\n    \n           if   (match   ==   FRIENDS) {\n               db   =   mOpenHelper.  getWritableDatabase  ();\n               recordId   =   db.  insert  (FriendsContract.TABLE_NAME,   null  , values);\n               if   (recordId   >   0  ) {\n                   returnUri   =   FriendsContract.  buildFriendUri  (recordId);\n               }   else   {\n                   throw   new   SQLException  (  \"Failed to insert: \"   +   uri.  toString  ());\n               }\n           }   else   {\n               throw   new   IllegalArgumentException  (  \"Unknown URI: \"   +   uri);\n           }\n           return   returnUri;\n       }\n    \n       @  Override\n       public   int   delete  (@  NonNull   Uri   uri  , @  Nullable   String   selection  , @  Nullable   String  []   selectionArgs  ) {\n           final   int   match   =   sUriMatcher.  match  (uri);\n           final   SQLiteDatabase   db   =   mOpenHelper.  getWritableDatabase  ();\n    \n           String   selectionCriteria   =   selection;\n    \n           if  (match   !=   FRIENDS   &&   match   !=   FRIENDS_ID)\n               throw   new   IllegalArgumentException  (  \"Unknown URI: \"  +   uri);\n    \n           if  (match  ==  FRIENDS_ID) {\n               long   taskId   =   FriendsContract.  getFriendId  (uri);\n               selectionCriteria   =   FriendsContract.Columns._ID   +   \" = \"   +   taskId;\n               if   ((selection   !=   null  )   &&   (selection.  length  ()   >   0  )) {\n                   selectionCriteria   +=   \" AND (\"   +   selection   +   \")\"  ;\n               }\n           }\n           return   db.  delete  (FriendsContract.TABLE_NAME, selectionCriteria, selectionArgs);\n       }\n    \n       @  Override\n       public   int   update  (@  NonNull   Uri   uri  , @  Nullable   ContentValues   values  , @  Nullable   String   selection  , @  Nullable   String  []   selectionArgs  ) {\n    \n           final   int   match   =   sUriMatcher.  match  (uri);\n           final   SQLiteDatabase   db   =   mOpenHelper.  getWritableDatabase  ();\n           String   selectionCriteria   =   selection;\n    \n           if  (match   !=   FRIENDS   &&   match   !=   FRIENDS_ID)\n               throw   new   IllegalArgumentException  (  \"Unknown URI: \"  +   uri);\n    \n           if  (match  ==  FRIENDS_ID) {\n               long   taskId   =   FriendsContract.  getFriendId  (uri);\n               selectionCriteria   =   FriendsContract.Columns._ID   +   \" = \"   +   taskId;\n               if   ((selection   !=   null  )   &&   (selection.  length  ()   >   0  )) {\n                   selectionCriteria   +=   \" AND (\"   +   selection   +   \")\"  ;\n               }\n           }\n           return   db.  update  (FriendsContract.TABLE_NAME, values, selectionCriteria, selectionArgs);\n       }\n   }\n  У підсумку вийде наступний проєкт:    Клас провайдера контенту має наслідуватись від абстрактного класу   ContentProvider , який визначає низку методів для роботи з даними, зокрема, методи   oncreate ,   query ,   insert ,   update ,   delete ,   getType .  Для побудови шляхів   uri  для запитів до джерела даних визначено об'єкт   sUriMatcher , який представляє тип   UriMatcher . Для його створення застосовується метод   buildUriMatcher :     private   static   UriMatcher   buildUriMatcher  () {\n       final   UriMatcher   matcher   =   new   UriMatcher  (UriMatcher.NO_MATCH);\n       // content://com.example.friendsprovider/FRIENDS\n       matcher.  addURI  (FriendsContract.CONTENT_AUTHORITY, FriendsContract.TABLE_NAME, FRIENDS);\n       // content://com.example.friendsprovider/FRIENDS/8\n       matcher.  addURI  (FriendsContract.CONTENT_AUTHORITY, FriendsContract.TABLE_NAME   +   \"/#\"  , FRIENDS_ID);\n       return   matcher;\n   }\n  За допомогою методу   addURI  в об'єкт   UriMatcher  додається певний шлях   uri , який використовується для надсилання запиту. Як перший параметр   addUri  приймає назву провайдера, який описується константою   CONTENT_AUTHORITY . Другий параметр - шлях до даних у межах джерела даних - у цьому разі це таблиця   friends . Третій параметр - числовий код, який дає змогу розмежувати характер операції. У цьому разі у нас можливі два типи запитів - для звернення до всієї таблиці, або для звернення до окремого об'єкта, незалежно від того, чи йдеться про додавання, отримання, оновлення або видалення даних. Тому додаються два   uri . І для кожного використовується один із двох числових кодів -   FRIENDS  або   FRIENDS_ID . Це можуть бути абсолютно будь-які числові коди. Але вони дадуть змогу потім дізнатися, йде запит до всієї таблиці загалом або до якогось одного певного об'єкта.  Метод   oncreate()  виконує початкову ініціалізацію провайдера під час його створення. У цьому випадку просто встановлюється використовувана база даних:     public   boolean   onCreate  () {\n       mOpenHelper   =   AppDatabase.  getInstance  (  getContext  ());\n       return   true  ;\n   }\n  Отримання даних  Для отримання даних у провайдері визначено метод   query() .     public   Cursor   query  (@  NonNull   Uri   uri, @  Nullable   String  [] projection, @  Nullable   String   selection, \n                       @  Nullable   String  [] selectionArgs, @  Nullable   String   sortOrder) {\n       final   int   match   =   sUriMatcher.  match  (uri);\n       SQLiteQueryBuilder   queryBuilder   =   new   SQLiteQueryBuilder  ();\n       switch  (match){\n           case   FRIENDS  :\n               queryBuilder.  setTables  (FriendsContract.TABLE_NAME);\n               break  ;\n           case   FRIENDS_ID  :\n               queryBuilder.  setTables  (FriendsContract.TABLE_NAME);\n               long   taskId   =   FriendsContract.  getFriendId  (uri);\n               queryBuilder.  appendWhere  (FriendsContract.Columns._ID   +   \" = \"   +   taskId);\n               break  ;\n           default:\n               throw   new   IllegalArgumentException  (  \"Unknown URI: \"  +   uri);\n       }\n       SQLiteDatabase   db   =   mOpenHelper.  getReadableDatabase  ();\n       return   queryBuilder.  query  (db, projection, selection, selectionArgs,   null  ,   null  , sortOrder);\n   }\n  Цей метод має приймати п'ять параметрів:    uri : шлях запиту   projection : набір стовпців, дані для яких треба отримати   selection : вираз для вибірки типу   «WHERE Name = ? ....»   selectionArgs : набір значень для параметрів із selection (вставляються замість знаків запитання)  ``sortOrder`: критерій сортування, в якості якого виступає ім'я стовпця  За допомогою об'єкта   SQLiteQueryBuilder  створюємо запит sql, який буде виконуватися. Для цього спочатку отримуємо числовий код операції за допомогою виразу   sUriMatcher.match(uri) . Тобто тут ми дізнаємося, чи звернений запит до всієї таблиці (код   FRIENDS ) або до одного об'єкта (код   FRIENDS_ID ). Якщо запит звернений до всієї таблиці, то викликаємо метод   queryBuilder.setTables(FriendsContract.TABLE_NAME) .  Якщо запит йде до одного об'єкта, то в цьому випадку отримуємо власне ідентифікатор об'єкта і за допомогою методу   appendWhere()  додаємо умову для вибірки за цим ідентифікатором.  Наприкінці власне виконуємо запит за допомогою методу   queryBuilder.query()  і повертаємо об'єкт   Cursor .  Далі ми розглянемо використання цього методу і курсору, який він повертає.  Додавання даних  Для додавання даних застосовується метод   insert() :     @  Nullable\n   @  Override\n   public   Uri   insert  (@  NonNull   Uri   uri, @  Nullable   ContentValues   values) {\n    \n       final   int   match   =   sUriMatcher.  match  (uri);\n       final   SQLiteDatabase   db;\n       Uri   returnUri;\n       long   recordId;\n    \n       if   (match   ==   FRIENDS) {\n           db   =   mOpenHelper.  getWritableDatabase  ();\n           recordId   =   db.  insert  (FriendsContract.TABLE_NAME,   null  , values);\n           if   (recordId   >   0  ) {\n               returnUri   =   FriendsContract.  buildFriendUri  (recordId);\n           }   else   {\n               throw   new   SQLException  (  \"Failed to insert: \"   +   uri.  toString  ());\n           }\n       }   else   {\n           throw   new   IllegalArgumentException  (  \"Unknown URI: \"   +   uri);\n       }\n       return   returnUri;\n   }\n  Метод приймає два параметри:    uri : шлях запиту   values : об'єкт   ContentValues , через який передаються дані, що додаються  Для виконання додавання виконується метод   db.insert , який повертає ідентифікатор доданого об'єкта:     recordId   =   db.  insert  (TasksContract.TABLE_NAME,   null  , values);\n  За допомогою цього ідентифікатора створюється і повертається шлях   Uri  до створеного об'єкта.  Видалення даних     public   int   delete  (@  NonNull   Uri   uri, @  Nullable   String   selection, @  Nullable   String  [] selectionArgs) {\n       final   int   match   =   sUriMatcher.  match  (uri);\n       final   SQLiteDatabase   db   =   mOpenHelper.  getWritableDatabase  ();\n    \n       String   selectionCriteria   =   selection;\n    \n       if  (match   !=   FRIENDS   &&   match   !=   FRIENDS_ID)\n           throw   new   IllegalArgumentException  (  \"Unknown URI: \"  +   uri);\n    \n       if  (match  ==  FRIENDS_ID) {\n           long   taskId   =   FriendsContract.  getFriendId  (uri);\n           selectionCriteria   =   FriendsContract.Columns._ID   +   \" = \"   +   taskId;\n           if   ((selection   !=   null  )   &&   (selection.  length  ()   >   0  )) {\n               selectionCriteria   +=   \" AND (\"   +   selection   +   \")\"  ;\n           }\n       }\n       return   db.  delete  (FriendsContract.TABLE_NAME, selectionCriteria, selectionArgs);\n   }\n  Цей метод має приймати три параметри:    uri : шлях запиту   selection : вираз для вибірки типу   \"WHERE Name = ? ....\"   selectionArgs : набір значень для параметрів з selection (вставляються замість знаків запитання)  Під час видалення ми можемо реалізувати один із двох сценаріїв: або видалити з таблиці набір даних (наприклад, друзів, у яких ім'я Том), або видалити один об'єкт за певним ідентифікатором. У разі якщо йде видалення за ідентифікатором, то до виразу вибірки даних, що видаляються, в   selection  додається умова видалення за   id :     long   taskId   =   FriendsContract.  getFriendId  (uri);\n   selectionCriteria   =   FriendsContract.Columns._ID   +   \" = \"   +   taskId;\n   if  ((selection   !=   null  )   &&   (selection.  length  ()   >   0  )){\n       selectionCriteria   +=   \" AND (\"   +   selection   +   \")\"  ;\n   }\n   count   =   db.  delete  (FriendsContract.TABLE_NAME, selectionCriteria, selectionArgs);\n  Результатом видалення є кількість видалених рядків у таблиці.  Оновлення даних  Для оновлення даних застосовується метод   update() :     public   int   update  (@  NonNull   Uri   uri, @  Nullable   ContentValues   values, @  Nullable   String   selection, @  Nullable   String  [] selectionArgs) {\n    \n       final   int   match   =   sUriMatcher.  match  (uri);\n       final   SQLiteDatabase   db   =   mOpenHelper.  getWritableDatabase  ();\n       String   selectionCriteria   =   selection;\n    \n       if  (match   !=   FRIENDS   &&   match   !=   FRIENDS_ID)\n           throw   new   IllegalArgumentException  (  \"Unknown URI: \"  +   uri);\n    \n       if  (match  ==  FRIENDS_ID) {\n           long   taskId   =   FriendsContract.  getFriendId  (uri);\n           selectionCriteria   =   FriendsContract.Columns._ID   +   \" = \"   +   taskId;\n           if   ((selection   !=   null  )   &&   (selection.  length  ()   >   0  )) {\n               selectionCriteria   +=   \" AND (\"   +   selection   +   \")\"  ;\n           }\n       }\n       return   db.  update  (FriendsContract.TABLE_NAME, values, selectionCriteria, selectionArgs);\n   }\n  Цей метод має приймати чотири параметри:    uri : шлях запиту   values : об'єкт   ContentValues , який визначає нові значення   selection : вираз для вибірки типу   \"WHERE Name = ? ....\"   selectionArgs : набір значень для параметрів із selection (вставляються замість знаків запитання)  Метод   update  багато в чому аналогічний методу   delete  за тим винятком, що в метод передаються дані типу   ContentValues , які передаються в метод   db.update() .  AndroidManifest  Але щоб провайдер контенту запрацював, необхідно внести зміни у файл   AndroidManifest.xml . Наприклад, за замовчуванням цей файл має приблизно такий вигляд:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  manifest   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       package  =  \"com.example.friendsproviderapp\"  >\n    \n       \u003C  application\n           android:allowBackup  =  \"true\"\n           android:icon  =  \"@mipmap/ic_launcher\"\n           android:label  =  \"@string/app_name\"\n           android:roundIcon  =  \"@mipmap/ic_launcher_round\"\n           android:supportsRtl  =  \"true\"\n           android:theme  =  \"@style/Theme.FriendsProviderApp\"  >\n           \u003C  activity   android:name  =  \".MainActivity\"  >\n               \u003C  intent-filter  >\n                   \u003C  action   android:name  =  \"android.intent.action.MAIN\"   />\n    \n                   \u003C  category   android:name  =  \"android.intent.category.LAUNCHER\"   />\n               \u003C/  intent-filter  >\n           \u003C/  activity  >\n       \u003C/  application  >\n    \n   \u003C/  manifest  >\n  І в кінець елемента   \u003Capplication>  додамо визначення провайдера:     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  manifest   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       package  =  \"com.example.friendsproviderapp\"  >\n    \n       \u003C  application\n           android:allowBackup  =  \"true\"\n           android:icon  =  \"@mipmap/ic_launcher\"\n           android:label  =  \"@string/app_name\"\n           android:roundIcon  =  \"@mipmap/ic_launcher_round\"\n           android:supportsRtl  =  \"true\"\n           android:theme  =  \"@style/Theme.FriendsProviderApp\"  >\n           \u003C  activity   android:name  =  \".MainActivity\"  >\n               \u003C  intent-filter  >\n                   \u003C  action   android:name  =  \"android.intent.action.MAIN\"   />\n    \n                   \u003C  category   android:name  =  \"android.intent.category.LAUNCHER\"   />\n               \u003C/  intent-filter  >\n           \u003C/  activity  >\n    \n           \u003C  provider\n               android:authorities  =  \"com.example.friendsprovider\"\n               android:name  =  \"com.example.friendsproviderapp.AppProvider\"\n               android:exported  =  \"false\"  />\n       \u003C/  application  >\n    \n   \u003C/  manifest  >\n  В елементі   provider  атрибут   android:authorities  вказує на назву провайдера - в даному випадку це назва, яка визначена в минулій темі в константі   CONTENT_AUTHORITY  в класі   FriendsContract , тобто   com.example.friendsprovider . А атрибут   android:name  вказує на повну назву класу провайдера з урахуванням його пакета. У моєму випадку пакет   com.example.friendsproviderapp , а клас провайдера -   AppProvider , тому в підсумку виходить   com.example.friendsproviderapp .  AppProvider .  Використання провайдера  Спочатку визначимо найпростіший візуальний інтерфейс для тестування можливостей провайдера у файлі   activity_main.xml :     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  androidx.constraintlayout.widget.ConstraintLayout\n       xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n       xmlns:app  =  \"http://schemas.android.com/apk/res-auto\"\n       android:layout_width  =  \"match_parent\"\n       android:layout_height  =  \"match_parent\"   >\n    \n       \u003C  Button\n           android:id  =  \"@+id/getButton\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Get\"\n           android:onClick  =  \"getAll\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/addButton\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toTopOf  =  \"parent\"   />\n    \n       \u003C  Button\n           android:id  =  \"@+id/addButton\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Add\"\n           android:onClick  =  \"add\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/updateButton\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/getButton\"   />\n    \n       \u003C  Button\n           android:id  =  \"@+id/updateButton\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Update\"\n           android:onClick  =  \"update\"\n           app:layout_constraintBottom_toTopOf  =  \"@id/deleteButton\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/addButton\"   />\n    \n       \u003C  Button\n           android:id  =  \"@+id/deleteButton\"\n           android:layout_width  =  \"0dp\"\n           android:layout_height  =  \"wrap_content\"\n           android:text  =  \"Delete\"\n           android:onClick  =  \"delete\"\n           app:layout_constraintLeft_toLeftOf  =  \"parent\"\n           app:layout_constraintRight_toRightOf  =  \"parent\"\n           app:layout_constraintTop_toBottomOf  =  \"@id/updateButton\"   />\n    \n   \u003C/  androidx.constraintlayout.widget.ConstraintLayout  >\n  Тут визначено набір кнопок для виведення списку друзів, а також додавання, оновлення та видалення. Кожна кнопка викликатиме відповідний метод у класі   MainActivity .  Тепер змінимо код класу   MainActivity . Для спрощення результати будемо виводити у вікні   Logcat  за допомогою методу   Log.d() :     public   class   MainActivity   extends   AppCompatActivity   {\n    \n       private   static   final   String   TAG   =   \"MainActivity\"  ;\n    \n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           setContentView  (R.layout.activity_main);\n       }\n       // отримання всіх\n       public   void   getAll  (  View   view  ){\n           String  [] projection   =   {\n                   FriendsContract.Columns._ID,\n                   FriendsContract.Columns.NAME,\n                   FriendsContract.Columns.EMAIL,\n                   FriendsContract.Columns.PHONE\n           };\n           ContentResolver   contentResolver   =   getContentResolver  ();\n           Cursor   cursor   =   contentResolver.  query  (FriendsContract.CONTENT_URI,\n                   projection,\n                   null  ,\n                   null  ,\n                   FriendsContract.Columns.NAME);\n           if  (cursor   !=   null  ){\n               Log.  d  (TAG,   \"count: \"   +   cursor.  getCount  ());\n               // перебор элементов\n               while  (cursor.  moveToNext  ()){\n                   for  (  int   i  =  0  ; i   \u003C   cursor.  getColumnCount  (); i  ++  ){\n                       Log.  d  (TAG, cursor.  getColumnName  (i)   +   \" : \"   +   cursor.  getString  (i));\n                   }\n                   Log.  d  (TAG,   \"=========================\"  );\n               }\n               cursor.  close  ();\n           }\n           else  {\n               Log.  d  (TAG,   \"Cursor is null\"  );\n           }\n       }\n       // Додавання\n       public   void   add  (  View   view  ){\n           ContentResolver   contentResolver   =   getContentResolver  ();\n           ContentValues   values   =   new   ContentValues  ();\n           values.  put  (FriendsContract.Columns.NAME,   \"Sam\"  );\n           values.  put  (FriendsContract.Columns.EMAIL,   \"sam@gmail.com\"  );\n           values.  put  (FriendsContract.Columns.PHONE,   \"+13676254985\"  );\n           Uri   uri   =   contentResolver.  insert  (FriendsContract.CONTENT_URI, values);\n           Log.  d  (TAG,   \"Friend added\"  );\n       }\n    \n       // Оновлення\n       public   void   update  (  View   view  ){\n           ContentResolver   contentResolver   =   getContentResolver  ();\n           ContentValues   values   =   new   ContentValues  ();\n           values.  put  (FriendsContract.Columns.EMAIL,   \"sammy@gmail.com\"  );\n           values.  put  (FriendsContract.Columns.PHONE,   \"+55555555555\"  );\n           String   selection   =   FriendsContract.Columns.NAME   +   \" = 'Sam'\"  ;\n           int   count   =   contentResolver.  update  (FriendsContract.CONTENT_URI, values, selection,   null  );\n           Log.  d  (TAG,   \"Friend updated\"  );\n       }\n       // Видалення\n       public   void   delete  (  View   view  ){\n           ContentResolver   contentResolver   =   getContentResolver  ();\n           String   selection   =   FriendsContract.Columns.NAME   +   \" = ?\"  ;\n           String  [] args   =   {  \"Sam\"  };\n           int   count   =   contentResolver.  delete  (FriendsContract.CONTENT_URI, selection, args);\n           Log.  d  (TAG,   \"Friend deleted\"  );\n       }\n   }\n  Розберемо окремі дії, що виконуються в цьому коді.  Отримання даних     public   void   getAll  (  View   view){\n       String  [] projection   =   {\n           FriendsContract.Columns._ID,\n           FriendsContract.Columns.NAME,\n           FriendsContract.Columns.EMAIL,\n           FriendsContract.Columns.PHONE\n       };\n       ContentResolver   contentResolver   =   getContentResolver  ();\n       Cursor   cursor   =   contentResolver.  query  (FriendsContract.CONTENT_URI,\n           projection,\n           null  ,\n           null  ,\n           FriendsContract.Columns.NAME);\n       if  (cursor   !=   null  ){\n           Log.  d  (TAG,   \"count: \"   +   cursor.  getCount  ());\n           // перебор элементов\n           while  (cursor.  moveToNext  ()){\n               for  (  int   i  =  0  ; i   \u003C   cursor.  getColumnCount  (); i  ++  ){\n                   Log.  d  (TAG, cursor.  getColumnName  (i)   +   \" : \"   +   cursor.  getString  (i));\n               }\n               Log.  d  (TAG,   \"=========================\"  );\n           }\n           cursor.  close  ();\n       }\n       else  {\n           Log.  d  (TAG,   \"Cursor is null\"  );\n       }\n   }\n  Взаємодія з провайдером контенту здійснюється через об'єкт   ContentResolver . Для отримання даних викликається метод   query() , по суті він являє собою виклик метод   query  провайдера контенту. У метод   query  передається   uri  - шлях до даних,   projection  - набір стовпчиків для вилучення, вираз вибірки і параметри для нього і назва стовпчика, за яким проводиться сортування.  Метод повертає курсор   Cursor , який за допомогою методу   moveToNext()  можна перебрати і отримати окремі дані. Метод   getColumnName()  повертає назву стовпця, а   getString()  - власне значення цього стовпця:    Отримання одного об'єкта за   id :     String  [] projection   =   {\n       FriendsContract.Columns._ID,\n       FriendsContract.Columns.NAME,\n       FriendsContract.Columns.EMAIL,\n       FriendsContract.Columns.PHONE\n   };\n   ContentResolver   contentResolver   =   getContentResolver  ();\n   Cursor   cursor   =   contentResolver.  query  (FriendsContract.  buildFriendUri  (  2  ),\n       projection,   null  ,   null  , FriendsContract.Columns.NAME);\n   if  (cursor   !=   null  ){\n       while  (cursor.  moveToNext  ()){\n           for  (  int   i  =  0  ; i   \u003C   cursor.  getColumnCount  (); i  ++  ){\n               Log.  d  (TAG, cursor.  getColumnName  (i)   +   \" : \"   +   cursor.  getString  (i));\n           }\n       }\n       cursor.  close  ();\n   }\n  У цьому випадку отримуємо об'єкт із   _id=2 .  Додавання даних     ContentResolver   contentResolver   =   getContentResolver  ();\n   ContentValues   values   =   new   ContentValues  ();\n   values.  put  (FriendsContract.Columns.NAME,   \"Sam\"  );\n   values.  put  (FriendsContract.Columns.EMAIL,   \"sam@gmail.com\"  );\n   values.  put  (FriendsContract.Columns.PHONE,   \"+13676254985\"  );\n   Uri   uri   =   contentResolver.  insert  (FriendsContract.CONTENT_URI, values);\n  Для додавання застосовується метод   insert , який приймає шлях URI і дані, що додаються, у вигляді   ContentValues .  Оновлення даних     ContentResolver   contentResolver   =   getContentResolver  ();\n   ContentValues   values   =   new   ContentValues  ();\n   values.  put  (FriendsContract.Columns.EMAIL,   \"sammy@gmail.com\"  );\n   values.  put  (FriendsContract.Columns.PHONE,   \"+55555555555\"  );\n   String   selection   =   FriendsContract.Columns.NAME   +   \" = 'Sam'\"  ;\n   int   count   =   contentResolver.  update  (FriendsContract.CONTENT_URI, values, selection,   null  );\n  У цьому випадку оновлюються дані у всіх об'єктів, у яких   \"Name=Sam\" . Критерій оновлення передається через третій параметр.  Природно, за допомогою виразу SQL можна задати будь-яку логіку вибірки об'єктів для оновлення. І для більшої зручності ми можемо вводити в нього дані за допомогою параметрів, які задаються знаком питання:     ContentResolver   contentResolver   =   getContentResolver  ();\n   ContentValues   values   =   new   ContentValues  ();\n   values.  put  (FriendsContract.Columns.NAME,   \"Sam\"  );\n   String   selection   =   FriendsContract.Columns.NAME   +   \" = ?\"  ;\n   String   args[]   =   {  \"Sam Scromby\"  };\n   int   count   =   contentResolver.  update  (FriendsContract.CONTENT_URI, values, selection, args);\n  У цьому випадку за допомогою четвертого параметра передається масив значень для параметрів виразу вибірки.  Але в прикладах вище оновлювалися всі рядки в бд, які мали, наприклад, ім'я \"Sam\". Але також можна оновлювати й один об'єкт за   id . Наприклад, оновимо рядок із   _id=3 :     ContentResolver   contentResolver   =   getContentResolver  ();\n   ContentValues   values   =   new   ContentValues  ();\n   values.  put  (FriendsContract.Columns.NAME,   \"Sam\"  );\n   values.  put  (FriendsContract.Columns.EMAIL,   \"sam@gmail.com\"  );\n   int   count   =   contentResolver.  update  (FriendsContract.  buildFriendUri  (  3  ), values,   null  ,   null  );\n  Видалення даних  Видалення даних за загальною умовою:     ContentResolver   contentResolver   =   getContentResolver  ();\n   String   selection   =   FriendsContract.Columns.NAME   +   \" = ?\"  ;\n   String  [] args   =   {  \"Sam\"  };\n   int   count   =   contentResolver.  delete  (FriendsContract.CONTENT_URI, selection, args);\n  У цьому випадку видаляються всі рядки, у яких   Name=Sam .  Видалення за   id :     ContentResolver   contentResolver   =   getContentResolver  ();\n   int   count   =   contentResolver.  delete  (FriendsContract.  buildFriendUri  (  2  ),   null  ,   null  );\n  У цьому випадку видаляється рядок із   _id=2 .  Асинхронне завантаження даних  У базі даних може бути багато даних, і їх завантаження може зайняти деякий час. У цьому випадку можна скористатися асинхронним завантаженням даних. Для цього клас activity або фрагмента має реалізувати інтерфейс   LoaderManager.LoaderCallbacks\u003CCursor> .  Візьмемо проєкт із минулої теми, де реалізовано провайдера контенту   AppProvider , і змінимо клас   MainActivity :     public   class   MainActivity   extends   AppCompatActivity   implements   LoaderManager.LoaderCallbacks  \u003C  Cursor  > {\n    \n       private   static   final   String   TAG   =   \"MainActivity\"  ;\n       private   static   final   int   LOADER_ID   =   225  ;\n       @  Override\n       protected   void   onCreate  (  Bundle   savedInstanceState  ) {\n           super  .  onCreate  (savedInstanceState);\n           // setContentView(R.layout.activity_main);\n           // запускаємо завантаження даних через провайдера контенту\n           LoaderManager.  getInstance  (  this  ).  initLoader  (LOADER_ID,   null  ,   this  );\n       }\n    \n       @  NonNull\n       @  Override\n       public   Loader  \u003C  Cursor  >   onCreateLoader  (  int   id  , @  Nullable   Bundle   args  ) {\n           String  [] projection   =   {\n                   FriendsContract.Columns._ID,\n                   FriendsContract.Columns.NAME,\n                   FriendsContract.Columns.EMAIL,\n                   FriendsContract.Columns.PHONE\n           };\n           if  (id   ==   LOADER_ID)\n               return   new   CursorLoader  (  this  , FriendsContract.CONTENT_URI,\n                       projection,\n                       null  ,\n                       null  ,\n                       FriendsContract.Columns.NAME);\n           else\n               throw   new   InvalidParameterException  (  \"Invalid loader id\"  );\n       }\n    \n       @  Override\n       public   void   onLoadFinished  (@  NonNull   Loader  \u003C  Cursor  >   loader  ,   Cursor   data  ) {\n           if  (data   !=   null  ){\n               Log.  d  (TAG,   \"count: \"   +   data.  getCount  ());\n               // перебір елементів\n               while  (data.  moveToNext  ()){\n                   for  (  int   i  =  0  ; i   \u003C   data.  getColumnCount  (); i  ++  ){\n                       Log.  d  (TAG, data.  getColumnName  (i)   +   \" : \"   +   data.  getString  (i));\n                   }\n                   Log.  d  (TAG,   \"=========================\"  );\n               }\n               data.  close  ();\n           }\n           else  {\n               Log.  d  (TAG,   \"Cursor is null\"  );\n           }\n       }\n    \n       @  Override\n       public   void   onLoaderReset  (@  NonNull   Loader  \u003C  Cursor  >   loader  ) {\n           Log.  d  (TAG,   \"onLoaderReset...\"  );\n       }\n   }\n  Інтерфейс   LoaderManager.LoaderCallbacks\u003CCursor>  передбачає реалізацію трьох методів. Метод   onCreateLoader()  завантажує курсор. У цей метод як параметри передаються числовий код операції та об'єкт   Bundle . Числовий код передається під час запуску завантаження курсора. В даному випадку в якості такого коду використовує константа   LOADER_ID .  У самому методі створюється об'єкт   CursorLoader . У його конструктор передається кілька параметрів:   об'єкт   Context  (поточна   activity )  набір стовпців, які треба отримати  вираз для вибірки даних  значення для параметрів для виразу вибірки  стовпець, за яким іде сортування  Метод   onLoadFinished  викликається при завантаженні курсору. Через другий параметр ми можемо власне отримати курсор і через нього завантажені дані. І відповідно в цьому методі ми може перебрати курсор, отримати дані і вивести їх в елементах графічного інтерфейсу або на консоль.  І метод   onLoaderReset  призначений для скидання завантажувача.  Щоб запустити завантаження даних, у методі   onCreate  викликається метод    LoaderManager.  getInstance  (  this  ).  initLoader  (LOADER_ID,   null  ,   this  ); . Перший параметр - числовий код, а другий - об'єкт   Bundle . Це ті значення, які ми можемо отримати в методі   onCreateLoader . І третій - об'єкт   Context .  У підсумку під час запуску   MainActivity  дані асинхронно будуть завантажені з бази даних:    html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1237,"path":1238,"dir":1137,"title":1239,"description":1240,"keywords":1241,"body":1247},"content:1.android:10.lesson10:11.notifications-intro.md","/android/lesson10/notifications-intro","Android Notifications. Сповіщення. Основи","Notifications - це сповіщення, які користувач бачить у верхній частині екрана, коли йому надходить новий лист, повідомлення, оновлення тощо.",[1242,1243,1244,1245,1246],"Відображення","Оновлення","Кілька повідомлень","Видалення","Обробка натискання","  Android Notifications. Сповіщення. Основи   Notifications  - це сповіщення, які користувач бачить у верхній частині екрана, коли йому надходить новий лист, повідомлення, оновлення тощо.  У цьому уроці розглянемо основи - відображення/оновлення/видалення сповіщення та обробка натискання на нього.  Відображення  Код створення простого повідомлення має такий вигляд:     NotificationCompat  .  Builder   builder   =\n          new   NotificationCompat.  Builder  (  this  )\n                  .  setSmallIcon  (R.mipmap.ic_launcher)\n                  .  setContentTitle  (  \"Title\"  )\n                  .  setContentText  (  \"Notification text\"  );\n    \n   Notification   notification   =   builder.  build  ();\n    \n   NotificationManager   notificationManager   =\n          (NotificationManager)   getSystemService  (NOTIFICATION_SERVICE);\n   notificationManager.  notify  (  1  , notification);\n  Використовуємо білдер, у якому вказуємо іконку, заголовок і текст для повідомлення. Методом   build  отримуємо готове повідомлення.  Далі використовуємо   NotificationManager  і його метод   notify , щоб показати створене повідомлення. Крім   notification , потрібно передати   id . Це необхідно, щоб надалі ми могли використовувати цей   id  для оновлення або видалення повідомлення.  Конструктор new    NotificationCompat.  Builder  (Context)  буде позначений як   Deprecated , якщо ви використовуєте бібліотеку   appCompat  версії   26  і вище. Так вийшло тому, що в Android API 26 з'явився новий конструктор і рекомендується використовувати його. Поки що не звертайте увагу на це.  Запустивши цей код, ми побачимо повідомлення\n   Воно відображає іконку і два тексти, які ми вказували в білдері. Натискання на нього ні до чого не призведе, тому що ми не реалізували обробник натискання. Ми це зробимо трохи пізніше.  Оновлення  Ми відобразили повідомлення і тепер хочемо його оновити. Для цього потрібно просто знову показати сповіщення методом   notify  і використовувати при цьому той самий   id .  Це матиме такий вигляд:     NotificationCompat  .  Builder   builder   =\n          new   NotificationCompat.  Builder  (  this  )\n                  .  setSmallIcon  (android.R.drawable.ic_dialog_email)\n                  .  setContentTitle  (  \"Title change\"  )\n                  .  setContentText  (  \"Notification text change\"  );\n    \n   Notification   notification   =   builder.  build  ();\n    \n   NotificationManager   notificationManager   =\n          (NotificationManager)   getSystemService  (NOTIFICATION_SERVICE);\n   notificationManager.  notify  (  1  , notification);\n  Код повністю аналогічний коду, що ми використовували під час відображення повідомлення. Тільки в білдері використовуємо інші тексти та іконку. Найголовніше, що в методі notify ми знову використовуємо   id = 1 .   NotificationManager  за цим   id  знайде повідомлення, яке ми відобразили трохи раніше, і замінить його новим.\n   Кілька повідомлень  Щоб показати нове сповіщення, а не оновити вже наявне, треба використовувати інший id у методі   notify .  Перше повідомлення     NotificationCompat  .  Builder   builder   =\n          new   NotificationCompat.  Builder  (  this  )\n                  .  setSmallIcon  (R.mipmap.ic_launcher)\n                  .  setContentTitle  (  \"Title\"  )\n                  .  setContentText  (  \"Notification text\"  );\n    \n   Notification   notification   =   builder.  build  ();\n    \n   NotificationManager   notificationManager   =\n          (NotificationManager)   getSystemService  (NOTIFICATION_SERVICE);\n   notificationManager.  notify  (  1  , notification);\n  Друге повідомлення     NotificationCompat  .  Builder   builder   =\n          new   NotificationCompat.  Builder  (  this  )\n                  .  setSmallIcon  (android.R.drawable.ic_dialog_email)\n                  .  setContentTitle  (  \"Title 2\"  )\n                  .  setContentText  (  \"Notification text 2\"  );\n    \n   Notification   notification   =   builder.  build  ();\n    \n   NotificationManager   notificationManager   =\n          (NotificationManager)   getSystemService  (NOTIFICATION_SERVICE);\n   notificationManager.  notify  (  2  , notification);\n  Ми використовували різні   id  у методі   notify  і отримали два різних повідомлення\n   Видалення  Щоб видалити повідомлення, використовуємо   NotificationManager  і його метод   cancel  із зазначенням   id  повідомлення.     NotificationManager   notificationManager   =\n          (NotificationManager)   getSystemService  (NOTIFICATION_SERVICE);\n   notificationManager.  cancel  (  1  );\n  Або методом   cancelAll  можемо видалити всі повідомлення відразу     NotificationManager   notificationManager   =\n          (NotificationManager)   getSystemService  (NOTIFICATION_SERVICE);\n   notificationManager.  cancelAll  ();\n  Під час видалення повідомлення немає необхідності перевіряти, відображається воно чи ні. Якщо повідомлення з якихось причин уже немає, то просто нічого не станеться.  Обробка натискання  Щоб виконати будь-яку дію після натискання на повідомлення, необхідно використовувати   PendingIntent .   PendingIntent  - це контейнер для   Intent . Цей контейнер може бути використаний для подальшого запуску вкладеного в нього   Intent .  Ми створюватимемо   Intent  для запуску, наприклад,   Activity , упаковуватимемо цей   Intent  у   PendingIntent  і передаватимемо   PeningIntent  у сповіщення. Після натискання на сповіщення, система дістане з нього   PendingIntent  і використає вкладений у нього   Intent , щоб запустити   Activity .  Давайте подивимося, як це виглядає на практиці:     Intent   resultIntent   =   new   Intent  (  this  , MainActivity.class);\n   PendingIntent   resultPendingIntent   =   PendingIntent.  getActivity  (  this  ,   0  , resultIntent,\n                  PendingIntent.FLAG_UPDATE_CURRENT);\n  Створюємо   Intent  для запуску   Activity  і пакуємо його в   PedningIntent .  Створений   PendingIntent  нам треба буде передати в білдер повідомлення. Повний код створення повідомлення виглядатиме так:     // Create PendingIntent\n   Intent   resultIntent   =   new   Intent  (  this  , MainActivity.class);\n   PendingIntent   resultPendingIntent   =   PendingIntent.  getActivity  (  this  ,   0  , resultIntent,\n                  PendingIntent.FLAG_UPDATE_CURRENT);\n    \n   // Create Notification\n   NotificationCompat  .  Builder   builder   =\n          new   NotificationCompat.  Builder  (  this  )\n                  .  setSmallIcon  (R.mipmap.ic_launcher)\n                  .  setContentTitle  (  \"Title\"  )\n                  .  setContentText  (  \"Notification text\"  )\n                  .  setContentIntent  (resultPendingIntent);\n    \n   Notification   notification   =   builder.  build  ();\n    \n   // Show Notification\n   NotificationManager   notificationManager   =\n          (NotificationManager)   getSystemService  (NOTIFICATION_SERVICE);\n   notificationManager.  notify  (  1  , notification);\n  Передаємо   PendingIntent  у метод   setContentIntent  білдера повідомлення.  Після натискання на повідомлення відкриється   MainActivity   Зверніть увагу, що повідомлення не видаляється автоматично після натискання на нього. Щоб виправити це, можна в білдері сповіщення використовувати увімкнути параметр   autoCancel     setAutoCancel  (  true  )\n  Повідомлення, створене з цим прапором, буде закриватися після натискання на нього.\n   Білдер повідомлення має ще кілька методів, які можуть бути корисними.   setNumber  - дає змогу додати число в сповіщення\n   html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1249,"path":1250,"dir":1137,"title":1251,"description":1252,"keywords":1253,"body":1254},"content:1.android:10.lesson10:12.notifications-extend.md","/android/lesson10/notifications-extend","Notifications. Розширені сповіщення","В Android 4.1 (API 16) з'явилися розширені повідомлення. Якщо потягнути вниз таке сповіщення, то воно відобразить додаткову інформацію.",[],"  Notifications. Розширені сповіщення  В Android 4.1 (API 16) з'явилися розширені повідомлення. Якщо потягнути вниз таке сповіщення, то воно відобразить додаткову інформацію.  Щоб створити розширене повідомлення, необхідно додати стиль до білдера. Стилів існує кілька. Усі вони спадкоємці абстрактного класу   NotificationCompat.Style . Із назви стилю зазвичай зрозуміло, для чого він може бути використаний.  Розглянемо, наприклад, стиль   BigTextStyle , щоб відобразити довгий текст.  Далі я наводитиму тільки код білдера. А як з білдера отримати і відобразити повідомлення, ви можете подивитися в попередніх уроках.     String   longText   =   \"To have a notification appear in an expanded view, \"   +\n          \"first create a NotificationCompat.Builder object \"   +\n          \"with the normal view options you want. \"   +\n          \"Next, call Builder.setStyle() with an \"   +\n          \"expanded layout object as its argument.\"  ;\n    \n   NotificationCompat  .  Builder   builder   =\n          new   NotificationCompat.  Builder  (  this  )\n                  .  setSmallIcon  (R.mipmap.ic_launcher)\n                  .  setContentTitle  (  \"Title\"  )\n                  .  setContentText  (  \"Notification text\"  )\n                  .  setStyle  (  new   NotificationCompat.  BigTextStyle  ().  bigText  (longText));\n  У білдері повідомлення викликаємо метод   setStyle , у який нам необхідно передати стиль. Створюємо стиль   BigTextStyle  і передаємо йому довгий текст у метод   bigText .  Тепер під час розкриття повідомлення відображатиметься довгий текст.\n   Стиль   BigPictureStyle  допоможе відобразити велику картинку:     BitmapFactory  .  Options   options   =   new   BitmapFactory.  Options  ();\n   Bitmap   bitmap   =   BitmapFactory.  decodeResource  (  getResources  (), R.mipmap.startandroid, options);\n    \n   NotificationCompat  .  Builder   builder   =\n          new   NotificationCompat.  Builder  (  this  )\n                  .  setSmallIcon  (R.mipmap.ic_launcher)\n                  .  setContentTitle  (  \"Title\"  )\n                  .  setContentText  (  \"Notification text\"  )\n                  .  setStyle  (  new   NotificationCompat.  BigPictureStyle  ().  bigPicture  (bitmap));\n  Створюємо   bitmap  і передаємо його в   BigPictureStyle .  Під час розкриття повідомлення відобразить картинку\n   Стиль   InboxStyle  - розмістить до 5 ваших рядків у вигляді списку     NotificationCompat  .  Builder   builder   =\n          new   NotificationCompat.  Builder  (  this  )\n                  .  setSmallIcon  (R.mipmap.ic_launcher)\n                  .  setContentTitle  (  \"Title\"  )\n                  .  setContentText  (  \"Notification text\"  )\n                  .  setStyle  (  new   NotificationCompat.  InboxStyle  ()\n                          .  addLine  (  \"Line 1\"  )\n                          .  addLine  (  \"Line 2\"  )\n                          .  addLine  (  \"Line 3\"  ));\n  Методом   addLine  додаємо рядки  Результат:\n   Стиль   MessagingStyle  зручний для відображення останніх повідомлень із чату:     NotificationCompat  .  MessagingStyle   messagingStyle   =   new   NotificationCompat.  MessagingStyle  (  \"You\"  );\n   messagingStyle.  setConversationTitle  (  \"Android chat\"  )\n          .  addMessage  (  \"Всем привет!\"  , System.  currentTimeMillis  (),   \"Ivan\"  )\n          .  addMessage  (  \"Кто перешел на новую студию, как оно?\"  , System.  currentTimeMillis  (),   \"Ivan\"  )\n          .  addMessage  (  \"Я пока не переходил, жду отзывов\"  , System.  currentTimeMillis  (),   \"Andrey\"  )\n          .  addMessage  (  \"Я перешел\"  , System.  currentTimeMillis  (),   null  )\n          .  addMessage  (  \"Было несколько проблем, но все решаемо\"  , System.  currentTimeMillis  (),   null  )\n          .  addMessage  (  \"Ок, спасибо!\"  , System.  currentTimeMillis  (),   \"Ivan\"  );\n    \n   NotificationCompat  .  Builder   builder   =\n          new   NotificationCompat.  Builder  (  this  )\n                  .  setSmallIcon  (R.mipmap.ic_launcher)\n                  .  setContentTitle  (  \"Title\"  )\n                  .  setContentText  (  \"Notification text\"  )\n                  .  setStyle  (messagingStyle);\n  У конструкторі   MessagingStyle  вам необхідно вказати, під яким ім'ям користувач бачитиме свої повідомлення. Зазвичай у чатах використовують слово   You  (або   Me ).  У   setConversationTitle  вказується назва чату. Зазвичай це використовується, коли в чаті більше двох співрозмовників.  Далі, методом   addMessage  додаються повідомлення. Повідомлення складається з трьох полів: текст, час, відправник. Якщо відправник -   null , то це вважається повідомленням користувача, і буде використано ім'я, яке ми вказували в конструкторі   MessagingStyle , тобто   You .  Додавати можна скільки завгодно повідомлень, але після того, як кількість повідомлень буде більшою, ніж   MessagingStyle.MAXIMUM_RETAINED_MESSAGES , старі повідомлення почнуть видалятися. Це зручно і дає змогу не заморочуватися перевірками на кількість.  Відображатимуться повідомлення в тому ж порядку, що ви їх додали.\nВиглядати це буде так:\n   Час повідомлень не відображається. Наскільки я зрозумів, поверхнево подивившись вихідні коди, він поки що взагалі ніде не використовується. Можливо, у майбутніх релізах це зміниться.  Метод   addMessage  також працює з об'єктом   Message . Цей об'єкт містить поля: текст, час і автор. Але крім них є метод   setData  для зазначення   MIME -даних, наприклад картинок.  У деяких стилів є пара загальних методів, які можуть бути корисними:   setBigContentTitle  і   setSummaryText .  Розглянемо їх на прикладі з   InboxStyle :     NotificationCompat  .  Builder   builder   =\n          new   NotificationCompat.  Builder  (  this  )\n                  .  setSmallIcon  (R.mipmap.ic_launcher)\n                  .  setContentTitle  (  \"Title\"  )\n                  .  setContentText  (  \"Notification text\"  )\n                  .  setStyle  (  new   NotificationCompat.  InboxStyle  ()\n                          .  addLine  (  \"Line 1\"  )\n                          .  addLine  (  \"Line 2\"  )\n                          .  addLine  (  \"Line 3\"  )\n                          .  setBigContentTitle  (  \"Extended title\"  )\n                          .  setSummaryText  (  \"+5 more\"  ));\n  Код майже той самий, що ми розглядали раніше. Додано два методи:    setBigContentTitle  - дає змогу вказати заголовок повідомлення, який буде показано під час розкриття повідомлення   setSummaryText  - текст буде відображено внизу розширеного повідомлення  Результат:\n   Під час розкриття повідомлення змінюється заголовок і в нижній частині відображено summary текст.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1256,"path":1257,"dir":1137,"title":1258,"description":1259,"keywords":1260,"body":1261},"content:1.android:10.lesson10:13.notifications-action-reply.md","/android/lesson10/notifications-action-reply","Notifications. Action кнопки. Reply.","В Android 4.1 з'явилася можливість додавати кнопки в повідомлення.",[],"  Notifications. Action кнопки. Reply.  В Android 4.1 з'явилася можливість додавати кнопки в повідомлення.  Для цього використовується метод   addAction .     Intent   deleteIntent   =   new   Intent  (  this  , MyService.class);\n   deleteIntent.  setAction  (  \"ru.startandroid.notifications.action_delete\"  );\n   PendingIntent   deletePendingIntent   =   PendingIntent.  getService  (  this  ,   0  , deleteIntent,   0  );\n    \n   NotificationCompat  .  Builder   builder   =\n          new   NotificationCompat.  Builder  (  this  )\n                  .  setSmallIcon  (R.mipmap.ic_launcher)\n                  .  setContentTitle  (  \"Title\"  )\n                  .  setContentText  (  \"Notification text\"  )\n                  .  addAction  (android.R.drawable.ic_delete,   \"Delete\"  , deletePendingIntent);\n  Спочатку створюємо   PendingIntent , який буде викликаний після натискання на кнопку. Потім передаємо його в метод   addAction , а разом із ним іконку і текст для кнопки.  Під час розкриття повідомлення буде відображена кнопка.\n   Після натискання на кнопку повідомлення саме не закриється. Якщо вам необхідно його закрити, використовуйте   cancel  в обробнику натискання.  Ви можете додати до трьох   Action  кнопок. Кнопки не повинні дублювати дію, яка відбувається після натискання на повідомлення.  На останніх версіях Android чомусь не відображається іконка кнопки, тільки текст.  Reply  Починаючи з API 24 з'явилася можливість додати в повідомлення рядок введення. Це може бути зручно, наприклад, у чат-додатках. Користувач зможе відповісти на повідомлення прямо з нотифікації.  Розглянемо приклад реалізації:     // id\n   int   itemId   =   ...;\n    \n   // Intent\n   Intent   intent   =   new   Intent  (  this  , MyService.class);\n   intent.  setAction  (ACTION_REPLY);\n   intent.  putExtra  (EXTRA_ITEM_ID, itemId);\n    \n   // PendingIntent\n   PendingIntent   replyPendingIntent   =\n          PendingIntent.  getService  (  getApplicationContext  (),\n                  itemId, intent, PendingIntent.FLAG_UPDATE_CURRENT);\n    \n   // RemoteInput\n   RemoteInput   remoteInput   =   new   RemoteInput.  Builder  (EXTRA_TEXT_REPLY)\n          .  setLabel  (  \"Type message\"  )\n          .  build  ();\n    \n   // Action\n   NotificationCompat  .  Action   action   =\n          new   NotificationCompat.Action.  Builder  (android.R.drawable.ic_menu_send,\n                  \"Reply\"  , replyPendingIntent)\n                  .  addRemoteInput  (remoteInput)\n                  .  build  ();\n    \n   // Notification builder\n   NotificationCompat  .  Builder   builder   =\n          new   NotificationCompat.  Builder  (  this  )\n                  .  setSmallIcon  (R.mipmap.ic_launcher)\n                  .  setContentTitle  (  \"Title\"  )\n                  .  setContentText  (  \"Notification text\"  )\n                  .  addAction  (action);\n    \n   // Notification\n   Notification   notification   =   builder.  build  ();\n    \n   // Show notification\n   NotificationManager   notificationManager   =\n          (NotificationManager)   getSystemService  (NOTIFICATION_SERVICE);\n   notificationManager.  notify  (itemId, notification);\n  Розбираємо код по порядку.  У нас є якийсь   itemId . Це може бути, наприклад,   id  чату, в який прийшло нове повідомлення.  Створюємо   Intent  і   PendingIntent . Тут нічого нового. Ми будемо викликати сервіс   MyService  і передавати йому   itemId . У   PendingIntent  використовуємо   itemId  як   requestCode .  Далі створюємо   RemoteInput . Тут налаштовуємо все, що стосується поля введення, яке буде відображено в повідомленні. У конструкторі білдера необхідно вказати ключ, який ми надалі будемо використовувати, щоб із   Bundle  дістати текст, який введе користувач. У метод   setLabel  можна передати текст, який буде використаний як   hint  (підказка) у полі введення.  Створюємо   Action  кнопку за допомогою білдера. Передаємо туди стандартний набір: іконку, текст і   PendingIntent . А в метод   addRemoteInput  передаємо раніше створений   RemoteInput . Це буде   Action  кнопка   Reply , після натискання на яку з'являтиметься рядок введення.  Далі використовуємо створений   Action  у білдері сповіщення, створюємо сповіщення і відображаємо його.  У методі   notify  використовуємо   itemId . Відповідно, знаючи   id  чату, ми завжди зможемо оновити або видалити повідомлення.  Зверніть увагу, що   PendingIntent , який ми створюємо і використовуємо в   Action  кнопці   Reply , буде використаний не після натискання на сповіщення, і навіть не після натискання на   Reply . Він буде використаний, коли користувач натисне на кнопку надсилання тексту.  У цьому прикладі, до речі, після натискання на сповіщення, нічого не станеться, тому що в білдері сповіщення я не використовував метод   setContentIntent , щоб не ускладнювати приклад.  Запускаємо\n   У повідомленні створюється   Action  кнопка   Reply . Вона відкриває рядок введення.  Після натискання на кнопку надсилання тексту система запускає   MyService , який ми вказували в   PedningIntent , і відображає   прогресбар . Але він буде крутитися нескінченно, поки ми програмно не оновимо або не видалимо повідомлення.  Давайте подивимося, як у   MyService  ми можемо отримати введений користувачем текст і прибрати   прогрессбар  з повідомлення:     if   (ACTION_REPLY.  equals  (intent.  getAction  ())) {\n    \n      // Get reply text\n      CharSequence   replyText   =   null  ;\n      Bundle   results   =   RemoteInput.  getResultsFromIntent  (intent);\n      if   (results   !=   null  ) {\n          replyText   =   results.  getCharSequence  (EXTRA_TEXT_REPLY);\n      }\n    \n      // Get itemId\n      int   itemId   =   intent.  getIntExtra  (EXTRA_ITEM_ID,   0  );\n    \n      // Perform operations with replyText and itemId\n      ...\n    \n      // Create new notification\n      Notification   repliedNotification   =\n              new   NotificationCompat.  Builder  (  getBaseContext  ())\n                      .  setSmallIcon  (R.mipmap.ic_launcher)\n                      .  setContentText  (  \"Replied\"  )\n                      .  build  ();\n    \n      // Update notification\n      NotificationManager   mNotificationManager   =\n              (NotificationManager)   getSystemService  (Context.NOTIFICATION_SERVICE);\n      mNotificationManager.  notify  (itemId, repliedNotification);\n    \n   }\n  Методом   RemoteInput.getResultsFromIntent  дістаємо   Bundle  з   Intent . З цього   Bundle  можемо дістати текст, який вводив користувач у повідомленні. Для цього використовуємо ключ   EXTRA_TEXT_REPLY  (який раніше використовували в білдері   RemoteInput ).  Далі з   Intent  дістаємо   itemId .  Тепер у нас є   id  чату і текст, який ввів користувач. Можемо зберегти його в БД, відправити на сервер або зробити ще щось. Це залежить від логіки програми.  Далі нам необхідно розібратися з повідомленням. Нагадаю, що після надсилання тексту воно відображає прогрессбар. У цьому прикладі ми створюємо просте сповіщення з текстом   Replied  і замінюємо ним (використовуючи той самий   itemId  у методі   notify ) те сповіщення, з якого було надіслано текст.  Пробуємо ще раз надіслати текст із сповіщення\n  \nЦього разу ми в обробнику оновили сповіщення і прогресбар зник.  Що ви будете робити з повідомленням після надсилання тексту - це ваше рішення. Наприклад, ви можете просто видалити його. Або, якщо ви в повідомленні відображаєте останні повідомлення чату, ви можете оновити це повідомлення з урахуванням нового повідомлення і знову зробити там кнопку   Reply .  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1263,"path":1264,"dir":1137,"title":1265,"description":1266,"keywords":1267,"body":1268},"content:1.android:10.lesson10:14.notifications-custom.md","/android/lesson10/notifications-custom","Notifications. Кастомні сповіщення","\nAndroid надає нам можливість самим створити layout для повідомлень.",[],"  Notifications. Кастомні сповіщення   \nAndroid надає нам можливість самим створити   layout  для повідомлень.  Розглянемо простий приклад:   layout/notification.xml     \u003C?  xml   version  =  \"1.0\"   encoding  =  \"utf-8\"  ?>\n   \u003C  LinearLayout   xmlns:android  =  \"http://schemas.android.com/apk/res/android\"\n      android:id  =  \"@+id/root\"\n      android:layout_width  =  \"match_parent\"\n      android:layout_height  =  \"64dp\"\n      android:orientation  =  \"horizontal\"  >\n    \n      \u003C  TextView\n          android:id  =  \"@+id/textView\"\n          android:layout_width  =  \"wrap_content\"\n          android:layout_height  =  \"wrap_content\"\n          android:layout_marginStart  =  \"8dp\"\n          android:layout_marginTop  =  \"8dp\"\n          android:text  =  \"TextView\"\n          android:textAppearance  =  \"@style/TextAppearance.Compat.Notification.Title\"   />\n    \n   \u003C/  LinearLayout  >\n  Висота   64dp  - стандартна висота повідомлення.  Будемо показувати тільки   TextView . Рекомендується використовувати   @style/TextAppearance.Compat.Notification.*  стилі, щоб ваш текст коректно відображався на будь-якій версії Android.  Код білдера повідомлення має такий вигляд:     RemoteViews   remoteViews   =   new   RemoteViews  (  getPackageName  (), R.layout.notification);\n   remoteViews.  setTextViewText  (R.id.textView,   \"Custom notification text\"  );\n   remoteViews.  setOnClickPendingIntent  (R.id.root, rootPendingIntent);\n    \n   NotificationCompat  .  Builder   builder   =   new   NotificationCompat.  Builder  (  this  )\n          .  setSmallIcon  (R.mipmap.ic_launcher)\n          .  setContent  (remoteViews);\n  Створюємо   RemoteViews  з   layout  файлу.  Методом   setTextViewText  поміщаємо текст у   View c id = R.id.textView .  А методом   setOnClickPendingIntent  вказуємо   PendingIntent , який буде викликаний при натисканні на   View з id = R.id.root . У нашому прикладі   root  - це кореневий   LinearLayout . Відповідно під час натискання на сповіщення, буде використано цей   PendingIntent , щоб запустити   Activity/Service/BroadcastReceiver .  У білдері залишається необхідність вказати іконку, яку буде видно в області повідомлень. А ось методи   setContentTitle  і   setContentText  не потрібні. Замість них використовуємо   setContent  і передаємо туди створений   RemoteViews .  У результаті побачимо своє повідомлення\n   Для порівняння поруч відображено стандартне повідомлення.  Є ще один, новіший, спосіб створення кастомного повідомлення - використання стилю   DecoratedCustomViewStyle .     RemoteViews   remoteViews   =   new   RemoteViews  (  getPackageName  (), R.layout.notification);\n   remoteViews.  setTextViewText  (R.id.textView,   \"Custom notification text\"  );\n   remoteViews.  setOnClickPendingIntent  (R.id.root, rootPendingIntent);\n    \n   NotificationCompat  .  Builder   builder   =   new   NotificationCompat.  Builder  (  this  )\n          .  setSmallIcon  (R.mipmap.ic_launcher)\n          .  setCustomContentView  (remoteViews)\n          .  setStyle  (  new   NotificationCompat.  DecoratedCustomViewStyle  ());\n  Відмінність від старого способу в тому, що ми викликаємо метод   setCustomContentView , а не   setContent , і використовуємо стиль   DecoratedCustomViewStyle .  Результат:\n   Зверніть увагу, що в цьому разі кастомізується вже не все сповіщення, а тільки його зміст. А інші частини сповіщення, як-от іконка, час або action кнопки залишаться на своїх місцях.  Використання   DecoratedCustomViewStyle  дає нам можливість кастомізувати і розширене повідомлення.  Приклад     RemoteViews   remoteViews   =   new   RemoteViews  (  getPackageName  (), R.layout.notification);\n   remoteViews.  setTextViewText  (R.id.textView,   \"Custom notification text\"  );\n   remoteViews.  setOnClickPendingIntent  (R.id.root, rootPendingIntent);\n    \n   RemoteViews   remoteViewsExtended   =   new   RemoteViews  (  getPackageName  (), R.layout.extended_notification);\n   remoteViewsExtended.  setTextViewText  (R.id.textView,   \"Extended custom notification text\"  );\n   remoteViewsExtended.  setOnClickPendingIntent  (R.id.root, rootPendingIntent);\n    \n   NotificationCompat  .  Builder   builder   =   new   NotificationCompat.  Builder  (  this  )\n          .  setSmallIcon  (R.mipmap.ic_launcher)\n          .  setCustomContentView  (remoteViews)\n          .  setCustomBigContentView  (remoteViewsExtended)\n          .  setStyle  (  new   NotificationCompat.  DecoratedCustomViewStyle  ());\n  Тут ми кастомізуємо і звичайний вигляд повідомлення (  setCustomContentView ), і розширений (  setCustomBigContentView ).  Результат:\n   Висота layout розширеного повідомлення має бути не більшою за   256dp .  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1270,"path":1271,"dir":1137,"title":1272,"description":1273,"keywords":1274,"body":1277},"content:1.android:10.lesson10:15.notifications-groups.md","/android/lesson10/notifications-groups","Notifications. Групування сповіщень","В Android 7 (API 24) з'явилася можливість групувати сповіщення. Навіть якщо ви це явно не реалізуєте, система сама створить групу, якщо у вас 4 і більше повідомлень.",[1275,1276],"Коли створювати групу","Сортування в групі","  Notifications. Групування сповіщень  В Android 7 (API 24) з'явилася можливість групувати сповіщення. Навіть якщо ви це явно не реалізуєте, система сама створить групу, якщо у вас   4  і більше повідомлень.  Виглядає це так:\n   Ви можете розгорнути/згорнути/видалити групу. На окреме повідомлення ви також можете натиснути або видалити його. Якщо сповіщень у групі стає менше 4, то сповіщення стають окремими від групи.  Усі ваші сповіщення потраплятимуть в одну безіменну групу. За замовчуванням, натискання на цю групу відкриє застосунок.  Розглянемо, які можливості управління групами нам надано.  Ми можемо:   створювати кілька груп і самі вирішувати, в яку з них піде нове повідомлення. Група відображатиметься, коли в ній є хоча б два повідомлення.  додати до групи текстовий опис  додати до групи   PendingIntent , який спрацює після натискання на групу  Як приклад можна розглянути поштовий додаток. У користувача є кілька акаунтів і в них приходять нові листи. Буде розумно створювати окрему групу для кожного акаунта. Кожна така група відображатиме тільки ті листи, які знаходяться в певному акаунті.  Розглянемо на практиці. Створюємо повідомлення:     NotificationCompat  .  Builder   mBuilder   =\n          new   NotificationCompat.  Builder  (  this  )\n                  .  setSmallIcon  (R.mipmap.ic_launcher)\n                  .  setContentTitle  (  \"Sender \"   +   1  )\n                  .  setContentText  (  \"Subject text \"   +   1  )\n                  .  setGroup  (GROUP_KEY);\n    \n   Notification   notification   =   mBuilder.  build  ();\n    \n   NotificationManager   notificationManager   =\n          (NotificationManager)   getSystemService  (NOTIFICATION_SERVICE);\n   notificationManager.  notify  (  1  , notification);\n  Повідомлення створюється так само, як зазвичай. Додано тільки метод   setGroup . У ньому нам потрібно вказати   String  ключ групи, щоб система знала, в яку групу поміщати це повідомлення.  Створюємо групу:     NotificationCompat  .  Builder   mBuilder   =\n          new   NotificationCompat.  Builder  (  this  )\n                  .  setSmallIcon  (R.mipmap.ic_launcher)\n                  .  setContentInfo  (  \"user_mail.com\"  )\n                  .  setGroup  (GROUP_KEY)\n                  .  setGroupSummary  (  true  );\n    \n   Notification   notification   =   mBuilder.  build  ();\n    \n   NotificationManager   notificationManager   =\n          (NotificationManager)   getSystemService  (NOTIFICATION_SERVICE);\n   notificationManager.  notify  (  -  100  , notification);\n  Група створюється так само, як і повідомлення. Але тексти, які ми зазвичай передаємо в   setContentTitle  і   setContentTitle , у групі не відображаються, тому я в прикладі їх не використовую. Щоправда, у наступних версіях Android відображення груп може змінитися, і вони раптом почнуть відображати   title  і   text . Може і має сенс передавати туди що-небудь.  А ось текст із методу   setContentInfo  буде відображено, і це дає нам змогу дати якийсь текстовий опис для групи, щоб користувач розумів, про що вона. Оскільки ми розглядаємо приклад поштового застосунку, то можна використовувати ім'я акаунта користувача. Користувач буде бачити, в якій групі, вміст якого акаунта відображається.  У   setGroup  передаємо   String  ключ групи. Його ж ми використовуємо при створенні повідомлень, які повинні потрапляти в цю групу.  У   setGroupSummary  вказуємо   true . Це означає, що повідомлення є групою.  У методі   notify , так само, як і для звичайного повідомлення, необхідно вказувати   id . Тут будьте уважні і стежте, щоб у повідомлення і у групи не збіглися   id . Група все-таки є звичайним повідомленням. А в разі збігу   id , одне повідомлення замінить інше.  Як варіант, для повідомлень про новий лист можна брати   id  листа, а для груп - від'ємне значення   id  акаунта. Тоді вони точно не перетнуться.  У підсумку ви отримаєте таку картину\n   Три нові листи зібралися в одну групу. І в описі групи видно, що вона відображає листи акаунта   user@mail.com .  Коли створювати групу  Групу має сенс відображати щоразу після створення повідомлення, яке входить до цієї групи. Якщо група вже існує і відображається, то просто нічого не станеться (якщо ви не змінювали параметри групи).  А якщо ми відобразимо групу тільки один раз, і користувач у якийсь момент видалить її з повідомлень, то всі наші нові повідомлення залишаться без групи.  Сортування в групі  Ви можете сортувати сповіщення в групі, використовуючи метод   setSortKey  у білдері кожного сповіщення. Передаєте в нього строкове значення, і за ним буде виконуватися сортування.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":1279,"path":1280,"dir":1137,"title":1281,"description":1282,"keywords":1283,"body":1287},"content:1.android:10.lesson10:16.notifications-channel.md","/android/lesson10/notifications-channel","Notifications. Канали","В Android Oreo (API 26) з'явилася можливість створювати канали для сповіщень. У цьому уроці розберемося, як це робити і навіщо це потрібно.",[1284,1285,1286],"Група","Отримання інформації про канал","Видалення каналу","  Notifications. Канали  В Android Oreo (API 26) з'явилася можливість створювати канали для сповіщень. У цьому уроці розберемося, як це робити і навіщо це потрібно.  Для кожної програми користувач може налаштувати сповіщення. Для цього треба зайти в налаштування системи, там вибрати Apps, знайти в списку і відкрити потрібний застосунок і вибрати розділ   Notifications .  За замовчуванням налаштування виглядають так:    Налаштувань небагато, і вони торкнуться всіх повідомлень від цієї програми.  Канали дають змогу розширити ці налаштування і застосовувати їх вибірково. Розробник застосунку створює канал і вказує його   ID  під час створення повідомлень. Користувач у системних налаштуваннях програми бачить цей канал і може налаштувати його: важливість, звук, вібру тощо. У підсумку всі сповіщення, які належать цьому каналу, відображатимуться з цими налаштуваннями.  Тобто створюючи канал, розробник дає користувачеві можливість налаштувати поведінку певної групи повідомлень.  Давайте створимо канал:     NotificationManager   notificationManager   =\n          (NotificationManager)   getSystemService  (Context.NOTIFICATION_SERVICE);\n    \n   if   (android.os.Build.VERSION.SDK_INT   >=   android.os.Build.VERSION_CODES.O) {\n      NotificationChannel   channel   =   new   NotificationChannel  (CHANNEL_ID,   \"My channel\"  ,\n              NotificationManager.IMPORTANCE_HIGH);\n      channel.  setDescription  (  \"My channel description\"  );\n      channel.  enableLights  (  true  );\n      channel.  setLightColor  (Color.RED);\n      channel.  enableVibration  (  false  );\n      notificationManager.  createNotificationChannel  (channel);\n   }\n  Канали актуальні тільки для Android Oreo і вище, тому використовується перевірка версії Android. Далі я не буду включати цю перевірку в приклади, щоб не захаращувати код.  У конструкторі   NotificationChannel  вказуємо   ID , ім'я та важливість. Далі вказуємо інші дані та налаштування. За назвою методів усе зрозуміло.  Методом   createNotificationChannel  створюємо канал.  Тепер   Notifications  налаштування застосунку мають такий вигляд:\n   З'явилися два канали: дефолтний і наш створений My channel. Налаштування дефолтного будуть використані для повідомлень, для яких не було вказано канал.  Відкриємо налаштування My channel:\n   Зверніть увагу, що пункт Vibrate вимкнений. Ми явно вказали це під час створення каналу, використовуючи метод   enableVibration(false) .  Тепер під час створення сповіщень ви можете вказати ID каналу, і сповіщення буде відображено відповідно до налаштувань цього каналу.     NotificationCompat  .  Builder   builder   =\n          new   NotificationCompat.  Builder  (  this  , CHANNEL_ID)\n                  .  setSmallIcon  (R.mipmap.ic_launcher)\n                  .  setContentTitle  (  \"Title\"  )\n                  .  setContentText  (  \"Notification text\"  );\n  ID каналу вказується в конструкторі білдера повідомлення. І тепер цей конструктор не буде закреслено як   Deprecated , якщо ви використовуєте бібліотеку   appCompat  версії 26 і вище.  У який момент створювати канал? Можна під час старту програми. Навіть якщо канал уже був раніше створений, то просто нічого не станеться. Але судячи з того, що користувач не може видаляти канали, я думаю, можна використати якийсь прапор, який ми встановимо в true після першого створення каналів, і надалі він буде говорити нам про те, що канали вже створені.  Група  Розглянемо приклад поштового додатка. Припустимо, що він уміє працювати не тільки з поштою, а й з календарем. Тобто він може нам надсилати повідомлення двох типів: листи і події.  Відповідно, ми можемо створити два канали - один для повідомлень про листи, інший - для подій. У результаті, користувач сам зможе налаштувати під себе окремо повідомлення про листи й окремо про події. Це зручно.  Але наш застосунок підтримує кілька облікових записів. І під кожен обліковий запис нам необхідно створювати два канали для повідомлень.  При створенні 4-х каналів налаштування будуть виглядати так:\n   Можна це поліпшити, використовуючи групи. Група - це просто спосіб візуально розділити канали в налаштуваннях.  Створюється група так:     NotificationManager   notificationManager   =\n          (NotificationManager)   getSystemService  (Context.NOTIFICATION_SERVICE);\n   notificationManager.  createNotificationChannelGroup  (\n          new   NotificationChannelGroup  (GROUP_ID,   \"Group 1\"  ));\n  У конструкторі вказуємо   ID  та ім'я.  Далі, при створенні каналу використовуємо метод   setGroup , щоб вказати, якій групі буде належати канал.     NotificationChannel   channel   =   new   NotificationChannel  (...);\n   // ...\n   channel.  setGroup  (GROUP_ID);\n   notificationManager.  createNotificationChannel  (channel);\n  Таким чином, для кожного облікового запису нашого застосунку ми можемо створити групу і вказати її під час створення каналів повідомлень цього облікового запису:     User   A   (group)\n       Mail   (channel)\n       Events   (channel)\n   User   B   (group)\n       Mail   (channel)\n       Events   (channel)\n  Тепер налаштування мають кращий вигляд:\n  \nКанали згруповані за обліковими записами.  Отримання інформації про канал  У будь-який момент після створення каналу, ви можете отримати інформацію про нього.     NotificationChannel   channel   =   notificationManager.  getNotificationChannel  (CHANNEL_ID);\n  Метод   getNotificationChannel  поверне вам об'єкт   NotificationChannel  або   null , якщо канал із зазначеним   ID  не було знайдено. Використовуючи різні   get -методи каналу, ви зможете дізнатися, як користувач налаштував ваш канал. Але ви не зможете переналаштувати його,   set -методи просто не працюватимуть.  Єдине, що ви можете змінити - це ім'я каналу і його опис (  description ). Для цього необхідно просто перестворити канал із новими параметрами і тим самим   ID .  Якщо ви рахували налаштування каналу і з якихось причин вирішили, що користувач не правий, то ви можете попросити його змінити налаштування.  Наприклад, якщо користувач вимкнув відображення повідомлень для каналу, відкриваємо налаштування цього каналу.     NotificationChannel   channel   =   notificationManager.  getNotificationChannel  (CHANNEL_ID);\n    \n   if   (channel.  getImportance  ()   ==   NotificationManager.IMPORTANCE_NONE) {\n      Intent   intent   =   new   Intent  (Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS);\n      intent.  putExtra  (Settings.EXTRA_CHANNEL_ID, channel.  getId  ());\n      intent.  putExtra  (Settings.EXTRA_APP_PACKAGE,   getPackageName  ());\n      startActivity  (intent);\n   }\n  Якщо   getImportance  дорівнює   IMPORTANCE_NONE , це означає, що канал був вимкнений користувачем. Створюємо   Intent  із зазначенням ID каналу та package додатка і запускаємо   Activity .  Зрозуміло, у реальному застосунку треба діяти не так незграбно, а спершу поцікавитися думкою користувача і пояснити, чому ви хочете, щоб він змінив налаштування каналу.  Видалення каналу  Щоб видалити канал, використовуйте метод   deleteNotificationChannel     notificationManager.  deleteNotificationChannel  (CHANNEL_ID);\n  Технічно ви, звичайно, можете використовувати видалення, а потім створення каналу, щоб відновити ваші налаштування. Але так робити не рекомендується. До того ж у налаштуваннях, у самому низу, користувач бачитиме, скільки каналів було видалено.\n   І він зрозуміє, що ви просто перестворюєте канал і скидаєте його налаштування.   Importance vs Priority  Якщо ви пам'ятаєте, при створенні повідомлення, ми можемо в білдері вказати пріоритет. Починаючи з Android Oreo пріоритети сповіщень були оголошені застарілими і замінені параметром каналу - важливість.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",1736105742161]